{"./":{"url":"./","title":"前言","keywords":"","body":" 前言1. go基础语法-快速入门2. 前言 前言 1. go基础语法-快速入门 https://github1s.com/515250339/goland/blob/HEAD/00基础语法/ 2. 前言 “Go是一个开源的编程语言，它很容易用于构建简单、可靠和高效的软件。”（摘自Go语言官方网站：http://golang.org） Go语言由来自Google公司的Robert Griesemer，Rob Pike和Ken Thompson三位大牛于2007年9月开始设计和实现，然后于2009年的11月对外正式发布（译注：关于Go语言的创世纪过程请参考http://talks.golang.org/2015/how-go-was-made.slide）。语言及其配套工具的设计目标是具有表达力，高效的编译和执行效率，有效地编写高效和健壮的程序。 Go语言有着和C语言类似的语法外表，和C语言一样是专业程序员的必备工具，可以用最小的代价获得最大的战果。 但是它不仅仅是一个更新的C语言。它还从其他语言借鉴了很多好的想法，同时避免引入过度的复杂性。 Go语言中和并发编程相关的特性是全新的也是有效的，同时对数据抽象和面向对象编程的支持也很灵活。 Go语言同时还集成了自动垃圾收集技术用于更好地管理内存。 Go语言尤其适合编写网络服务相关基础设施，同时也适合开发一些工具软件和系统软件。 但是Go语言确实是一个通用的编程语言，它也可以用在图形图像驱动编程、移动应用程序开发 和机器学习等诸多领域。目前Go语言已经成为受欢迎的作为无类型的脚本语言的替代者： 因为Go编写的程序通常比脚本语言运行的更快也更安全，而且很少会发生意外的类型错误。 Go语言还是一个开源的项目，可以免费获取编译器、库、配套工具的源代码。 Go语言的贡献者来自一个活跃的全球社区。Go语言可以运行在类UNIX系统—— 比如Linux、FreeBSD、OpenBSD、Mac OSX——和Plan9系统和Microsoft Windows操作系统之上。 Go语言编写的程序无需修改就可以运行在上面这些环境。 本书是为了帮助你开始以有效的方式使用Go语言，充分利用语言本身的特性和自带的标准库去编写清晰地道的Go程序。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"qian-yan/goyu-yan-qi-yuan.html":{"url":"qian-yan/goyu-yan-qi-yuan.html","title":"Go语言起源","keywords":"","body":"1. Go语言起源 1. Go语言起源 编程语言的演化跟生物物种的演化类似，一个成功的编程语言的后代一般都会继承它们祖先的优点；当然有时多种语言杂合也可能会产生令人惊讶的特性；还有一些激进的新特性可能并没有先例。通过观察这些影响，我们可以学到为什么一门语言是这样子的，它已经适应了怎样的环境。 下图展示了有哪些早期的编程语言对Go语言的设计产生了重要影响。 Go语言有时候被描述为“C类似语言”，或者是“21世纪的C语言”。Go从C语言继承了相似的表达式语法、控制流结构、基础数据类型、调用参数传值、指针等很多思想，还有C语言一直所看中的编译后机器码的运行效率以及和现有操作系统的无缝适配。 但是在Go语言的家族树中还有其它的祖先。其中一个有影响力的分支来自Niklaus Wirth所设计的Pascal语言。然后Modula-2语言激发了包的概念。然后Oberon语言摒弃了模块接口文件和模块实现文件之间的区别。第二代的Oberon-2语言直接影响了包的导入和声明的语法，还有Oberon语言的面向对象特性所提供的方法的声明语法等。 Go语言的另一支祖先，带来了Go语言区别其他语言的重要特性，灵感来自于贝尔实验室的Tony Hoare于1978年发表的鲜为外界所知的关于并发研究的基础文献顺序通信进程（communicating sequential processes，缩写为CSP。在CSP中，程序是一组中间没有共享状态的平行运行的处理过程，它们之间使用管道进行通信和控制同步。不过Tony Hoare的CSP只是一个用于描述并发性基本概念的描述语言，并不是一个可以编写可执行程序的通用编程语言。 接下来，Rob Pike和其他人开始不断尝试将CSP引入实际的编程语言中。他们第一次尝试引入CSP特性的编程语言叫Squeak（老鼠间交流的语言），是一个提供鼠标和键盘事件处理的编程语言，它的管道是静态创建的。然后是改进版的Newsqueak语言，提供了类似C语言语句和表达式的语法和类似Pascal语言的推导语法。Newsqueak是一个带垃圾回收的纯函数式语言，它再次针对键盘、鼠标和窗口事件管理。但是在Newsqueak语言中管道是动态创建的，属于第一类值，可以保存到变量中。 在Plan9操作系统中，这些优秀的想法被吸收到了一个叫Alef的编程语言中。Alef试图将Newsqueak语言改造为系统编程语言，但是因为缺少垃圾回收机制而导致并发编程很痛苦。（译注：在Alef之后还有一个叫Limbo的编程语言，Go语言从其中借鉴了很多特性。 具体请参考Pike的讲稿：http://talks.golang.org/2012/concurrency.slide#9） Go语言的其他的一些特性零散地来自于其他一些编程语言；比如iota语法是从APL语言借鉴，词法作用域与嵌套函数来自于Scheme语言（和其他很多语言）。当然，我们也可以从Go中发现很多创新的设计。比如Go语言的切片为动态数组提供了有效的随机存取的性能，这可能会让人联想到链表的底层的共享机制。还有Go语言新发明的defer语句。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"qian-yan/goyu-yan-xiang-mu.html":{"url":"qian-yan/goyu-yan-xiang-mu.html","title":"Go语言项目","keywords":"","body":"1. Go语言项目 1. Go语言项目 所有的编程语言都反映了语言设计者对编程哲学的反思，通常包括之前的语言所暴露的一些不足地方的改进。Go项目是在Google公司维护超级复杂的几个软件系统遇到的一些问题的反思（但是这类问题绝不是Google公司所特有的）。 正如Rob Pike所说，“软件的复杂性是乘法级相关的”，通过增加一个部分的复杂性来修复问题通常将慢慢地增加其他部分的复杂性。通过增加功能、选项和配置是修复问题的最快的途径，但是这很容易让人忘记简洁的内涵，即从长远来看，简洁依然是好软件的关键因素。 简洁的设计需要在工作开始的时候舍弃不必要的想法，并且在软件的生命周期内严格区别好的改变和坏的改变。通过足够的努力，一个好的改变可以在不破坏原有完整概念的前提下保持自适应，正如Fred Brooks所说的“概念完整性”；而一个坏的改变则不能达到这个效果，它们仅仅是通过肤浅的和简单的妥协来破坏原有设计的一致性。只有通过简洁的设计，才能让一个系统保持稳定、安全和持续的进化。 Go项目包括编程语言本身，附带了相关的工具和标准库，最后但并非代表不重要的是，关于简洁编程哲学的宣言。就事后诸葛的角度来看，Go语言的这些地方都做的还不错：拥有自动垃圾回收、一个包系统、函数作为一等公民、词法作用域、系统调用接口、只读的UTF8字符串等。但是Go语言本身只有很少的特性，也不太可能添加太多的特性。例如，它没有隐式的数值转换，没有构造函数和析构函数，没有运算符重载，没有默认参数，也没有继承，没有泛型，没有异常，没有宏，没有函数修饰，更没有线程局部存储。但是，语言本身是成熟和稳定的，而且承诺保证向后兼容：用之前的Go语言编写程序可以用新版本的Go语言编译器和标准库直接构建而不需要修改代码。 Go语言有足够的类型系统以避免动态语言中那些粗心的类型错误，但是，Go语言的类型系统相比传统的强类型语言又要简洁很多。虽然，有时候这会导致一个“无类型”的抽象类型概念，但是Go语言程序员并不需要像C++或Haskell程序员那样纠结于具体类型的安全属性。在实践中，Go语言简洁的类型系统给程序员带来了更多的安全性和更好的运行时性能。 Go语言鼓励当代计算机系统设计的原则，特别是局部的重要性。它的内置数据类型和大多数的准库数据结构都经过精心设计而避免显式的初始化或隐式的构造函数，因为很少的内存分配和内存初始化代码被隐藏在库代码中了。Go语言的聚合类型（结构体和数组）可以直接操作它们的元素，只需要更少的存储空间、更少的内存写操作，而且指针操作比其他间接操作的语言也更有效率。由于现代计算机是一个并行的机器，Go语言提供了基于CSP的并发特性支持。Go语言的动态栈使得轻量级线程goroutine的初始栈可以很小，因此，创建一个goroutine的代价很小，创建百万级的goroutine完全是可行的。 Go语言的标准库（通常被称为语言自带的电池），提供了清晰的构建模块和公共接口，包含I/O操作、文本处理、图像、密码学、网络和分布式应用程序等，并支持许多标准化的文件格式和编解码协议。库和工具使用了大量的约定来减少额外的配置和解释，从而最终简化程序的逻辑，而且，每个Go程序结构都是如此的相似，因此，Go程序也很容易学习。使用Go语言自带工具构建Go语言项目只需要使用文件名和标识符名称，一个偶尔的特殊注释来确定所有的库、可执行文件、测试、基准测试、例子、以及特定于平台的变量、项目的文档等；Go语言源代码本身就包含了构建规范。 2. console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"goji-chu-zhi-shi.html":{"url":"goji-chu-zhi-shi.html","title":"GO基础知识","keywords":"","body":" 安装go 安装go go安装文档 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"goji-chu-zhi-shi/gogai-shu.html":{"url":"goji-chu-zhi-shi/gogai-shu.html","title":"go概述","keywords":"","body":" Go 语言的起源，发展与普及1.1. 语言的主要特性与发展的环境和影响因素 Go 语言的起源，发展与普及 Go 语言起源 2007 年，并于 2009 年正式对外发布。它从 2009 年 9 月 21 日开始作为谷歌公司 20% 兼职项目，即相关员工利用 20% 的空余时间来参与 Go 语言的研发工作。该项目的三位领导者均是著名的 IT 工程师：Robert Griesemer，参与开发 Java HotSpot 虚拟机；Rob Pike，Go 语言项目总负责人，贝尔实验室 Unix 团队成员，参与的项目包括 Plan 9，Inferno 操作系统和 Limbo 编程语言；Ken Thompson，贝尔实验室 Unix 团队成员，C 语言、Unix 和 Plan 9 的创始人之一，与 Rob Pike 共同开发了 UTF-8 字符集规范。自 2008 年 1 月起，Ken Thompson 就开始研发一款以 C 语言为目标结果的编译器来拓展 Go 语言的设计思想。 这是一个由计算机领域 “发明之父” 所组成的黄金团队，他们对系统编程语言，操作系统和并行都有着非常深刻的见解 在 2008 年年中，Go 语言的设计工作接近尾声，一些员工开始以全职工作状态投入到这个项目的编译器和运行实现上。Ian Lance Taylor 也加入到了开发团队中，并于 2008 年 5 月创建了一个 gcc 前端。 Russ Cox 加入开发团队后着手语言和类库方面的开发，也就是 Go 语言的标准包。在 2009 年 10 月 30 日，Rob Pike 以 Google Techtalk 的形式第一次向人们宣告了 Go 语言的存在。 直到 2009 年 11 月 10 日，开发团队将 Go 语言项目以 BSD-style 授权（完全开源）正式公布了 Linux 和 Mac OS X 平台上的版本。Hector Chu 于同年 11 月 22 日公布了 Windows 版本。 作为一个开源项目，Go 语言借助开源社区的有生力量达到快速地发展，并吸引更多的开发者来使用并改善它。自该开源项目发布以来，超过 200 名非谷歌员工的贡献者对 Go 语言核心部分提交了超过 1000 个修改建议。在过去的 18 个月里，又有 150 开发者贡献了新的核心代码。这俨然形成了世界上最大的开源团队，并使该项目跻身 Ohloh 前 2% 的行列。大约在 2011 年 4 月 10 日，谷歌开始抽调员工进入全职开发 Go 语言项目。开源化的语言显然能够让更多的开发者参与其中并加速它的发展速度。Andrew Gerrand 在 2010 年加入到开发团队中成为共同开发者与支持者。 在 Go 语言在 2010 年 1 月 8 日被 Tiobe（闻名于它的编程语言流行程度排名）宣布为 “2009 年年度语言” 后，引起各界很大的反响。目前 Go 语言在这项排名中的最高记录是在 2017 年 1 月创下的第13名，流行程度 2.325%。 时间轴： 2007 年 9 月 21 日：雏形设计 2009 年 11 月 10日：首次公开发布 2010 年 1 月 8 日：当选 2009 年年度语言 2010 年 5 月：谷歌投入使用 2011 年 5 月 5 日：Google App Engine 支持 Go 语言 从 2010 年 5 月起，谷歌开始将 Go 语言投入到后端基础设施的实际开发中，例如开发用于管理后端复杂环境的项目。有句话叫 “吃你自己的狗食”，这也体现了谷歌确实想要投资这门语言，并认为它是有生产价值的。 Go 语言的官方网站是 golang.org，这个站点采用 Python 作为前端，并且使用 Go 语言自带的工具 godoc 运行在 Google App Engine 上来作为 Web 服务器提供文本内容。在官网的首页有一个功能叫做 Go Playground，是一个 Go 代码的简单编辑器的沙盒，它可以在没有安装 Go 语言的情况下在你的浏览器中编译并运行 Go，它提供了一些示例，其中包括国际惯例 “Hello, World!”。 1.1. 语言的主要特性与发展的环境和影响因素 影响 Go 语言发展的早期编程语言 正如 “21 世纪的 C 语言” 这句话所说，Go 语言并不是凭空而造的，而是和 C++、Java 和 C# 一样属于 C 系。不仅如此，设计者们还汲取了其它编程语言的精粹部分融入到 Go 语言当中。 在声明和包的设计方面，Go 语言受到 Pascal、Modula 和 Oberon 系语言的影响；在并发原理的设计上，Go 语言从同样受到 Tony Hoare 的 CSP（通信序列进程 Communicating Squential Processes）理论影响的 Limbo 和 Newsqueak 的实践中借鉴了一些经验，并使用了和 Erlang 类似的机制。 这是一门完全开源的编程语言，因为它使用 BSD 授权许可，所以任何人都可以进行商业软件的开发而不需要支付任何费用。 尽管为了能够让目前主流的开发者们能够对 Go 语言中的类 C 语言的语法感到非常亲切而易于转型，但是它在极大程度上简化了这些语法，使得它们比 C/C++ 的语法更加简洁和干净。同时，Go 语言也拥有一些动态语言的特性，这使得使用 Python 和 Ruby 的开发者们在使用 Go 语言的时候感觉非常容易上手。 为什么要创造一门编程语言 C/C++ 的发展速度无法跟上计算机发展的脚步，十多年来也没有出现一门与时代相符的主流系统编程语言，因此人们需要一门新的系统编程语言来弥补这个空缺，尤其是在计算机信息时代。 相比计算机性能的提升，软件开发领域不被认为发展得足够快或者比硬件发展得更加成功（有许多项目均以失败告终），同时应用程序的体积始终在不断地扩大，这就迫切地需要一门具备更高层次概念的低级语言来突破现状。 在 Go 语言出现之前，开发者们总是面临非常艰难的抉择，究竟是使用执行速度快但是编译速度并不理想的语言（如：C++），还是使用编译速度较快但执行效率不佳的语言（如：.NET、Java），或者说开发难度较低但执行速度一般的动态语言呢？显然，Go 语言在这 3 个条件之间做到了最佳的平衡：快速编译，高效执行，易于开发。 Go 语言的发展目标 Go 语言的主要目标是将静态语言的安全性和高效性与动态语言的易开发性进行有机结合，达到完美平衡，从而使编程变得更加有乐趣，而不是在艰难抉择中痛苦前行。 因此，Go 语言是一门类型安全和内存安全的编程语言。虽然 Go 语言中仍有指针的存在，但并不允许进行指针运算。 Go 语言的另一个目标是对于网络通信、并发和并行编程的极佳支持，从而更好地利用大量的分布式和多核的计算机，这一点对于谷歌内部的使用来说就非常重要了。设计者通过 goroutine 这种轻量级线程的概念来实现这个目标，然后通过 channel 来实现各个 goroutine 之间的通信。他们实现了分段栈增长和 goroutine 在线程基础上多路复用技术的自动化。 这个特性显然是 Go 语言最强有力的部分，不仅支持了日益重要的多核与多处理器计算机，也弥补了现存编程语言在这方面所存在的不足。 Go 语言中另一个非常重要的特性就是它的构建速度（编译和链接到机器代码的速度），一般情况下构建一个程序的时间只需要数百毫秒到几秒。作为大量使用 C++ 来构建基础设施的谷歌来说，无疑从根本上摆脱了 C++ 在构建速度上非常不理想的噩梦。这不仅极大地提升了开发者的生产力，同时也使得软件开发过程中的代码测试环节更加紧凑，而不必浪费大量的时间在等待程序的构建上。 依赖管理是现今软件开发的一个重要组成部分，但是 C 语言中“头文件”的概念却导致越来越多因为依赖关系而使得构建一个大型的项目需要长达几个小时的时间。人们越来越需要一门具有严格的、简洁的依赖关系分析系统从而能够快速编译的编程语言。这正是 Go 语言采用包模型的根本原因，这个模型通过严格的依赖关系检查机制来加快程序构建的速度，提供了非常好的可量测性。 整个 Go 语言标准库的编译时间一般都在 20 秒以内，其它的常规项目也只需要半秒钟的时间来完成编译工作。这种闪电般的编译速度甚至比编译 C 语言或者 Fortran 更加快，使得编译这一环节不再成为在软件开发中困扰开发人员的问题。在这之前，动态语言将快速编译作为自身的一大亮点，像 C++ 那样的静态语言一般都有非常漫长的编译和链接工作。而同样作为静态语言的 Go 语言，通过自身优良的构建机制，成功地去除了这个弊端，使得程序的构建过程变得微不足道，拥有了像脚本语言和动态语言那样的高效开发的能力。 另外，Go 语言在执行速度方面也可以与 C/C++ 相提并论。 由于内存问题（通常称为内存泄漏）长期以来一直伴随着 C++ 的开发者们，Go 语言的设计者们认为内存管理不应该是开发人员所需要考虑的问题。因此尽管 Go 语言像其它静态语言一样执行本地代码，但它依旧运行在某种意义上的虚拟机，以此来实现高效快速的垃圾回收（使用了一个简单的标记-清除算法）。 尽管垃圾回收并不容易实现，但考虑这将是未来并发应用程序发展的一个重要组成部分，Go 语言的设计者们还是完成了这项艰难的任务。 Go 语言还能够在运行时进行反射相关的操作。 使用 go install 能够很轻松地对第三方包进行部署。 此外，Go 语言还支持调用由 C 语言编写的海量库文件，从而能够将过去开发的软件进行快速迁移。 指导设计原则 Go语言通过减少关键字的数量（25 个）来简化编码过程中的混乱和复杂度。干净、整齐和简洁的语法也能够提高程序的编译速度，因为这些关键字在编译过程中少到甚至不需要符号表来协助解析。 这些方面的工作都是为了减少编码的工作量，甚至可以与 Java 的简化程度相比较。 Go 语言有一种极简抽象艺术家的感觉，因为它只提供了一到两种方法来解决某个问题，这使得开发者们的代码都非常容易阅读和理解。众所周知，代码的可读性是软件工程里最重要的一部分。代码是写给人看的，不是写给机器看的。 这些设计理念没有建立其它概念之上，所以并不会因为牵扯到一些概念而将某个概念复杂化，他们之间是相互独立的。 Go 语言有一套完整的编码规范，不像 Ruby 那样通过实现过程来定义编码规范。作为一门具有明确编码规范的语言，它要求可以采用不同的编译器如 gc 和 gccgo进行编译工作，这对语言本身拥有更好的编码规范起到很大帮助。LALR是 Go 语言的语法标准，这种语法标准在编译时不需要符号表来协助解析。 语言的特性 Go 语言从本质上（程序和结构方面）来实现并发编程。因为 Go 语言没有类和继承的概念，所以它和 Java 或 C++ 看起来并不相同。但是它通过接口（interface）的概念来实现多态性。Go 语言有一个清晰易懂的轻量级类型系统，在类型之间也没有层级之说。因此可以说这是一门混合型的语言。 在传统的面向对象语言中，使用面向对象编程技术显得非常臃肿，它们总是通过复杂的模式来构建庞大的类型层级，这违背了编程语言应该提升生产力的宗旨。 函数是 Go 语言中的基本构件，它们的使用方法非常灵活。在第六章，我们会看到 Go 语言在函数式编程方面的基本概念。 Go 语言使用静态类型，所以它是类型安全的一门语言，加上通过构建到本地代码，程序的执行速度也非常快。 作为强类型语言，隐式的类型转换是不被允许的，记住一条原则：让所有的东西都是显式的。 Go 语言其实也有一些动态语言的特性（通过关键字 var），所以它对那些逃离 Java 和 .Net 世界而使用 Python、Ruby、PHP 和 JavaScript 的开发者们也具有很大的吸引力。 Go 语言支持交叉编译，比如说你可以在运行 Linux 系统的计算机上开发运行 Windows 下运行的应用程序。这是第一门完全支持 UTF-8 的编程语言，这不仅体现在它可以处理使用 UTF-8 编码的字符串，就连它的源码文件格式都是使用的 UTF-8 编码。Go 语言做到了真正的国际化！ 语言的用途 Go 语言被设计成一门应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言。对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。它提供了海量并行的支持，这对于游戏服务端的开发而言是再好不过了。 Go 语言一个非常好的目标就是实现所谓的复杂事件处理（CEP），这项技术要求海量并行支持，高度的抽象化和高性能。当我们进入到物联网时代，CEP 必然会成为人们关注的焦点。 但是 Go 语言同时也是一门可以用于实现一般目标的语言，例如对于文本的处理，前端展现，甚至像使用脚本一样使用它。 值得注意的是，因为垃圾回收和自动内存分配的原因，Go 语言不适合用来开发对实时性要求很高的软件。 越来越多的谷歌内部的大型分布式应用程序都开始使用 Go 语言来开发，例如谷歌地球的一部分代码就是由 Go 语言完成的。 如果你想知道一些其它组织使用Go语言开发的实际应用项目，你可以到 使用 Go 的组织页面进行查看。出于隐私保护的考虑，许多公司的项目都没有展示在这个页面。我们将会在第 21 章讨论到一个使用 Go 语言开发的大型存储区域网络（SAN）案例。 在 Chrome 浏览器中内置了一款 Go 语言的编译器用于本地客户端（NaCl），这很可能会被用于在 Chrome OS 中执行 Go 语言开发的应用程序。 Go 语言可以在 Intel 或 ARM 处理器上运行，因此它也可以在安卓系统下运行，例如 Nexus 系列的产品。 关于特性缺失 许多能够在大多数面向对象语言中使用的特性 Go 语言都没有支持，但其中的一部分可能会在未来被支持。 为了简化设计，不支持函数重载和操作符重载 为了避免在 C/C++ 开发中的一些 Bug 和混乱，不支持隐式转换 Go 语言通过另一种途径实现面向对象设计（第 10-11 章）来放弃类和类型的继承 尽管在接口的使用方面（第 11 章）可以实现类似变体类型的功能，但本身不支持变体类型 不支持动态加载代码 不支持动态链接库 不支持泛型 通过 recover 和 panic 来替代异常机制 不支持静态变量 使用 Go 语言编程 如果你有其它语言的编程经历（面向对象编程语言，如：Java、C#、Object-C、Python、Ruby），在你进入到 Go 语言的世界之后，你将会像迷恋你的 X 语言一样无法自拔。Go 语言使用了与其它语言不同的设计模式，所以当你尝试将你的X语言的代码迁移到 Go 语言时，你将会非常失望，所以你需要从头开始，用 Go 的理念来思考。 如果你在至高点使用 Go 的理念来重新审视和分析一个问题，你通常会找到一个适用于 Go 语言的优雅的解决方案。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"goji-chu-zhi-shi/di-yi-ge-go-cheng-xu.html":{"url":"goji-chu-zhi-shi/di-yi-ge-go-cheng-xu.html","title":"第一个go程序","keywords":"","body":" Go 语言教程1. Go 语言特色2. Go 语言用途3. 第一个 Go 程序 Go 语言教程 Go 是一个开源的编程语言，它能让构造简单、可靠且高效的软件变得容易。 Go是从2007年末由Robert Griesemer, Rob Pike, Ken Thompson主持开发，后来还加入了Ian Lance Taylor, Russ Cox等人，并最终于2009年11月开源，在2012年早些时候发布了Go 1稳定版本。现在Go的开发已经是完全开放的，并且拥有一个活跃的社区。 1. Go 语言特色 简洁、快速、安全 并行、有趣、开源 内存管理、数组安全、编译迅速 2. Go 语言用途 Go 语言被设计成一门应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言。 对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。它提供了海量并行的支持，这对于游戏服务端的开发而言是再好不过了。 3. 第一个 Go 程序 接下来我们来编写第一个 Go 程序 hello.go（Go 语言源文件的扩展是 .go），代码如下： package main import \"fmt\" func main() { fmt.Println(\"Hello, World!\") } 运行 $ go run hello.go Hello, World! 此外我们还可以使用 go build 命令来生成二进制文件： $ go build hello.go $ ls hello hello.go $ ./hello Hello, World! 执行命令 E:\\go\\代码\\Project\\基础\\hello_word\\main>go run hello_word.go Hello WordHello Word Hello Word E:\\go\\代码\\Project\\基础\\hello_word\\main>go build E:\\go\\代码\\Project\\基础\\hello_word\\main>dir 驱动器 E 中的卷是 study 卷的序列号是 DCA4-4E82 E:\\go\\代码\\Project\\基础\\hello_word\\main 的目录 2021/05/31 23:10 . 2021/05/31 23:10 .. 2021/05/31 23:09 480 hello_word.go 2021/05/31 23:10 2,144,256 main.exe 2 个文件 2,144,736 字节 2 个目录 108,196,679,680 可用字节 E:\\go\\代码\\Project\\基础\\hello_word\\main>go build hello_word.go E:\\go\\代码\\Project\\基础\\hello_word\\main>dir 驱动器 E 中的卷是 study 卷的序列号是 DCA4-4E82 E:\\go\\代码\\Project\\基础\\hello_word\\main 的目录 2021/05/31 23:10 . 2021/05/31 23:10 .. 2021/05/31 23:10 2,144,256 hello_word.exe 2021/05/31 23:09 480 hello_word.go 2021/05/31 23:10 2,144,256 main.exe 3 个文件 4,288,992 字节 2 个目录 108,194,533,376 可用字节 E:\\go\\代码\\Project\\基础\\hello_word\\main>go build -o hello hello_word.go E:\\go\\代码\\Project\\基础\\hello_word\\main>dir 驱动器 E 中的卷是 study 卷的序列号是 DCA4-4E82 E:\\go\\代码\\Project\\基础\\hello_word\\main 的目录 2021/05/31 23:11 . 2021/05/31 23:11 .. 2021/05/31 23:11 2,144,256 hello 2021/05/31 23:10 2,144,256 hello_word.exe 2021/05/31 23:09 480 hello_word.go 2021/05/31 23:10 2,144,256 main.exe 4 个文件 6,433,248 字节 2 个目录 108,192,387,072 可用字节 转义符 \\ \\t 相当于一个table \\n 换行 \\t \\\\ console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"goji-chu-zhi-shi/zhu-shi.html":{"url":"goji-chu-zhi-shi/zhu-shi.html","title":"注释","keywords":"","body":" 注释(comment)1. 介绍注释 注释(comment) 1. 介绍注释 用于注解说明解释程序的文字就是注释，注释提高了代码的阅读性； 注释是一个程序员必须要具有的良好编程习惯。将自己的思想通过注释先整理出来，再用代码去 体现。 2.11.2 在 Golang 中注释有两种形式 1) 行注释 基本语法 // 注释内容 举例 2) 块注释(多行注释) 基本语法 /* 注释内容 */ 举例说明 使用细节 1) 对于行注释和块注释，被注释的文字，不会被 Go 编译器执行。 2) 块注释里面不允许有块注释嵌套 [注意一下] console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"goji-chu-zhi-shi/golangguan-fang-bian-cheng-zhi-nan.html":{"url":"goji-chu-zhi-shi/golangguan-fang-bian-cheng-zhi-nan.html","title":"Golang官方编程指南","keywords":"","body":"1. Golang 官方编程指南2. Golang 标准库 API 文档1. Golang 官方编程指南 说明： Golang 官方网站 https://golang.org 点击上图的 tour -> 选择 简体中文就可以进入中文版的 Go 编程指南 。 Golang 官方标准库 API 文档， https://golang.org/pkg 可以查看 Golang 所有包下的函数和使用 解释术语：API api ： application program interface :应用程序编程接口。 就是我们 Go 的各个包的各个函数。 2. Golang 标准库 API 文档 1) API （Application Programming Interface,应用程序编程接口）是 Golang 提供的基本编程接口。 2) Go 语言提供了大量的标准库，因此 google 公司 也为这些标准库提供了相应的 API 文档，用于告 诉开发者如何使用这些标准库，以及标准库包含的方法。 3) Golang 中文网 在线标准库文档： https://studygolang.com/pkgdoc 4) Golang 的包和源文件和函数的关系简图 5) 有一个离线版的 Golang_Manual_By_AstaXie_20120522.chm console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"goji-chu-zhi-shi/dai-ma-gui-830326-zhuan-yi-fu.html":{"url":"goji-chu-zhi-shi/dai-ma-gui-830326-zhuan-yi-fu.html","title":"代码规范&转义符","keywords":"","body":" Go 规范的代码风格&语言的转义字符(escape char)1. 说明:常用的转义字符有如下2. 规范的代码风格 Go 规范的代码风格&语言的转义字符(escape char) 1. 说明:常用的转义字符有如下 1) \\t : 表示一个制表符，通常使用它可以排版。尚硅谷 Go 语言课程 2) \\n ：换行符 3) \\ ：一个\\ 4) \\\" ：一个\" 5) \\r ：一个回车 fmt.Println(\"天龙八部雪山飞狐\\r 张飞\"); 6) 案例截图 2. 规范的代码风格 2.12.1 正确的注释和注释风格： 1) Go 官方推荐使用行注释来注释整个方法和语句。 2) 带看 Go 源码 2.12.2 正确的缩进和空白 1) 使用一次 tab 操作，实现缩进,默认整体向右边移动，时候用 shift+tab 整体向左移 看老师的演示： 2) 或者使用 gofmt 来进行格式化 [演示] 3) 运算符两边习惯性各加一个空格。比如：2 + 4 * 5。 4) Go 语言的代码风格. package main import \"fmt\" func main() { fmt.Println(\"hello,world!\") } 上面的写法是正确的. package main import \"fmt\" func main() { fmt.Println(\"hello,world!\") } 上面的写法不是正确，Go 语言不允许这样编写。 【Go 语言不允许这样写，是错误的！】 Go 设计者思想: 一个问题尽量只有一个解决方法 5) 一行最长不超过 80 个字符，超过的请使用换行展示，尽量保持格式优雅 举例说明 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"ru-men-lian-xi/":{"url":"ru-men-lian-xi/","title":"入门练习","keywords":"","body":" 入门练习 入门练习 基础语法，下面是github地址 https://github1s.com/515250339/goland/blob/HEAD/00%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/\\ console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"ru-men-lian-xi/page-1.html":{"url":"ru-men-lian-xi/page-1.html","title":"Page 1","keywords":"","body":" Page 1 Page 1 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"ru-men-lian-xi/hello-world.html":{"url":"ru-men-lian-xi/hello-world.html","title":"Hello, World","keywords":"","body":"1. Hello, World 1. Hello, World 我们以现已成为传统的“hello world”案例来开始吧，这个例子首次出现于1978年出版的C语言圣经《The C Programming Language》（译注：本书作者之一Brian W. Kernighan也是《The C Programming Language》一书的作者）。C语言是直接影响Go语言设计的语言之一。这个例子体现了Go语言一些核心理念。 gopl.io/ch1/helloworld package main import \"fmt\" func main() { fmt.Println(\"Hello, World\") } Go是一门编译型语言，Go语言的工具链将源代码及其依赖转换成计算机的机器指令（译注：静态编译）。Go语言提供的工具都通过一个单独的命令go调用，go命令有一系列子命令。最简单的一个子命令就是run。这个命令编译一个或多个以.go结尾的源文件，链接库文件，并运行最终生成的可执行文件。（本书使用$表示命令行提示符。） $ go run helloworld.go 毫无意外，这个命令会输出： Hello, World Go语言原生支持Unicode，它可以处理全世界任何语言的文本。 如果不只是一次性实验，你肯定希望能够编译这个程序，保存编译结果以备将来之用。可以用build子命令： $ go build helloworld.go 这个命令生成一个名为helloworld的可执行的二进制文件（译注：Windows系统下生成的可执行文件是helloworld.exe，增加了.exe后缀名），之后你可以随时运行它（译注：在Windows系统下在命令行直接输入helloworld.exe命令运行），不需任何处理（译注：因为静态编译，所以不用担心在系统库更新的时候冲突，幸福感满满）。 $ ./helloworld Hello, World 本书中所有示例代码上都有一行标记，利用这些标记可以从gopl.io网站上本书源码仓库里获取代码： gopl.io/ch1/helloworld 执行go get gopl.io/ch1/helloworld命令，就会从网上获取代码，并放到对应目录中（需要先安装Git或Hg之类的版本管理工具，并将对应的命令添加到PATH环境变量中。序言已经提及，需要先设置好GOPATH环境变量，下载的代码会放在$GOPATH/src/gopl.io/ch1/helloworld目录）。2.6和10.7节有这方面更详细的介绍。 来讨论下程序本身。Go语言的代码通过包（package）组织，包类似于其它语言里的库（libraries）或者模块（modules）。一个包由位于单个目录下的一个或多个.go源代码文件组成，目录定义包的作用。每个源文件都以一条package声明语句开始，这个例子里就是package main，表示该文件属于哪个包，紧跟着一系列导入（import）的包，之后是存储在这个文件里的程序语句。 Go的标准库提供了100多个包，以支持常见功能，如输入、输出、排序以及文本处理。比如fmt包，就含有格式化输出、接收输入的函数。Println是其中一个基础函数，可以打印以空格间隔的一个或多个值，并在最后添加一个换行符，从而输出一整行。 main包比较特殊。它定义了一个独立可执行的程序，而不是一个库。在main里的main函数也很特殊，它是整个程序执行时的入口（译注：C系语言差不多都这样）。main函数所做的事情就是程序做的。当然了，main函数一般调用其它包里的函数完成很多工作（如：fmt.Println）。 必须告诉编译器源文件需要哪些包，这就是跟随在package声明后面的import声明扮演的角色。hello world例子只用到了一个包，大多数程序需要导入多个包。 必须恰当导入需要的包，缺少了必要的包或者导入了不需要的包，程序都无法编译通过。这项严格要求避免了程序开发过程中引入未使用的包（译注：Go语言编译过程没有警告信息，争议特性之一）。 import声明必须跟在文件的package声明之后。随后，则是组成程序的函数、变量、常量、类型的声明语句（分别由关键字func、var、const、type定义）。这些内容的声明顺序并不重要（译注：最好还是定一下规范）。这个例子的程序已经尽可能短了，只声明了一个函数，其中只调用了一个其他函数。为了节省篇幅，有些时候示例程序会省略package和import声明，但是，这些声明在源代码里有，并且必须得有才能编译。 一个函数的声明由func关键字、函数名、参数列表、返回值列表（这个例子里的main函数参数列表和返回值都是空的）以及包含在大括号里的函数体组成。第五章进一步考察函数。 Go语言不需要在语句或者声明的末尾添加分号，除非一行上有多条语句。实际上，编译器会主动把特定符号后的换行符转换为分号，因此换行符添加的位置会影响Go代码的正确解析（译注：比如行末是标识符、整数、浮点数、虚数、字符或字符串文字、关键字break、continue、fallthrough或return中的一个、运算符和分隔符++、--、)、]或}中的一个）。举个例子，函数的左括号{必须和func函数声明在同一行上，且位于末尾，不能独占一行，而在表达式x + y中，可在+后换行，不能在+前换行（译注：以+结尾的话不会被插入分号分隔符，但是以x结尾的话则会被分号分隔符，从而导致编译错误）。 Go语言在代码格式上采取了很强硬的态度。gofmt工具把代码格式化为标准格式（译注：这个格式化工具没有任何可以调整代码格式的参数，Go语言就是这么任性），并且go工具中的fmt子命令会对指定包，否则默认为当前目录中所有.go源文件应用gofmt命令。本书中的所有代码都被gofmt过。你也应该养成格式化自己的代码的习惯。以法令方式规定标准的代码格式可以避免无尽的无意义的琐碎争执（译注：也导致了Go语言的TIOBE排名较低，因为缺少撕逼的话题）。更重要的是，这样可以做多种自动源码转换，如果放任Go语言代码格式，这些转换就不大可能了。 很多文本编辑器都可以配置为保存文件时自动执行gofmt，这样你的源代码总会被恰当地格式化。还有个相关的工具，goimports，可以根据代码需要，自动地添加或删除import声明。这个工具并没有包含在标准的分发包中，可以用下面的命令安装： $ go get golang.org/x/tools/cmd/goimports 对于大多数用户来说，下载、编译包、运行测试用例、察看Go语言的文档等等常用功能都可以用go的工具完成。10.7节详细介绍这些知识。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"ru-men-lian-xi/ming-ling-xing-can-shu.html":{"url":"ru-men-lian-xi/ming-ling-xing-can-shu.html","title":"命令行参数","keywords":"","body":" 命令行参数 命令行参数 1.编译 go build hello.go 2.go get gopl.io/ch1/helloworld命令，就会从网上获取代码，并放到对应目录中 下载的可执行程序会放在$GOPATH/bin/helloworld目录 3.Go语言不需要在语句或者声明的末尾添加分号，除非一行上有多条语句。 4.Go语言在代码格式上采取了很强硬的态度。gofmt工具把代码格式化为标准格式 gofmt -w hello.go重写回源文件 5.goimports，可以根据代码需要,自动地添加或删除import声明 go get golang.org/x/tools/cmd/goimports （被墙不能用） 命令行参数： 1.os包以跨平台的方式，提供了一些与操作系统交互的函数和变量。程序的命令行参数可从os包的Args变量获取；os包外部使用os.Args访问该变量。 2.切片是Go语言的基础概念，现在先把切片s当作数组元素序列,序列的长度动态变化,用s[i]访问单个元素，用s[m:n]获取子序列，序列的元素数目为len(s) a = [1, 2, 3, 4, 5], a[0:3] = [1, 2, 3] 3.os.Args的第一个元素，os.Args[0],是命令本身的名字，其他参数是os.Args[1:len(os.Args)] => os.Args[1:] 4.import导入两个包，括号括起来 5.Go语言只有for循环这一种循环语句 for initialization; condition; post { } for condition { } for {//无限循环 } 6.for循环的另一种形式,在某种数据类型的区间（range）上遍历，如字符串或切片。 循环迭代，range产生一对值；索引以及在该索引处的元素值。 _空标识符丢弃索引，arg是索引所对应的值 7.使用strings包的Join函数 package main import ( \"fmt\" \"os\" \"strings\" ) /* 练习 1.1 修改 echo 程序输出 os.Args[0] ,即命令的名字 练习 1.2 修改 echo 输出参数的索引和值，每行一个 练习1.3：尝试测量可能低效的程序和使用 strings.Join 的程序在执行时间上的差昇 （1.6节有time 包，11.4 节展示如何撰写系统性的性能评估测试。 */ // 练习 1.1 func test1() { var s, sep string for _, arg := range os.Args[1:] { s += sep + arg sep = \"****\" } fmt.Println(s) } //练习 1.2 func test2() { var s, sep string for i := 1; i 8.只是为了调试可以直接打印 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"ru-men-lian-xi/zhao-chu-zhong-fu-xing.html":{"url":"ru-men-lian-xi/zhao-chu-zhong-fu-xing.html","title":"找出重复行","keywords":"","body":"从标准输入中读取数据 1.if语句条件两边也不加括号，但是主体部分需要加{} 2.map存储了键/值（key/value）的集合，对集合元素，提供常数时间的存、取操作，map[string]int ==> key的类型string和value的类型int 3.内置函数make创建空map, counts := make(map[string]int) 4.bufio包Scanner类型读取输入并将其拆成行或单词input := bufio.NewScanner(os.Stdin) 短变量声明一个input变量 5.调用input.Scan()，读入下一行，在读到一行时返回true，不再有输入时返回false 6.fmt.Printf函数对一些表达式产生格式化输出 注意： go语言中的input.Scan() 停止输入是 EOF 终端情况下请使用 ctrl+d我是windows11使用 ctrl+z或者增加判断条件输入end直接结束循环 文件的是直接 cat input | go run main.go dup1,go package main import ( \"bufio\" \"fmt\" \"os\" ) func test1() { // 定义一个 map 对象 key:str value:int counts := make(map[string]int) input := bufio.NewScanner(os.Stdin) for input.Scan() { if input.Text() == \"end\" { break } counts[input.Text()]++ } for line, n := range counts { if n > 1 { fmt.Printf(\"%d\\t%s\\n\", n, line) } } } func main() { test1() } 从文件中读取数据 1.os.Open函数返回两个值。第一个值是被打开的文件(*os.File） 2.os.Open返回的第二个值是内置error类型的值，如果不等于内置值nil（NULL）说明出错了 3.使用fmt.Fprintf表示打印任意类型默认格式值的动词%v 4.map是一个由make函数创建的数据结构的引用，作为参数传递给某函数时相当于引用传递 package main import ( \"bufio\" \"fmt\" \"os\" ) func test1() { // 定义一个 map 对象 key:str value:int counts := make(map[string]int) input := bufio.NewScanner(os.Stdin) for input.Scan() { if input.Text() == \"end\" { break } counts[input.Text()]++ } for line, n := range counts { if n > 1 { fmt.Printf(\"%d\\t%s\\n\", n, line) } } } func test2() { // 创建 map counts := make(map[string]int) // 切片截取命令行输入数据 files := os.Args[1:] // 判断命令行是否输入文件名 if len(files) == 0 { // 无输入则调用 countLines 方法 countLines(os.Stdin, counts) } else { // 输入则打开文件 支持多个文件 for _, arg := range files { f, err := os.Open(arg) if err != nil { fmt.Println(os.Stderr, \"dup2: %v\\n\", err) } // 判断有无重复数据 countLines(f, counts) // 关闭文件 err = f.Close() if err != nil { return } } } for line, n := range counts { // 打印 counst数据 fmt.Printf(\"%d\\t%s\\n\", n, line) } } func countLines(f *os.File, counts map[string]int) { input := bufio.NewScanner(f) for input.Scan() { counts[input.Text()]++ } } func main() { test2() } 多文件 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"ru-men-lian-xi/gifdong-hua.html":{"url":"ru-men-lian-xi/gifdong-hua.html","title":"GIF动画","keywords":"","body":"1.常量声明的值必须是一个数字值、字符串或者一个固定的boolean值。2.常量声明和变量声明一般都会出现在包级别3.[]color.Color{...}生成的是一个slice切片和gif.GIF{...}生成的是一个struct结构体这两个表达式就是我们说的复合声明4.struct是一组值或者叫字段的集合，不同的类型集合在一个struct可以让我们以一个统一的单元进行处理，struct内部的变量可以以一个点(.)来进行访问5.import了一个包路径包含有多个单词的package时，比如image/color（image和color两个单词），通常我们只需要用最后那个单词表示这个包就可以 练习 1.5： 修改前面的Lissajous程序里的调色板，由黑色改为绿色。我们可以用color.RGBA{0xRR, 0xGG, 0xBB, 0xff}来得到#RRGGBB这个色值，三个十六进制的字符串分别代表红、绿、蓝像素。 package main import ( \"image\" \"image/color\" \"image/gif\" \"io\" \"log\" \"math\" \"math/rand\" \"net/http\" \"os\" \"time\" ) var palette = []color.Color{color.White, color.Black} const ( whiteIndex = 0 // 第一种颜色 OpaqueIndex = 1 //第二种颜色 ) func main() { rand.Seed(time.Now().UTC().UnixNano()) if len(os.Args) > 1 && os.Args[1] == \"web\" { handler := func(w http.ResponseWriter, r *http.Request) { lissajous(w) } http.HandleFunc(\"/\", handler) log.Fatal(http.ListenAndServe(\"localhost:8000\", nil)) return } lissajous(os.Stdout) } func lissajous(out io.Writer) { const ( cycles = 5 res = 0.001 size = 100 nframes = 64 delay = 8 ) freq := rand.Float64() * 3.0 anim := gif.GIF{LoopCount: nframes} phase := 0.0 for i := 0; i console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"ru-men-lian-xi/huo-qu-url.html":{"url":"ru-men-lian-xi/huo-qu-url.html","title":"获取url","keywords":"","body":"1.主要使用net/http和io/ioutil包 2.http.Get函数是创建HTTP请求的函数,resp这个结构体中,Body字段包括一个可读的服务器响应流 3.ioutil.ReadAll函数从response中读取到全部内容,resp.Body.Close关闭resp的Body流 4.用os.Exit函数来终止进程，并且返回一个status错误码 5.使用Fprintf与表示任意类型默认格式值的动词%v，向标准错误流打印一条信息 6.strings.HasPrefix(s, prefix string) bool,判断字符串s是否以prefix 开头 练习 1.7： 函数调用io.Copy(dst, src)会从src中读取内容，并将读到的结果写入到dst中，使用这个函数替代掉例子中的ioutil.ReadAll来拷贝响应结构体到os.Stdout，避免申请一个缓冲区（例子中的b）来存储。记得处理io.Copy返回结果中的错误。 练习 1.8： 修改fetch这个范例，如果输入的url参数没有 http:// 前缀的话，为这个url加上该前缀。你可能会用到strings.HasPrefix这个函数。 练习 1.9： 修改fetch打印出HTTP协议的状态码，可以从resp.Status变量得到该状态码。 package main import ( \"fmt\" \"io\" \"net/http\" \"os\" \"strings\" ) func main() { // 循环命令行参数 for _, url := range os.Args[1:] { //加入前缀 当参数不为 http:// 开头 则进行拼接 if !strings.HasPrefix(url, \"http://\") { url = \"http://\" + url } // 获取当前 url resp, err := http.Get(url) // 异常捕获 if err != nil { //向标准错误流打印信息 fmt.Fprintf(os.Stderr, \"fetch: v%\\n\", err) //终止进程 os.Exit(1) } // 获取 resp 中 Body 信息 // b, err := ioutil.ReadAll(resp.Body) // 避免申请一个缓冲区,直接到标准输出流 从 resp.Body 读，并且写入 os.Stdout io.Copy(os.Stdout, resp.Body) // 关闭 Body 避免资源泄露 resp.Body.Close() if err != nil { fmt.Fprintf(os.Stderr, \"fetch: reading %s: %v\\n\", url, err) os.Exit(1) } fmt.Println(\"\") // 输出 code 码 fmt.Printf(\"%s\", resp.Status) } } 执行 go run .\\exercise\\获取一个url\\main.go gopl.io 或 go build {文件名} --> ./文件名 gopl.io console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"ru-men-lian-xi/bing-fa-huo-qu-duo-ge-url.html":{"url":"ru-men-lian-xi/bing-fa-huo-qu-duo-ge-url.html","title":"并发获取多个url","keywords":"","body":" 并发获取多个url 并发获取多个url go语言圣经-并发获取多个URL 1.GO最新奇的特性就是对并发编程的支持,goroutine和channel 2.goroutine是一种函数的并发执行方式，而channel是用来在goroutine之间进行参数传递 go function则表示创建一个新的goroutine，并在这个新的goroutine中执行这个函数。 3.make函数创建了一个传递string类型参数的channel 4.io.Copy把响应的Body内容拷贝到ioutil.Discard输出流中,扔到一个垃圾桶 5.goroutine尝试在一个channel上做send或者receive操作时，这个goroutine会阻塞在调用处,直到另一个goroutine往这个channel里写入、或者接收值 6.用main函数来接收所有fetch函数传回的字符串，可以避免在goroutine异步执行还没有完成时main函数提前退出。 练习 1.10： 找一个数据量比较大的网站，用本小节中的程序调研网站的缓存策略，对每个URL执行两遍请求，查看两次时间是否有较大的差别，并且每次获取到的响应内容是否一致，修改本节中的程序，将响应结果输出，以便于进行对比。 练习 1.11： 在fetchall中尝试使用长一些的参数列表，比如使用在alexa.com的上百万网站里排名靠前的。如果一个网站没有回应，程序将采取怎样的行为？ （Section8.9 描述了在这种情况下的应对机制）。 package main import ( \"fmt\" \"io\" \"io/ioutil\" \"net/http\" \"os\" \"time\" ) func main() { // 获取当前时间 start := time.Now() // make函数创建了一个传递string类型参数的channel ch := make(chan string) // for循环命令行参数 for _, url := range os.Args[1:] { // 开启一个goroutine go fetch(url, ch) } for range os.Args[1:] { // 接收并打印channel,for循环不需要key value fmt.Println( console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"ru-men-lian-xi/da-jian-yi-ge-web-fu-wu-qi.html":{"url":"ru-men-lian-xi/da-jian-yi-ge-web-fu-wu-qi.html","title":"搭建一个web服务器","keywords":"","body":"我们这里搭建一个gin框架 https://yanxiang.wang/win%E7%8E%AF%E5%A2%83%E5%90%AF%E5%8A%A8gin/?t=1646224462365 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"cheng-xu-jie-gou.html":{"url":"cheng-xu-jie-gou.html","title":"常量、变量及基本数据类型","keywords":"","body":" console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"cheng-xu-jie-gou/ming-ming.html":{"url":"cheng-xu-jie-gou/ming-ming.html","title":"标识符和关键字","keywords":"","body":"Go语言中的函数名、变量名、常量名、类型名、语句标号和包名等所有的命名，都遵循一个简单的命名规则：一个名字必须以一个字母（Unicode字母）或下划线开头，后面可以跟任意数量的字母、数字或下划线。大写字母和小写字母是不同的：heapSort和Heapsort是两个不同的名字。 Go语言中类似if和switch的关键字有25个；关键字不能用于自定义名字，只能在特定语法结构中使用。 break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var var和const ：变量和常量的声明 package and import: 导入 func： 用于定义函数和方法 return ：用于从函数返回 defer someCode ：在函数退出之前执行 go : 用于并行 select 用于选择不同类型的通讯 interface 用于定义接口 struct用于定义抽象数据类型 break、case、continue、for、fallthrough、else、if、switch、goto、default 流程控制 chan用于channel通讯 type用于声明自定义类型 map用于声明map类型数据 range用于读取slice、map、channel数据 此外，还有大约30多个预定义的名字，比如int和true等，主要对应内建的常量、类型和函数。 内建常量: true false iota nil 内建类型: int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr float32 float64 complex128 complex64 bool byte rune string error 内建函数: make len cap new append copy close delete complex real imag panic recover 这些内部预先定义的名字并不是关键字，你可以在定义中重新使用它们。在一些特殊的场景中重新定义它们也是有意义的，但是也要注意避免过度而引起语义混乱。 如果一个名字是在函数内部定义，那么它就只在函数内部有效。如果是在函数外部定义，那么将在当前包的所有文件中都可以访问。名字的开头字母的大小写决定了名字在包外的可见性。如果一个名字是大写字母开头的（译注：必须是在函数外部定义的包级名字；包级函数名本身也是包级名字），那么它将是导出的，也就是说可以被外部的包访问，例如fmt包的Printf函数就是导出的，可以在fmt包外部访问。包本身的名字一般总是用小写字母。 名字的长度没有逻辑限制，但是Go语言的风格是尽量使用短小的名字，对于局部变量尤其是这样；你会经常看到i之类的短名字，而不是冗长的theLoopIndex命名。通常来说，如果一个名字的作用域比较大，生命周期也比较长，那么用长的名字将会更有意义。 在习惯上，Go语言程序员推荐使用 驼峰式 命名，当名字由几个单词组成时优先使用大小写分隔，而不是优先用下划线分隔。因此，在标准库有QuoteRuneToASCII和parseRequestLine这样的函数命名，但是一般不会用quote_rune_to_ASCII和parse_request_line这样的命名。而像ASCII和HTML这样的缩略词则避免使用大小写混合的写法，它们可能被称为htmlEscape、HTMLEscape或escapeHTML，但不会是escapeHtml。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"cheng-xu-jie-gou/sheng-ming.html":{"url":"cheng-xu-jie-gou/sheng-ming.html","title":"声明、变量、常量","keywords":"","body":" 声明 常量 、变量1. demo2. 变量的生命周期 声明 1.四种类型的声明语句：var、const、type和func，分别对应变量、常量、类型和函数实体对象的声明2.包一级声明语句声明的名字可在整个包对应的每个源文件中访问,局部声明的名字就只能在函数内部很小的范围被访问 常量 、变量 var 变量名字 类型 = 表达式 零值初始化机制,数值类型零值是0，布尔类型变量对应的零值是false，字符串类型对应的零值是空字符串，接口或引用类型（包括slice、指针、map、chan和函数）变量对应的零值是nil 同时声明一组变量,用逗号分隔 简短变量声明 := ,只有对已经在同级词法域声明过的变量才和赋值操作语句等价 1. demo package main import \"fmt\" // 常量声明 const boilingF = 212.0 //func main() { // var f = boilingF // var c = (f - 32) * 5 / 9 // fmt.Printf(\"%g° or %g℃\", f, c) //} func main() { // 变量声明 const freezingF, boiling = 32.0, boilingF // 调用函数 fToC 计算 入参为 float64 类型，返回参数为 float64 类型 fmt.Printf(\"%g°F = %g°C\\n\", freezingF, fToC(freezingF)) // \"32°F = 0°C\" fmt.Printf(\"%g°F = %g°C\\n\", boiling, fToC(boiling)) // \"212°F = 100°C\" } // 入参为 float64 类型，返回参数为 float64 类型 func fToC(f float64) float64 { // 计算并返回 return (f - 32) * 5 / 9 } 2. 变量的生命周期 变量的生命周期指的是在程序运行期间变量有效存在的时间段。对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。而相比之下，局部变量的生命周期则是动态的：每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。 Go语言的自动垃圾收集器对编写正确的代码是一个巨大的帮助，但也并不是说你完全不用考虑内存了。你虽然不需要显式地分配和释放内存，但是要编写高效的程序你依然需要了解变量的生命周期。例如，如果将指向短生命周期对象的指针保存到具有长生命周期的对象中，特别是保存到全局变量时，会阻止对短生命周期对象的垃圾回收（从而可能影响程序的性能）。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"cheng-xu-jie-gou/zhi-zhen.html":{"url":"cheng-xu-jie-gou/zhi-zhen.html","title":"指针、new函数","keywords":"","body":" 指针、new函数1. 指针2. demo3. new函数 指针、new函数 1. 指针 1.一个指针的值是另一个变量的地址,指针名字为p，那么可以说“p指针指向变量x”，或者说“p指针保存了x变量的内存地址”\\ 2.聚合类型每个成员,可以被取地址\\ 3.函数返回局部变量的地址也是安全的\\ 4.将指针作为参数调用函数，那将可以在函数中通过该指针来更新变量的值。\\ 5.我们对一个变量取地址，或者复制指针，我们都是为原变量创建了新的别名\\ 6.指针是实现标准库中flag包的关键技术，它使用命令行参数来设置对应变量的值 2. demo /* &是“取地址运算符”，是从一个变量获取地址 *是“解引用运算符”，可以简单理解为“从地址取值”， 是&的逆运算 你 testd 是一个 Test*类型，也就是指向 Test 的指针 然后&testd 就是 testd 变量本身的地址，类型应该是 Test 的指针的指针 */ package main import \"fmt\" type Test struct { name string } func main() { var a int = 20 /* 声明实际变量 */ var ip *int /* 声明指针变量 */ ip = &a /* 指针变量的存储地址 */ fmt.Printf(\"a 变量的地址是: %x\\n\", &a) /* 指针变量的存储地址 */ fmt.Printf(\"ip 变量储存的指针地址: %x\\n\", ip) /* 使用指针访问值 */ fmt.Printf(\"*ip 变量的值: %d\\n\", *ip) main2() } func main2() { testa := Test{\"test\"} fmt.Println(testa) //结果{test} testb := &Test{\"test\"} fmt.Println(testb) //结果 &{test} testc := &Test{\"test\"} fmt.Println(*testc) //结果 {test} testd := &Test{\"test\"} fmt.Println(&testd) //结果 0xc000006030 var a int = 1 fmt.Println(a) //结果 1 fmt.Println(&a) //结果 0xc00000c0d8 } 3. new函数 另一个创建变量的方法是调用用内建的new函数,new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为*T。 用new创建变量和普通变量声明语句方式创建变量没有什么区别，除了不需要声明一个临时变量的名字外，我们还可以在表达式中使用new(T)。换言之，new函数类似是一种语法糖，而不是一个新的基础概念。 p := new(int) // p, *int 类型, 指向匿名的 int 变量 fmt.Println(*p) // \"0\" *p = 2 // 设置 int 匿名变量的值为 2 fmt.Println(*p) // \"2\" 指针/nil/声明变量/new 声明变量 var v1 int v2 := 99 指针 var v3 *int v4 := new(int) new关键字 new用于创建内存并进行内部数据的初始化，并返回一个指针类型。 nil nil指go语言中的空值。 var v100 *int var v101 *int8 问题： 为什么要有指针？ 为了节省内存，不重复开辟空间去存储数据。 int和*int是两种不同的数据类型，不等。（之后专门讲指针细说） console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"fu-zhi.html":{"url":"fu-zhi.html","title":"赋值","keywords":"","body":" 赋值1. 多重赋值（元组赋值）1.1. 可赋值性 赋值 将要被赋值的变量放在=的左边，新值的表达式放在=的右边。 x = 1 // 命名变量的赋值 *p = true // 通过指针间接赋值 person.name = \"bob\" // 结构体字段赋值 count[x] = count[x] * scale // 数组、slice或map的元素赋值 特定的二元算术运算符和赋值语句的复合操作可以重写为： count[x] *= scale 这样可以省去对变量表达式的重复计算。 数值变量也可以支持++递增和--递减语句 v := 1 v++ // 等价方式 v = v + 1；v 变成 2 v-- // 等价方式 v = v - 1；v 变成 1 1. 多重赋值（元组赋值） 元组赋值是另一种形式的赋值语句，它允许同时更新多个变量的值。在赋值之前，赋值语句右边的所有表达式将会先进行求值，然后再统一更新左边对应变量的值。 x, y = y, x a[i], a[j] = a[j], a[i] 元组赋值也可以使一系列琐碎赋值更加紧凑（译注: 特别是在for循环的初始化部分）， i, j, k = 2, 3, 5 但如果表达式太复杂的话，应该尽量避免过度使用元组赋值；因为每个变量单独赋值语句的写法可读性会更好。 1.1. 可赋值性 赋值语句是显式的赋值形式，但是程序中还有很多地方会发生隐式的赋值行为：函数调用会隐式地将调用参数的值赋值给函数的参数变量，一个返回语句会隐式地将返回操作的值赋值给结果变量，一个复合类型的字面量（§4.2）也会产生赋值行为。例如下面的语句： medals := []string{\"gold\", \"silver\", \"bronze\"} 隐式地对slice的每个元素进行赋值操作，类似这样写的行为： medals[0] = \"gold\" medals[1] = \"silver\" medals[2] = \"bronze\" map和chan的元素，虽然不是普通的变量，但是也有类似的隐式赋值行为。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"cheng-xu-jie-gou/shu-ju-lei-xing.html":{"url":"cheng-xu-jie-gou/shu-ju-lei-xing.html","title":"基本数据类型","keywords":"","body":" 数据类型的基本介绍1. 整数类型1.1. 整数的各个类型1.2. int 的无符号的类型：1.3. int 的其它类型的说明: 数据类型的基本介绍 1. 整数类型 基本介绍 简单的说，就是用于存放整数值的，比如 0, -1, 2345 等等 1.1. 整数的各个类型 1.2. int 的无符号的类型： 1.3. int 的其它类型的说明: 整型的使用细节 1) Golang 各整数类型分：有符号和无符号，int uint 的大小和系统有关。 2) Golang 的整型默认声明为 int 型 3) 如何在程序查看某个变量的字节大小和数据类型 （使用较多） 4) Golang 程序中整型变量在使用时，遵守保小不保大的原则，即：在保证程序正确运行下，尽量 使用占用空间小的数据类型。【如：年龄】 5) bit: 计算机中的最小存储单位。byte:计算机中基本存储单元。[二进制再详细说] 1byte = 8 bit console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"cheng-xu-jie-gou/dan-wei.html":{"url":"cheng-xu-jie-gou/dan-wei.html","title":"单位","keywords":"","body":" 单位1.1. 今日概要1.2. 1.进制1.3. 2.单位1.4. 3.编码1.5. 编码答疑1.6. 总结 单位 1.1. 今日概要 进制 单位 编码 1.2. 1.进制 1.1 烽火狼烟 古代打仗用烽火狼烟来进行传递信号 生活中灯泡的亮与暗用来指示信息（用电来抓耗子，灯亮表示抓到了） 用亮灯用1表示，则上述的情景为： 110010 010100 100001 计算机本质上都有由晶体管和二极管组成（类比为灯泡），亮与灭都代表一定的信息，所以，本质计算机的所有操作：0101010。 为这些“10101010”来进行一定的格式化： 0 1 10 11 100 所以，二进制，满2进1. 小结 计算机的底层本质上都是二进制。 八进制、十进制、十六进制、二进制之间有对应关系。 满N进1位 1.3. 2.单位 计算机中表示对于二进制大小的常见单位有： b（bit），位 表示二进制有多少位，例如： 01101 就是 5位 = 5b 011011010 就是 9位 = 9b B（byte），字节 8位就是1个字节，例如： 10100101 就是 8位 = 8b = 1B= 1个字节 1010010110100101 就是 16位 = 16b = 2B= 2个字节 KB（Kilobyte），千字节 1024个字节就是1千字节（1KB），即： 1 KB = 1024 B = 1024*8 b M（Megabyte），兆 1024个千字节就是1兆（1M)，即： 1M = 1024 KB = 1024 * 1024 B = 1024 * 1024 * 8 b G（Gigabyte），千兆 1024个兆就是1千兆（1G),即： 1G = 1024 M = 1024 * 1024 KB = 1024 * 1024 * 1024 B = 1024 * 1024 * 1024 * 8 b T（Terabyte），万亿字节 1024个G就是1T …其他更大单位 PB/EB/ZB/YB/BB/NB/DB 不再赘述。 学完上面的这些单位之后，是不是就了解了平时大家说的自己有1G流量是啥意思了。 生活中的场景： 电脑的内存 4G 硬盘是1T 流量10G 流量有30M 1.4. 3.编码 计算机底层本质都是二进制。 3.1 ascii编码 最多用二进制的8来表示所有的情况。 0000000 0000001 0000010 0000011 0000100 .... ... 11111111 2**8=256 A --> 按照ascii码对照表找到他对应的二进制 01000001 3.2 unicode（万国码） ucs2，用16位来表示所有的情况。2**16=65535 十六进制 0000000 0000000 0000000 0000001 0000000 0000010 0000000 1111111 ... 0025 % 6B66 武 ... 11111111 11111111 ucs4，用32位来表示所有的情况。2**32=4294967296 0000000 0000000 0000000 0000000 ... 0000000 0000000 0000000 11111111 ... 11111111 11111111 11111111 11111111 忠告：ucs2和ucs4应该根据自己的业务场景来进行选择。 3.3 utf-8编码 对unicode进行压缩，到底是如何压缩？ 第一步：找模板 码位范围（十六进制） 转换模板 0000 ~ 007F 0XXXXXXX 0080 ~ 07FF 110XXXXX 10XXXXXX 0800 ~ FFFF 1110XXXX 10XXXXXX 10XXXXXX 10000 ~ 10FFFF 11110XXX 10XXXXXX 10XXXXXX 10XXXXXX 例如： \"B\" 对应的unicode码位为 0042，那么他应该选择的一个模板。 \"ǣ\" 对应的unicode码位为 01E3，则应该选择第二个模板。 \"武\" 对应的unicode码位为 6B66，则应该选择第三个模板。 \"沛\" 对应的unicode码位为 6C9B，则应该选择第三个模板。 \"齐\" 对应的unicode码位为 9F50，则应该选择第三个模板。 注意：utf-8表示中文时，用的是3个字节。 第二步：码位以二进制展示，再根据模板进行转换 码位拆分： \"武\"的码位为6B66，则二进制为 0110101101100110 根据模板转换： 6 B 6 6 0110 1011 0110 0110 ---------------------------- 1110XXXX 10XXXXXX 10XXXXXX 使用第三个模板 11100110 10XXXXXX 10XXXXXX 第一步：取二进制前四位0110填充到模板的第一个字节的xxxx位置 11100110 10101101 10XXXXXX 第二步：挨着向后取6位101101填充到模板的第二个字节的xxxxxx位置 11100110 10101101 10100110 第二步：再挨着向后取6位100110填充到模板的第三个字节的xxxxxx位置 最终，\"武\"对应的utf-8编码为 11100110 10101101 10100110 除了utf-8之外，其实还有一些其他的 utf-7/utf-16/utf-32 等编码，他们跟utf-8类似，但没有utf-8应用广泛。 1.5. 编码答疑 /* @Author:武沛齐 微信号：wupeiqi666 @Description: 老男孩IT教育 & 路飞学城 @Video: https://space.bilibili.com/283478842 */ package main import ( \"fmt\" \"strconv\" ) func main() { // 定义字符串，字符串是以什么形式存在于Go编译器（utf-8编码） name := \"武沛齐\" // 其他语言： // 0 武 fmt.Println(name[0], strconv.FormatInt(int64(name[0]), 2)) // 230 11100110 fmt.Println(name[1], strconv.FormatInt(int64(name[1]), 2)) // 173 10101101 fmt.Println(name[2], strconv.FormatInt(int64(name[2]), 2)) // 166 10100110 // 1 沛 fmt.Println(name[3]) fmt.Println(name[4]) fmt.Println(name[5]) // 2 齐 fmt.Println(name[6]) fmt.Println(name[7]) fmt.Println(name[8]) } 1.6. 总结 本章的知识点属于理解为主，了解这些基础之后有利于后面知识点的学习，接下来对本节所有的知识点进行归纳总结： 计算机上所有的东西最终都会转换成为二进制再去运行。 ascii编码、unicode字符集、utf-8编码本质上都是字符与二进制的关系。 ascii，字符和二进制的对照表。 unicode，字符和二进制（码位）的对照表。 utf-8，对unicode字符集的码位进行压缩处理，间接也维护了字符和二进制的对照表。 ucs2和ucs4指的是使用多少个字节来表示unicode字符集的码位。 目前最广泛的编码为：utf-8，他可以表示所有的字符且存储或网络传输也不会浪费资源（对码位进行压缩了）。 二进制、八进制、十进制、十六进制其实就是进位的时机不同。 一个字节8位 b/B/KB/M/G的关系。 utf-8用3个字节表示中文。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"ji-chu-yu-fa.html":{"url":"ji-chu-yu-fa.html","title":"基础语法","keywords":"","body":" console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"ji-chu-yu-fa/pan-duan-yu-ju.html":{"url":"ji-chu-yu-fa/pan-duan-yu-ju.html","title":"条件语句","keywords":"","body":" if1.1. 语法 if else1.1. 语法 if 语句嵌套1.1. 语法 switch1.1. 语法 select1.1. 语法 select demo if if 语句由布尔表达式后紧跟一个或多个语句组成。 1.1. 语法 if 布尔表达式 { /* 在布尔表达式为 true 时执行 */ } If 在布尔表达式为 true 时，其后紧跟的语句块执行，如果为 false 则不执行。 if else if 语句 后可以使用可选的 else 语句, else 语句中的表达式在布尔表达式为 false 时执行。 1.1. 语法 if 布尔表达式 { /* 在布尔表达式为 true 时执行 */ } else { /* 在布尔表达式为 false 时执行 */ } If 在布尔表达式为 true 时，其后紧跟的语句块执行，如果为 false 则执行 else 语句块。 if 语句嵌套 你可以在 if 或 else if 语句中嵌入一个或多个 if 或 else if 语句。 1.1. 语法 if 布尔表达式 1 { /* 在布尔表达式 1 为 true 时执行 */ if 布尔表达式 2 { /* 在布尔表达式 2 为 true 时执行 */ } } 你可以以同样的方式在 if 语句中嵌套else if...else语句 switch switch 语句用于基于不同条件执行不同动作，每一个 case 分支都是唯一的，从上至下逐一测试，直到匹配为止。 switch 语句执行的过程从上至下，直到找到匹配项，匹配项后面也不需要再加 break。 switch 默认情况下 case 最后自带 break 语句，匹配成功后就不会执行其他 case，如果我们需要执行后面的 case，可以使用fallthrough。 1.1. 语法 switch var1 { case val1: ... case val2: ... default: ... } 变量 var1 可以是任何类型，而 val1 和 val2 则可以是同类型的任意值。类型不被局限于常量或整数，但必须是相同的类型；或者最终结果为相同类型的表达式。 您可以同时测试多个可能符合条件的值，使用逗号分割它们，例如：case val1, val2, val3。 select select 是 Go 中的一个控制结构，类似于用于通信的 switch 语句。每个 case 必须是一个通信操作，要么是发送要么是接收。 select 随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。一个默认的子句应该总是可运行的。 1.1. 语法 select { case communication clause : statement(s); case communication clause : statement(s); /* 你可以定义任意数量的 case */ default : /* 可选 */ statement(s); } 以下描述了 select 语句的语法： 每个 case 都必须是一个通信 所有 channel 表达式都会被求值 所有被发送的表达式都会被求值 如果任意某个通信可以进行，它就执行，其他被忽略。 如果有多个 case 都可以运行，Select 会随机公平地选出一个执行。其他不会执行。 否则： 如果有 default 子句，则执行该语句。 如果没有 default 子句，select 将阻塞，直到某个通信可以运行；Go 不会重新对 channel 或值进行求值。 select demo // switch 相当于 if elif func switchTest() { fmt.Println(\"\") fmt.Println(\"---------switch-----------\") for i := 1; i console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"ji-chu-yu-fa/xun-huan-yu-ju.html":{"url":"ji-chu-yu-fa/xun-huan-yu-ju.html","title":"循环语句","keywords":"","body":" 循环语句1. for 循环语法练习2. for3. 循环嵌套4. break5. continue6. goto 循环语句 1. for 循环语法练习 2. for for 循环是一个循环控制结构，可以执行指定次数的循环。 语法 Go 语言的 For 循环有 3 种形式，只有其中的一种使用分号。 变量&条件 for init; condition; post {} 布尔值条件 for condition { } 死循环 for{ } init： 一般为赋值表达式，给控制变量赋初值； condition： 关系表达式或逻辑表达式，循环控制条件； post： 一般为赋值表达式，给控制变量增量或减量。 for语句执行过程如下： 1、先对表达式 1 赋初值； 2、判别赋值表达式 init 是否满足给定条件，若其值为真，满足循环条件，则执行循环体内语句，然后执行 post，进入第二次循环，再判别 condition；否则判断 condition 的值为假，不满足条件，就终止for循环，执行循环体外语句。 for 循环的 range 格式可以对 slice、map、数组、字符串等进行迭代循环。格式如下： for key, value := range oldMap { newMap[key] = value } 3. 循环嵌套 Go 语言允许用户在循环内使用循环。接下来我们将为大家介绍嵌套循环的使用。 语法 for [condition | ( init; condition; increment ) | Range] { for [condition | ( init; condition; increment ) | Range] { statement(s); } statement(s); } 九九成法表 package main import \"fmt\" func main() { for m := 1; m 4. break Go 语言中 break 语句用于以下两方面： 用于循环语句中跳出循环，并开始执行循环之后的语句。 break 在 switch（开关语句）中在执行一条 case 后跳出语句的作用。 在多重循环中，可以用标号 label 标出想 break 的循环。 语法 break 语法格式如下： break; demo // break 跳出当前循环，可⽤于 for、switch、select。 func breakTest() { fmt.Println(\"\") fmt.Println(\"---------break-----------\") for i := 1; 1 5. continue Go 语言的 continue 语句 有点像 break 语句。但是 continue 不是跳出循环，而是跳过当前循环执行下一次循环语句。 for 循环中，执行 continue 语句会触发 for 增量语句的执行。 在多重循环中，可以用标号 label 标出想 continue 的循环。 语法 continue 语法格式如下： continue; demo // continue 跳过本次循环，只能用于 for。 func continueTest() { fmt.Println(\"\") fmt.Println(\"---------continue-----------\") for i := 1; i 6. goto Go 语言的 goto 语句可以无条件地转移到过程中指定的行。 goto 语句通常与条件语句配合使用。可用来实现条件转移， 构成循环，跳出循环体等功能。 但是，在结构化程序设计中一般不主张使用 goto 语句， 以免造成程序流程的混乱，使理解和调试程序都产生困难。 语法 goto 语法格式如下： goto label; .. . label: statement; package main import \"fmt\" func main() { var name string fmt.Print(\"请输入姓名：\") fmt.Scanln(&name) if name == \"wupeiqi\" { // svip goto SVIP } else if name == \"yuanhao\" { // vip goto VIP } fmt.Println(\"预约...\") VIP: fmt.Println(\"等号...\") SVIP: fmt.Println(\"进入...\") } console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"ji-chu-yu-fa/yun-suan-fu/":{"url":"ji-chu-yu-fa/yun-suan-fu/","title":"比较、关系运算符","keywords":"","body":" 算数运算符使用、1. i++ 关系运算符 逻辑运算符 赋值运算符.算数运算符 算数运算符使用、 package main import ( \"fmt\" ) func main() { fmt.Println(\"10+3=\", 10+3) //10+3= 13 fmt.Println(\"10-3=\", 10-3) //10-3= 7 fmt.Println(\"10*3=\", 10*3) //10*3= 30 //除法注意：如果运算的数都是整数，那么除后，去掉小数部分，保留整数部分 fmt.Println(\"10/3=\", 10/3) //10/3= 3 fmt.Println(\"10.0/3=\", 10.0/3) //3.3333333333333335 // 取余注意 余数=被除数-（被除数/除数）*除数 fmt.Println(\"10%3=\", 10%3) //10%3= 1 fmt.Println(\"-10%3=\", -10%3) // -10%3= -1 fmt.Println(\"10%-3=\", 10%-3) // 10%-3= 1 fmt.Println(\"-10%-3=\", -10%-3) // -10%-3= -1 } 1. i++ package main import ( \"fmt\" ) func main() { var i int = 1 i++ fmt.Println(\"i=\", i) // i= 2 } 关系运算符 package main import ( \"fmt\" ) func main() { var n1 int = 9 var n2 int = 8 fmt.Println(n1 == n2) //false fmt.Println(n1 != n2) //true fmt.Println(n1 > n2) //true fmt.Println(n1 >= n2) //true fmt.Println(n1 n2 fmt.Println(\"flag=\", flag) //flag= true } 逻辑运算符 package main import ( \"fmt\" ) func main() { //演示逻辑运算符的使用 && var age int = 40 if age > 30 && age 30 && age 30 || age 30 || age 30 { fmt.Println(\"ok5\") } if !(age > 30) { fmt.Println(\"ok6\") } } 赋值运算符 package main import ( \"fmt\" ) func main() { d := 8 + 2*8 //赋值运算从右向左 fmt.Println(d) //24 x := 10 x += 5 //x=x+5 fmt.Println(\"x += 5 的值:\", x) //24 } console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"ji-chu-yu-fa/yun-suan-fu/yun-suan-fu.html":{"url":"ji-chu-yu-fa/yun-suan-fu/yun-suan-fu.html","title":"运算符","keywords":"","body":" 运算符1. 运算符2. 赋值运算符2.1. 运算符的优先级 运算符 1. 运算符 算数运算符 关系运算符 逻辑运算符 if !true { fmt.Println(\"你是风儿我是沙，去你吗的风河沙\") } 位运算符 必知必会概念： 计算机中的 存储、运算、网络传输等任何的行为，本质上都是二进制的操作。例如：01010101。 A B hello -> 0101010010101 -> hello 信息表现形式 二进制表示：0101010010101 -> hello 十进制表示：1921 -> hello 十进制和二进制的转换关系 | 十进制 | 二进制 | | --- | ---- | | 0 | 0 | | 1 | 1 | | 2 | 10 | | 3 | 11 | | 4 | 100 | | 5 | 101 | | 6 | 110 | | 7 | 111 | | 8 | 1000 | | 9 | 1001 | | 10 | 1010 | | ... | ... | 二进制转换为十进制 10101 -> 2**4 + 2**2 + 2**0 => 16 + 4 + 1 => 21 101010010101 -> 2**11 + 2**9 + .... 十进制转换成二进制 99 -> 64 + 32 + 2 + 1 -> 2**6 + 2**5 + 2**1 + 2*0 -> 1100011 位运算指的是二进制之间的运算： // 1.按位进行与运算（全为1，才得1） r1 := 5 & 99 5 -> 0000101 99 -> 1100011 0000001 -> 1 // 2.按位进行或运算（只要有1，就得1） r2 := 5 | 99 5 -> 0000101 99 -> 1100011 1100111 -> 2**6 + 2**5 + 2**2 + 2**1 + 2**0 = 64 + 32 + 4 + 2 + 1 = 103 // 3.按位进行异或运算（上下不同，就得1） r3 := 5 ^ 99 5 -> 0000101 99 -> 1100011 1100110 -> 2**6 + 2**5 + 2**2 + 2**1 = 64 + 32 + 4 + 2 = 102 // 4.按位向左移动 r4 := 5 101 向左移动2位 -> 10100 -> 2**4 + 2**2 = 16 + 4 = 20 // 5.按位向右移动 r5 := 5 >> 1 5 -> 101 向右移动1位 -> 10 -> 2**1 = 2 // 6.比较清除 // 以前面的值为基准，让前面的和后面的值的二进制位进行比较，如果两个位置都是1，则讲前面的值的那个位置置0 r6 := 5 &^ 99 5 -> 0000101 99 -> 1100011 0000100 -> 2**2 = 4 2. 赋值运算符 age := 19 age = 99 age = age + 9 // age+=9 age = age - 9 // age-=9 age = age * 9 // age*=9 ... 2.1. 运算符的优先级 Precedence Operator 5 * / % > & &^ 4 + - | ^ 3 == != >= 2 && 1 || v1 := 3 + 2 * 2 v2 := 8 == 5 & 99 注意：不要想办法去记住他，使用括号。 参考地址： https://golang.org/ref/spec#Arithmetic_operators https://www.runoob.com/go/go-operators.html console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"shu-ju-lei-xing.html":{"url":"shu-ju-lei-xing.html","title":"数据类型与常见操作","keywords":"","body":" console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"shu-ju-lei-xing/shu-zi-lei-xing/":{"url":"shu-ju-lei-xing/shu-zi-lei-xing/","title":"数字类型","keywords":"","body":" 数字类型1. 数字类型2. Golang数据类型介绍3. 整型分为两大类4. unsafe.Sizeof5. int不同长度直接的转换7. 浮点型9. reflect.TypeOf查看数据类型11. int常用转换13. int8转int1614. int16转float3215. math.Sqrt强转16. int与str转换17. str与int64转换 数字类型 1. 数字类型 2. Golang数据类型介绍 Go 语言中数据类型分为：基本数据类型和复合数据类型 基本数据类型有： 整型、浮点型、布尔型、字符串\\ 复合数据类型有： 数组、切片、结构体、函数、map、通道（channel）、接口 3. 整型分为两大类 有符号整形按长度分为：int8、int16、int32、int64 对应的无符号整型：uint8、uint16、uint32、uint64 关于字节： 字节也叫 Byte，是计算机数据的基本存储单位。8bit(位)=1Byte(字节) 1024Byte(字节)=1KB 1024KB=1MB 1024MB=1GB 1024GB=1TB 。在电脑里一个中文字是占两个字节的。 4. unsafe.Sizeof unsafe.Sizeof(n1) 是 unsafe 包的一个函数，可以返回 n1 变量占用的字节数 package main import ( \"fmt\" \"unsafe\" ) // 查看占用内存 参数aa 为int类型 从地址取值 func sizeOf(aa *int) { fmt.Println(*aa) // 输出类型为 %T fmt.Printf(\"%T\\n\", *aa) // 查看占用内存 fmt.Println(unsafe.Sizeof(*aa)) } func main() { var a = 99 // 传入内存地址 sizeOf(&a) } 5. int不同长度直接的转换 package main import ( \"fmt\" \"unsafe\" ) // 类型转换 参数aa 为int类型 从地址取值 func transitionInt32(aa *int) { fmt.Println(*aa) // 输出类型为 %T fmt.Printf(\"%T\\n\", *aa) // 查看占用内存 fmt.Println(unsafe.Sizeof(*aa)) // 类型转换 dd := int32(*aa) fmt.Println(dd) // 输出类型为 %T fmt.Printf(\"%T\\n\", dd) // 查看占用内存 fmt.Println(unsafe.Sizeof(dd)) } func main() { var a = 127 // 传入内存地址 transitionInt32(&a) } 6. 7. 浮点型 Go 语言支持两种浮点型数：float32 和 float64 package main import ( \"fmt\" \"math\" \"unsafe\" ) // 查看float类型 参数aa float64 从地址取值 func floatTest(aa *float64) { fmt.Println(*aa) // 输出类型为 %T fmt.Printf(\"%T\\n\", *aa) // 查看占用内存 fmt.Println(unsafe.Sizeof(*aa)) } func main() { a := math.Pi // 传入内存地址 floatTest(&a) } 8. 9. reflect.TypeOf查看数据类型 package main import ( \"fmt\" \"reflect\" ) // 查看数据类型 func showType() { a := 10 fmt.Println(reflect.TypeOf(a)) } func main() { showType() } 10. 11. int常用转换 package main import ( \"fmt\" \"strconv\" ) // int 常用转换 func intTransition() { aStr := \"123465\" // 转为int32 intV, _ := strconv.Atoi(aStr) fmt.Printf(\"intV:%v--type:%T\\n\", intV, intV) // 转为int64 base:10进制 bitSize:预期数值的bit大小，用于数值上限限制，最终返回的还是int64类型 int64V, _ := strconv.ParseInt(aStr, 10, 64) fmt.Printf(\"intV:%v--type:%T\\n\", int64V, int64V) // int转string aInt := 123 strS := strconv.Itoa(aInt) fmt.Printf(\"intV:%v--type:%T\\n\", strS, strS) // int64转string var aInt64 int64 aInt64 = 123 str64S := strconv.FormatInt(aInt64, 10) fmt.Printf(\"intV:%v--type:%T\\n\", str64S, str64S) } func main() { intTransition() } 12. 13. int8转int16 package main import \"fmt\" func main() { var a int8 = 20 var b int16 = 40 var c = int16(a) + b //要转换成相同类型才能运行 fmt.Printf(\"值：%v--类型%T\", c, c) //值：60--类型 int16 } 14. int16转float32 package main import \"fmt\" func main() { var a float32 = 3.2 var b int16 = 6 var c = a + float32(b) fmt.Printf(\"值：%v--类型%T\", c, c) //值：9.2--类型 float32 } 15. math.Sqrt强转 package main import ( \"fmt\" \"math\" ) func main() { var a, b = 3, 4 var c int // math.Sqrt()接收的参数是 float64 类型，需要强制转换 c = int(math.Sqrt(float64(a*a + b*b))) fmt.Println(c) // 5 } 16. int与str转换 package main import ( \"fmt\" \"strconv\" ) func main() { //2.1 int64转str var num2 int64 = 123456 str2 := strconv.FormatInt(num2, 10) fmt.Printf(\"%v---%T \\n\",str2,str2) // 123456---string //2.2 str转int64 v1, _ := strconv.ParseFloat(str2, 64) fmt.Printf(\"%v---%T\\n\",v1,v1) // 123456---float64 } 17. str与int64转换 package main import ( \"fmt\" \"strconv\" ) func main() { //1.1 int转sting num1 := 123456 str1 := strconv.Itoa(num1) fmt.Printf(\"%v---%T \\n\",str1,str1) // 123456---string // 1.2 sting转int _int, err := strconv.Atoi(str1) fmt.Println(_int,err) // 123456 fmt.Printf(\"%v---%T\\n\",_int,_int) // 123456---int //2.1 int64转str var num2 int64 = 123456 str2 := strconv.FormatInt(num2, 10) fmt.Printf(\"%v---%T \\n\",str2,str2) // 123456---string //2.2 str转int64 v1, _ := strconv.ParseFloat(str2, 64) fmt.Printf(\"%v---%T\\n\",v1,v1) // 123456---float64 } console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"shu-ju-lei-xing/shu-zi-lei-xing/chang-jian-shu-xue-yun-suan.html":{"url":"shu-ju-lei-xing/shu-zi-lei-xing/chang-jian-shu-xue-yun-suan.html","title":"常见数学运算","keywords":"","body":" 常见数学运算 常见数学运算 常见数学运算 package main import ( \"fmt\" \"math\" ) func main() { fmt.Println(math.Abs(-19)) // 取绝对值 fmt.Println(math.Floor(3.14)) // 向下取整 fmt.Println(math.Ceil(3.14)) // 向上取整 fmt.Println(math.Round(3.3478)) // 就近取整 fmt.Println(math.Round(3.5478*100) / 100) // 保留小数点后两位 fmt.Println(math.Mod(11, 3)) // 取余数，同11 % 3 fmt.Println(math.Pow(2, 5)) // 计算次方，如：2的5次方 fmt.Println(math.Pow10(2)) // 计算10次方，如：2的10次方 fmt.Println(math.Max(1, 2)) // 两个值，取较大值 fmt.Println(math.Min(1, 2)) // 两个值，取较小值 // ... } console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"shu-ju-lei-xing/shu-zi-lei-xing/chao-da-zheng-xing.html":{"url":"shu-ju-lei-xing/shu-zi-lei-xing/chao-da-zheng-xing.html","title":"超大整型","keywords":"","body":" 超大整型1. 超大整型 超大整型 1. 超大整型 第一步：创建对象 创建超大整型对象 // 第一步：创建一个超大整型的一个对象 var v1 big.Int var v2 big.Int // 第二步：在超大整型对象中写入值 v1.SetInt64(9223372036854775807) fmt.Println(v1) v2.SetString(\"92233720368547758089223372036854775808\", 10) fmt.Println(v2) // 第一步：创建一个超大整型的一个对象 v3 := new(big.Int) v4 := new(big.Int) // 第二步：在超大整型对象中写入值 v3.SetInt64(9223372036854775807) fmt.Println(v3) v4.SetString(\"92233720368547758089223372036854775808\", 10) fmt.Println(v4) 推荐：使用指针的方式，即：使用new来进行创建和初始化。 第二步：加减乘除 超大对象进行加减乘除 n1 := new(big.Int) n1.SetInt64(89) n2 := new(big.Int) n2.SetInt64(99) result := new(big.Int) result.Add(n1, n2) fmt.Println(result) n1 := big.NewInt(89) n2 := big.NewInt(99) result := new(big.Int) result.Add(n1, n2) fmt.Println(result) 其他： v1 := big.NewInt(11) v2 := big.NewInt(3) result := new(big.Int) // 加 result.Add(v1, v2) fmt.Println(result) // 减 result.Sub(v1, v2) fmt.Println(result) // 乘 result.Mul(v1, v2) fmt.Println(result) // 除（地板除，只能得到商） result.Div(v1, v2) fmt.Println(result) // 除，得商和余数 minder := new(big.Int) result.DivMod(v1, v2, minder) fmt.Println(result, minder) 第三步：关于结果 n1 := new(big.Int) n1.SetString(\"92233720368547758089223372036854775808\", 10) n2 := new(big.Int) n2.SetString(\"11111192233720368547758089223372036854775808\", 10) result := new(big.Int) result.Add(n1, n2) fmt.Println(result.String()) 最后建议 尽量new方式去初始化并返回一个指针类型的方式。 易错的点（int类型和*int类型） var v1 big.Int v1.SetString(\"92233720368547758089223372036854775808\", 10) var v2 big.Int v2.SetString(\"2\", 10) //result := new(big.Int) var result big.Int result.Add(&v1, &v2) fmt.Println(result.String()) console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"shu-ju-lei-xing/shu-zi-lei-xing/fu-dian-xing-di-ceng.html":{"url":"shu-ju-lei-xing/shu-zi-lei-xing/fu-dian-xing-di-ceng.html","title":"浮点型底层","keywords":"","body":" 浮点型底层1. 浮点型1.1. 非精确1.2. float底层存储原理 浮点型底层 1. 浮点型 浮点数，计算机中小数的表示方式，如：3.14 Go语言中提供了两种浮点型： float32，用32位（4个字节）来存储浮点型。 float64，用64位（8个字节）来存储浮点型。 package main import \"fmt\" func main() { var v1 float32 v1 = 3.14 v2 := 99.9 v3 := float64(v1) + v2 fmt.Println(v1, v2, v3) } 1.1. 非精确 float类型，计算机中小数的非精确的表示方式，如：3.14 package main import \"fmt\" func main() { var v1 float32 v1 = 3.14 v2 := 99.9 v3 := float64(v1) + v2 fmt.Println(v1, v2, v3) v4 := 0.1 v5 := 0.2 result := v4 + v5 fmt.Println(result) v6 := 0.3 v7 := 0.2 data := v6 + v7 fmt.Println(data) } 3.14 99.9 103.04000010490418 0.30000000000000004 0.5 1.2. float底层存储原理 var price float32 = 0.29 第一步：浮点型转换为二进制 整数部分，直接转换为二进制（10进制转换为2进制），即：100111 小数部分，让小数部分乘以2，结果小于1则将结果继续乘以2，结果大于1则讲结果-1继续乘以2，结果等于1则结束。 0.29 * 2 = 0.58 // 小于1，则继续乘 0.58 * 2 = 1.16 // 大于1，则减1继续乘 0.16 * 2 = 0.32 // 小于1，则继续乘 0.32 * 2 = 0.64 // 小于1，则继续乘 0.64 * 2 = 1.28 // 大于1，则减1继续乘 0.28 * 2 = 0.56 // 小于1，则继续乘 0.56 * 2 = 1.12 // 大于1，则减1继续乘 0.12 * 2 = 0.24 // 小于1，则继续乘 0.24 * 2 = 0.48 // 小于1，则继续乘 0.48 * 2 = 0.96 // 小于1，则继续乘 0.96 * 2 = 1.92 // 大于1，则减1继续乘 0.92 * 2 = 1.84 // 大于1，则减1继续乘 0.84 * 2 = 1.68 // 大于1，则减1继续乘 0.68 * 2 = 1.36 // 大于1，则减1继续乘 0.36 * 2 = 0.72 // 小于1，则继续乘 0.72 * 2 = 1.44 // 大于1，则减1继续乘 0.44 * 2 = 0.88 // 小于1，则继续乘 0.88 * 2 = 1.76 // 大于1，则减1继续乘 0.76 * 2 = 1.52 // 大于1，则减1继续乘 0.52 * 2 = 1.04 // 大于1，则减1继续乘 0.04 * 2 = 0.08 // 小于1，则继续乘 0.08 * 2 = 0.16 // 小于1，则继续乘 0.16 * 2 = 0.32 // 小于1，则继续乘（与第三行相同，这样会一直循环执行下去） ... 将相乘之后等结果的整数部分拼接起来，所以 0.29的 二进制表示：010010100011110101110000101000111... 所以，最终39.29的二进制表示为：100111.010010100011110101110000101000111... 第二步：科学计数法表示 100111.010010100011110101110000101000111... $$ 1.00111010010100011110101110000101000111... * 2^5 $$ 第三步：存储 以float32为例来进行存储，用32位来存储浮点型 sign，用1位来表示浮点数正负，0表示正数；1表示负数。 exponent，用8位来表示共有256种（0~255），含正负值（-127 ~ 128）。例如：5想要存储到exponent位的话，需要让 5 + 127 = 132，再讲132转换二进制，存储到exponent。（132的二进制是：01000010） fraction，存储小数点后的所有数据。 float64和float32类似，只是用于表示各部分的位数不同而已，其中：sign=1位、exponent=11位、fraction=52位，也就意味着可以表示的范围更大了。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"shu-ju-lei-xing/shu-zi-lei-xing/decimal.html":{"url":"shu-ju-lei-xing/shu-zi-lei-xing/decimal.html","title":"decimal","keywords":"","body":" decimal1. godecimal decimal 1. godecimal Go语言内部没有decimal。 第三方包，则需要在本地的Go环境中先安装再使用。第三方包源码地址：https://github.com/shopspring/decimal 。 第一步：安装第三发的包 go get github.com/shopspring/decimal 命令执行完成之后，在 $GOPATH/src的目录下就会出现 github/shopspring/decimal的目录，这就是第三方模块安排的位置。 第二步：使用decimal包 package main import ( \"fmt\" \"github.com/shopspring/decimal\" ) func main() { var v1 = decimal.NewFromFloat(0.0000000000019) var v2 = decimal.NewFromFloat(0.29) var v3 = v1.Add(v2) var v4 = v1.Sub(v2) var v5 = v1.Mul(v2) var v6 = v1.Div(v2) fmt.Println(v3, v4, v5, v6) // 输出：0.2900000000019（也可以调用String方法） var price = decimal.NewFromFloat(3.4626) var data1 = price.Round(1) // 保留小数点后1位（四舍五入） var data2 = price.Truncate(1) // 保留小数点后1位 fmt.Println(data1, data2) // 输出：3.5 3.4 } \\ console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"shu-ju-lei-xing/bu-er-zhi.html":{"url":"shu-ju-lei-xing/bu-er-zhi.html","title":"布尔值","keywords":"","body":" 布尔值 布尔值 Go 语言中以 bool 类型进行声明布尔型数据，布尔型数据只有 true（真）和 false（假）两个值。 注意： 1.布尔类型变量的默认值为 false。\\ 2.Go 语言中不允许将整型强制转换为布尔型.\\ 3.布尔型无法参与数值运算，也无法与其他类型进行转换。 package main import ( \"fmt\" \"unsafe\" ) func main() { var b = true fmt.Println(b, \"占用字节：\", unsafe.Sizeof(b)) // true 占用字节： 1 } 字符串转换 package main import ( \"fmt\" \"strconv\" ) func main() { // 字符串 转换 布尔类型 // true:\"1\", \"t\", \"T\", \"true\", \"TRUE\", \"True\" // false:\"0\", \"f\", \"F\", \"false\", \"FALSE\", \"False\" //false,err错误信息 v1, err := strconv.ParseBool(\"t\") fmt.Println(v1, err) // 布尔类型 转换 字符串 v2 := strconv.FormatBool(false) fmt.Println(v2) } # \\ console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"shu-ju-lei-xing/zi-fu-chuan-lei-xing/":{"url":"shu-ju-lei-xing/zi-fu-chuan-lei-xing/","title":"字符串类型","keywords":"","body":" 字符串 字符串转义符 多行字符串 byte和rune 字符串的常用操作 len(str) +(拼接) strings.Split() strings.HasPrefix() strings.Index() strings.Join() 单引号 遍历字符串 修改字符串 sprintf转string strconv string转int string转float string转bool string转字符 字符串反转 字符串 Go 语言里的字符串的内部实现使用 UTF-8 编码。字符串的值为双引号(\")中的内容，可以在 Go 语言的源码中直接添加非 ASCII 码字符s1 := \"hello\"s2 := \"你好\" 字符串转义符 Go 语言的字符串常见转义符包含回车、换行、单双引号、制表符等 package main import ( \"fmt\" ) func main() { // 创建字符串 fmt.Println(\"str := \\\"c:\\\\Code\\\\demo\\\\go.exe\\\"\") // str := \"c:\\Code\\demo\\go.exe\" str := \"c:\\\\Code\\\\demo\\\\go.exe\" fmt.Println(\"str := \", str) } 多行字符串 反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。 package main import ( \"fmt\" ) func main() { // 创建的多行字符串 sManyLine := `第一行 第二行 第三行` fmt.Println(sManyLine) } byte和rune Go 语言的字符有以下两种uint8类型，或者叫 byte 型：代表了ASCII码的一个字符。rune类型：代表一个 UTF-8字符字符串底层是一个byte数组，所以可以和[]byte类型相互转换。字符串是不能修改的 字符串是由byte字节组成，所以字符串的长度是byte字节的长度。rune类型用来表示utf8字符，一个rune字符由一个或多个byte组成。 package main import ( \"fmt\" ) // byte和rune func byteAndRune() { s := \"日本垃垃\" fmt.Println(s) sRune := []rune(s) fmt.Println(\"美国\" + string(sRune[2:])) } func main() { byteAndRune() } 字符串的常用操作 方法 介绍len(str) 求长度+或fmt.Sprintf 拼接字符串strings.Split 分割strings.Contains 判断是否包含strings.HasPrefix,strings.HasSuffix 前缀/后缀判断strings.Index(),strings.LastIndex() 子串出现的位置strings.Join(a[]string, sep string) join操作 len(str) package main import ( \"fmt\" ) // 获取字符串长度 func lenStr(a *string) { fmt.Println(len(*a)) } func main() { var a = \"string\" lenStr(&a) } +(拼接) package main import ( \"fmt\" ) // 拼接字符串 func strJoin(a, b *string) { fmt.Println(*a + *b) } func main() { var a = \"hi \" var b = \"lao 8\" strJoin(&a, &b) } strings.Split() package main import ( \"fmt\" \"strings\" ) // 切分字符串 func strSplit(a *string) { bArr := strings.Split(*a, \"/\") fmt.Println(bArr) fmt.Println(bArr[0]) } func main() { a := \"123/456/789\" strSplit(&a) } strings.HasPrefix() 首字符尾字母包含指定字符 package main import ( \"fmt\" \"strings\" ) func strHasPrefix(a *string) { // 是否以test开头 if strings.HasPrefix(*a, \"test\") { fmt.Println(\"是test开头\") } else if strings.HasSuffix(*a, \"end\") { //是否以en结尾 fmt.Println(\"是end结尾\") } } func main() { a := \"test_a\" strHasPrefix(&a) a = \"a_end\" strHasPrefix(&a) } strings.Index() 判断字符串出现的位置 package main import ( \"fmt\" \"strings\" ) // 判断字符串出现的位置 func indexStr(a *string) { index := strings.Index(*a, \"w\") fmt.Println(index) } func main() { // 判断字符串出现的位置 a := \"teswt\" indexStr(&a) } strings.Join() package main import ( \"fmt\" \"strings\" ) // 拼接字符串 func strJoin2(a *string) { aArr := strings.Split(*a, \" \") fmt.Println(aArr) aStr := strings.Join(aArr, \"-\") fmt.Println(aStr) } func main() { var b = \"lao 8\" strJoin2(&b) } 单引号 组成每个字符串的元素叫做“字符”，可以通过遍历字符串元素获得字符，字符用单引号（’）uint8 类型，或者叫 byte 型，代表了 ASCII 码的一个字符rune 类型，代表一个 UTF-8 字符 package main import ( \"fmt\" \"strings\" ) func strASCII() { a := 'a' name := \"张三\" // 当我们直接输出 byte（字符）的时候输出的是这个字符对应的码 fmt.Println(a) // 97 这里输出的是 a 字符串的 ASCII值 fmt.Println(name) // 如果我们要输出这个字符，需要格式化输出 fmt.Printf(\"%c\\n\", a) // 或者声明并强转为str var b = string('a') fmt.Println(b) } func main() { // 单引号 strASCII() } 遍历字符串 package main import \"fmt\" func main() { s := \"hello word\" // 通过下标去获取元素 for i := 0; i 修改字符串 要修改字符串，需要先将其转换成[]rune 或[]byte，完成后再转换为 string。无论哪种转换，都会重新分配内存，并复制字节数组。 package main import \"fmt\" func main() { // 修改字符串，需要先将其转换成[]rune 或[]byte，完成后再转换为 string s1 := \"big\" byteS1 := []byte(s1) byteS1[0] = 'B' fmt.Println(string(byteS1)) s2 := \"Big\" byteS2 := []rune(s2) byteS2[0] = 'b' fmt.Println(string(byteS2)) } package main import \"fmt\" func main() { // 修改字符串，需要先将其转换成[]rune 或[]byte，完成后再转换为 string s1 := \"big\" byteS1 := []byte(s1) byteS1[0] = 'B' fmt.Println(string(byteS1)) s2 := \"Big\" byteS2 := []rune(s2) byteS2[0] = 'b' fmt.Println(string(byteS2)) } sprintf转string 注意：sprintf 使用中需要注意转换的格式int 为%dfloat 为%fbool 为%tbyte 为%c package main import \"fmt\" func main() { var i int = 10 var f float64 = 2.00 var t bool = true var b byte = 'a' var str string str = fmt.Sprintf(\"%d\", i) fmt.Printf(\"类型: %T，值: %v \\n\", str, str) str = fmt.Sprintf(\"%f\", f) fmt.Printf(\"类型: %T，值: %v \\n\", str, str) str = fmt.Sprintf(\"%t\", t) fmt.Printf(\"类型: %T，值: %v \\n\", str, str) str = fmt.Sprintf(\"%c\", b) fmt.Printf(\"类型: %T，值: %v \\n\", str, str) } strconv package main import ( \"fmt\" \"strconv\" ) func main() { // int 转换为 string var i int fmt.Printf(\"转换前类型：%T，值：%v \\n\", i, i) s1 := strconv.Itoa(i) fmt.Printf(\"转换后类型：%T，值：%v \\n\", s1, s1) fmt.Println() // float 转 string var i2 float64 = 0.01 fmt.Printf(\"转换前类型：%T，值：%v \\n\", i2, i2) /* 参数 1：要转换的值 参数 2：格式化类型 参数 3: 保留的小数点 -1（不对小数点格式化） 参数 4：格式化的类型 */ s2 := strconv.FormatFloat(i2, 'f', 2, 64) fmt.Printf(\"转换后类型：%T，值：%v \\n\", s2, s2) fmt.Println() // bool 转 string b := false fmt.Printf(\"转换前类型：%T，值：%v \\n\", b, b) s3 := strconv.FormatBool(b) fmt.Printf(\"转换后类型：%T，值：%v \\n\", s3, s3) fmt.Println() // int64 转 string var i3 int64 = 998 fmt.Printf(\"转换前类型：%T，值：%v \\n\", i3, i3) var s4 = strconv.FormatInt(i3, 10) fmt.Printf(\"转换后类型：%T，值：%v \\n\", s4, s4) fmt.Println() } string转int package main import ( \"fmt\" \"strconv\" ) // string转int func str2int2() { var a string = \"1234\" i64, _ := strconv.ParseInt(a, 10, 64) fmt.Printf(\"转换前类型: %T 转换后类型: %T 值: %v \\n\", a, i64, i64) } func main() { str2int2() } string转float package main import ( \"fmt\" \"strconv\" ) // string转float func str2float() { var a string = \"3.14\" f32, _ := strconv.ParseFloat(a, 32) f64, _ := strconv.ParseFloat(a, 64) fmt.Printf(\"转换前类型: %T 转换后类型: %T 值: %v \\n\", a, f32, f32) fmt.Printf(\"转换前类型: %T 转换后类型: %T 值: %v \\n\", a, f64, f64) } func main() { str2float() } string转bool package main import ( \"fmt\" \"strconv\" ) // string转bool func str2bool() { var a string = \"true\" b, _ := strconv.ParseBool(a) fmt.Printf(\"转换前类型: %T 转换后类型: %T 值: %v \\n\", a, b, b) } func main() { str2bool() } string转字符 package main import ( \"fmt\" \"strconv\" ) // string转字符 func str2ASCII() { var a string = \"hello goland\" for _, i := range a { fmt.Printf(\"%v(%c) \", i, i) } } func main() { str2ASCII() } 字符串反转 package main import ( \"fmt\" \"strconv\" ) // 字符串反转 func strServer() { a := \"test\" r := []rune(a) for i, j := 0, len(r)-1; i console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"shu-ju-lei-xing/zi-fu-chuan-lei-xing/zi-fu-chuan-di-ceng-yi-ji-chang-yong-fang-fa.html":{"url":"shu-ju-lei-xing/zi-fu-chuan-lei-xing/zi-fu-chuan-di-ceng-yi-ji-chang-yong-fang-fa.html","title":"字符串底层以及常用方法","keywords":"","body":" 字符串底层以及常用方法1.1. 字符串 字符串底层以及常用方法 1.1. 字符串 在编写程序时，使用字符串来进行文本的处理，例如： package main ​ import \"fmt\" ​ func main() { var name string = \"alex\" fmt.Printf(name) ​ title := \"生活要想过得去，头上总得带点绿\" fmt.Printf(title) } 字符串的底层存储 计算机中所有的操作和数据最终都是二进制，即：1000100001011... Go语言中的字符串是utf-8编码的序列。 package main ​ import \"fmt\" ​ func main() { // unicode字符集：文字 -> 码点（ucs4, 4个字节表示） // utf-8编码，对unicode字符集的码点进行编码最终得到：1000100001 var name string = \"武沛齐\" fmt.Printf(name) } 课上代码示例： package main ​ import ( \"fmt\" \"strconv\" \"unicode/utf8\" ) ​ func main() { // 1. 本质是utf-8编码的序列 var name string = \"武沛齐\" ​ // 武 => 11100110 10101101 10100110 fmt.Println(name[0], strconv.FormatInt(int64(name[0]), 2)) fmt.Println(name[1], strconv.FormatInt(int64(name[1]), 2)) fmt.Println(name[2], strconv.FormatInt(int64(name[2]), 2)) ​ // 武 => 11100110 10110010 10011011 fmt.Println(name[3], strconv.FormatInt(int64(name[3]), 2)) fmt.Println(name[4], strconv.FormatInt(int64(name[4]), 2)) fmt.Println(name[5], strconv.FormatInt(int64(name[5]), 2)) ​ // 武 => 11101001 10111101 10010000 fmt.Println(name[6], strconv.FormatInt(int64(name[6]), 2)) fmt.Println(name[7], strconv.FormatInt(int64(name[7]), 2)) fmt.Println(name[8], strconv.FormatInt(int64(name[8]), 2)) ​ // 2. 获取字符串的长度：9（字节长度） fmt.Println(len(name)) ​ // 3. 字符串转换为一个\"字节集合\" byteSet := []byte(name) fmt.Println(byteSet) // [230,173,166,230,178,155,233,189,144] ​ // 4. 字节的集合转换为字符串 byteList := []byte{230, 173, 166, 230, 178, 155, 233, 189, 144} targetString := string(byteList) fmt.Println(targetString) ​ // 5. 将字符串转换为 unicode字符集码点的集合 6b66 -> 武 6c9b->沛 9f50->齐 tempSet := []rune(name) fmt.Println(tempSet) // [27494 27803 40784] fmt.Println(tempSet[0], strconv.FormatInt(int64(tempSet[0]), 16)) fmt.Println(tempSet[1], strconv.FormatInt(int64(tempSet[1]), 16)) fmt.Println(tempSet[2], strconv.FormatInt(int64(tempSet[2]), 16)) ​ // 6. \"rune集合\" 转换 为字符串 runeList := []rune{27494, 27803, 40784} targetName := string(runeList) fmt.Println(targetName) ​ // 7. 长度的处理（获取字符长度） runeLength := utf8.RuneCountInString(name) fmt.Println(runeLength) } 字符串常见功能 字符串属于在程序中最常见用的数据类型，所以Go中为字符串提供了很多常见的操作。 1 获取长度 package main ​ import ( \"fmt\" \"unicode/utf8\" ) ​ func main() { var name string = \"武沛齐\" ​ fmt.Println( len(name) ) // 获取 字节 长度，输出：8 fmt.Println( utf8.RuneCountInString(name) ) // 获取字符长度，输出：3 } 2 是否以xx开头 package main ​ import ( \"fmt\" \"strings\" ) ​ func main() { name := \"武沛齐\" ​ result := strings.HasPrefix(name, \"武\") ​ fmt.Println(result) // 输出：true } 3 是否以xx结尾 package main ​ import ( \"fmt\" \"strings\" ) ​ func main() { name := \"武沛齐\" ​ result := strings.HasSuffix(name, \"齐\") ​ fmt.Println(result) // 输出：true } 4 是否包含 package main ​ import ( \"fmt\" \"strings\" ) ​ func main() { name := \"抬老子的意大利炮来\" result := strings.Contains(name, \"老子\") ​ fmt.Println(result) // 输出：true } 5 变大写 package main ​ import ( \"fmt\" \"strings\" ) ​ func main() { name := \"wupeiqi\" ​ result := strings.ToUpper(name) ​ fmt.Println(result) // 输出：WUPEIQI } // 注意：result是大写；name依然是小写。 6 变小写 package main ​ import ( \"fmt\" \"strings\" ) ​ func main() { name := \"WUPEIQI\" ​ result := strings.ToLower(name) ​ fmt.Println(result) // 输出：wupeiqi } 7 去两边 package main ​ import ( \"fmt\" \"strings\" ) ​ func main() { name := \"wupeiqi\" ​ result1 := strings.TrimRight(name, \"qi\") // 去除右边的qi result2 := strings.TrimLeft(name, \"w\") // 去除左边的w result3 := strings.Trim(name, \"w\") // 去除两边的w ​ fmt.Println(result1, result2, result3) // 输出：wupe upeiqi upeiqi } 8 替换 package main ​ import ( \"fmt\" \"strings\" ) ​ func main() { name := \"wupeipeiqi\" ​ result1 := strings.Replace(name, \"pei\", \"PE\", 1) // 找到pei替换为PE，从左到右找第一个替换 result2 := strings.Replace(name, \"pei\", \"PE\", 2) // 找到pei替换为PE，从左到右找前两个替换 result3 := strings.Replace(name, \"pei\", \"PE\", -1) // 找到pei替换为PE，替换所有 ​ fmt.Println(result1, result2, result3) } 9 分割 package main ​ import ( \"fmt\" \"strings\" ) ​ func main() { name := \"抬老子的意大利的炮来\" result := strings.Split(name, \"的\") ​ // 根据`的`进行切割，获取一个切片（类似于一个数组） fmt.Println(result) // [ 抬老子, 意大利, 炮来 ] } 10 拼接 可以使用 + 让两个字符串进行拼接，但这样的拼接效率会非常的低，不建议使用，建议大家使用以下的方式： package main ​ import ( \"bytes\" \"fmt\" \"strings\" ) ​ func main() { // 不建议 message := \"我爱\" + \"北京天安门\" fmt.Println(message) ​ // 建议：效率高一些 dataList := []string{\"我爱\", \"北京天安门\"} result := strings.Join(dataList, \"\") fmt.Println(result) // 我爱北京天安门 ​ // 建议：效率更高一些（go 1.10之前） var buffer bytes.Buffer buffer.WriteString(\"你想\") buffer.WriteString(\"我干\") buffer.WriteString(\"他\") data := buffer.String() fmt.Print(data) ​ // 建议：效率更更更更高一些（go 1.10之后） var builder strings.Builder builder.WriteString(\"哈哈哈\") builder.WriteString(\"去你的吧\") value := builder.String() fmt.Print(value) } 11 string转换为int package main ​ import ( \"fmt\" \"strconv\" ) ​ func main() { num := \"666\" ​ // 内部调用的就是 ParseInt var data, _ = strconv.Atoi(num) fmt.Println(data) // 整型转字符串（strconv.ParseInt 和 strconv.FormatInt 可用处理进制转换） // 十进制：整型； 其他进制：字符串形式 var result, err = strconv.ParseInt(num, 10, 32) fmt.Println(result, err) } 12 int转换为string package main ​ import ( \"fmt\" \"strconv\" ) ​ func main() { var result = strconv.Itoa(888) fmt.Println(result) } 13 字符串 和 “字节集合” package main ​ import ( \"fmt\" \"strconv\" \"unicode/utf8\" ) ​ func main() { ​ var name string = \"武沛齐\" ​ // 字符串转换为一个\"字节集合\" byteSet := []byte(name) fmt.Println(byteSet) // [230,173,166,230,178,155,233,189,144] ​ // 字节的集合转换为字符串 byteList := []byte{230, 173, 166, 230, 178, 155, 233, 189, 144} targetString := string(byteList) fmt.Println(targetString) ​ } 14 字符串 和 “rune集合” package main ​ import ( \"fmt\" \"strconv\" \"unicode/utf8\" ) ​ func main() { ​ var name string = \"武沛齐\" ​ // 将字符串转换为 unicode字符集码点的集合 6b66 -> 武 6c9b->沛 9f50->齐 tempSet := []rune(name) fmt.Println(tempSet) // [27494 27803 40784] fmt.Println(tempSet[0], strconv.FormatInt(int64(tempSet[0]), 16)) fmt.Println(tempSet[1], strconv.FormatInt(int64(tempSet[1]), 16)) fmt.Println(tempSet[2], strconv.FormatInt(int64(tempSet[2]), 16)) ​ // \"rune集合\" 转换 为字符串 runeList := []rune{27494, 27803, 40784} targetName := string(runeList) fmt.Println(targetName) } 15 string 和 字符 package main ​ import ( \"fmt\" \"unicode/utf8\" ) ​ func main() { // 数字转字符串 v1 := string(65) fmt.Println(v1) // A v2 := string(27494) fmt.Println(v2) // 武 // 字符串转数字 v3, size := utf8.DecodeRuneInString(\"A\") fmt.Println(v3, size) // 65 1 v4, size := utf8.DecodeRuneInString(\"武\") fmt.Println(v4, size) // 27494 3 ​ } 应用场景：生成一个随机数，然后调用string得到一个随机的字符。 索引切片和循环 package main ​ import \"fmt\" ​ func main() { var name string = \"武沛齐\" ​ // 1. 索引获取字节 v1 := name[0] fmt.Println(v1) // 230 ​ // 2. 切片获取字节区间 v2 := name[0:3] fmt.Println(v2) // 武 ​ // 3. 手动循环获取所有字节 /* 0 230 1 173 2 166 3 230 4 178 5 155 6 233 7 189 8 144 */ for i := 0; i console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"shu-ju-lei-xing/shu-zu/":{"url":"shu-ju-lei-xing/shu-zu/","title":"数组","keywords":"","body":" 数组介绍1.1. Array介绍 1.2. 数组定义 1.3. 数组是值类型 2. 创建数组 2.1. 自定义数组长度 2.2. 让编译器识别 2.3. 指定索引值 3. 数组的遍历 3.1. 普通遍历数组 3.2. k,v遍历数组 5. 多维数组 5.1. 定义多维数组 5.2. 遍历多维数组 6. 数组练习 6.1. 数组求和 6.2. 数组最大值 数组介绍 1.1. Array介绍 数组是指一系列 同一类型数据的集合。 数组中包含的每个数据被称为数组元素(element)，这种类型可以是任意的原始类型，比如 int、string 等 一个数组包含的元素个数被称为数组的长度。 在 Golang 中数组是一个长度固定的数据类型，数组的长度是类型的一部分，也就是说 [5]int 和 [10]int 是两个不同的类型。 Golang中数组的另一个特点是占用内存的连续性，也就是说数组中的元素是被分配到连续的内存地址中的，因而索引数组元素的速度非常快。 和数组对应的类型是 Slice（切片），Slice 是可以增长和收缩的动态序列，功能也更灵活 但是想要理解 slice 工作原理的话需要先理解数组，所以本节主要为大家讲解数组的使用。 1.2. 数组定义 var 数组变量名 [元素数量]T 比如：var a [5]int， 数组的长度必须是常量，并且长度是数组类型的一部分 一旦定义，长度不能变。 [5]int 和[4]int 是不同的类型。 package main import \"fmt\" // 创建数组并赋值 func createArr() { // 创建数组 5 个元素 int 类型 var a [5]int // 创建数组 3 个元素 int 类型 var b [3]int fmt.Printf(\"类型：%T value：%[1]v \\n\", a) fmt.Printf(\"类型：%T value：%[1]v \\n\", b) // 进行下标取值并赋值 0 开始 a[0] = 11 a[3] = 33 b[0] = 22 b[2] = 99 fmt.Printf(\"类型：%T value：%[1]v \\n\", a) fmt.Printf(\"类型：%T value：%[1]v \\n\", b) } func main() { createArr() } {#_1-3-数组是值类型} 1.3. 数组是值类型 数组是值类型，赋值和传参会复制整个数组。 因此改变副本的值，不会改变本身的值。 注意： 数组支持 “==“、”!=” 操作符，因为内存总是被初始化过的。 [n]*T 表示指针数组， *[n]T 表示数组指针 package main import \"fmt\" // 数组是值类型 func updateArr(x [3]int) { x[2] = 100 fmt.Println(\"【updateArr】-- 修改值为副本不影响本身的值\", x) } // 数组是值类型 func updateArr2(x *[3]int) { x[2] = 100 fmt.Println(\"【updateArr】-- 修改值为本身\", *x) } func main() { // 数组是值类型 var a [3]int updateArr(a) fmt.Println(a) fmt.Println() // 修改本身需要传递内存地址 var b [3]int updateArr2(&b) fmt.Println(b) } 2. 创建数组 2.1. 自定义数组长度 package main import \"fmt\" func createCustomArr() { var a [3]int fmt.Println(a) var b = [3]int{1, 2} fmt.Println(b) } func main() { createCustomArr() } 2.2. 让编译器识别 按照上面的方法每次都要确保提供的初始值和数组长度一致 一般情况下我们可以让编译器根据初始值的个数自行推断数组的长度 package main import \"fmt\" func createCustomArr2() { // 不定长Arr var c = []string{\"张三\", \"李四\"} fmt.Printf(\"类型：%T value：%[1]v \\n\", c) // 不定长Arr 两个参数长度就为2 var d = [...]string{\"张三\", \"dd\"} fmt.Printf(\"类型：%T value：%[1]v \\n\", d) // 不定长Arr 长度默认下标加1 4+1=5 var e = [...]int{0: 3, 1: 5, 4: 6} fmt.Printf(\"类型：%T value：%[1]v \\n\", e) } func main() { createCustomArr2() } 2.3. 指定索引值 我们还可以使用指定索引值的方式来初始化数组 package main import \"fmt\" func createCustomArr3() { // 指定索引赋值 长度默认下标加1 4+1=5 var e = [...]int{0: 3, 1: 5, 4: 6} fmt.Printf(\"类型：%T value：%[1]v \\n\", e) } func main() { createCustomArr3() } 3. 数组的遍历 3.1. 普通遍历数组 package main import ( \"fmt\" ) func main() { // 普通遍历 var a = [...]int{998, 2, 3} for x := 0; x 3.2. k,v遍历数组 package main import ( \"fmt\" ) func main() { var a = [...]int{998, 2, 3} // k,v遍历 for k, v := range a { fmt.Println(k, v) } } 4. 5. 多维数组 5.1. 定义多维数组 package main import \"fmt\" func manyArr() { var a = [3][2]string{ {\"张三\", \"男\"}, {\"里斯\", \"女\"}, {\"老六\", \"中\"}, } fmt.Println(a) fmt.Println(a[1][0]) } func main() { manyArr() } 5.2. 遍历多维数组 package main import \"fmt\" func manyArr() [3][2]string { var a = [3][2]string{ {\"张三\", \"男\"}, {\"里斯\", \"女\"}, {\"老六\", \"中\"}, } //fmt.Println(a) //fmt.Println(a[1][0]) return a } func main() { a := manyArr() for _, i := range a { var name string var sex string for k, v := range i { if k == 0 { name = v continue } else if k == 1 { sex = v } fmt.Println(\"name:\", name, \"sex:\", sex) } } } 6. 数组练习 6.1. 数组求和 package main import \"fmt\" func sumArr(a [3]int) { sum := 0 for _, i := range a { sum += i } fmt.Printf(\"sum: %v, mean: %v\", sum, float64(sum)/float64(len(a))) } func main() { var a = [...]int{998, 2, 3} sumArr(a) } 6.2. 数组最大值 1、声明一个数组 var intArr[5] = [...]int {1, -1, 12, 65, 11} 2、假定第一个元素就是最大值，下标就 0 3、然后从第二个元素开始循环比较，如果发现有更大，则交换 package main import \"fmt\" func maxArr() { a := [4]int{1, 2, 4, 3} var max int = a[0] for _, i := range a { if i > max { max = i } } fmt.Println(max) } func main() { maxArr() } console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"shu-ju-lei-xing/shu-zu/shu-zu-di-ceng.html":{"url":"shu-ju-lei-xing/shu-zu/shu-zu-di-ceng.html","title":"数组底层","keywords":"","body":" 数组底层1. 数组1.1. 数组内存管理1.2. 可变和拷贝1.3. 长度索引切片和循环1.4. 数组嵌套 数组底层 1. 数组 数组，定长且元素类型一致的数据集合。 // 方式一：先声明再赋值（声明时内存中已开辟空间，内存初始化的值是0） var numbers [3]int numbers[0] = 999 numbers[1] = 666 numbers[2] = 333 // 方式二：声明+赋值 var names = [2]string{\"武沛齐\",\"alex\"} // 方式三：声明+赋值 + 指定位置 var ages = [3]int{0:87,1:73,2:99} // 方式四：省略个数 var names = [...]string{\"武沛齐\",\"alex\"} var ages = [...]int{ 0:87, 2:99 } // 声明 指针类型的数组（指针类型），不会开辟内存初始化数组中的值，numbers = nil var numbers *[3]int // 声明数组并初始化，返回的是 指针类型的数组（指针类型） numbers := new([3]int) 1.1. 数组内存管理 数组，定长且元素类型一致的数据集合。 必备知识点： 数组的内存是连续的。 数组的内存地址实际上就是数组第一个元素的内存地址。 每个字符串的内部存储：len + str type stringStruct struct { str unsafe.Pointer len int } 示例1：int8 16进制每次+1 package main import \"fmt\" func main() { nums := [3]int8{11, 22, 33} fmt.Printf(\"数组的内存地址：%p \\n\", &nums) fmt.Printf(\"数组第1个元素的内存地址：%p \\n\", &nums[0]) fmt.Printf(\"数组第2个元素的内存地址：%p \\n\", &nums[1]) fmt.Printf(\"数组第3个元素的内存地址：%p \\n\", &nums[2]) } >>> 输出 数组的内存地址：0xc00001604a 数组第1个元素的内存地址：0xc00001604a 数组第2个元素的内存地址：0xc00001604b 数组第3个元素的内存地址：0xc00001604c 示例2：16进制每次+4 package main import \"fmt\" func main() { nums := [3]int32{11, 22, 33} fmt.Printf(\"数组的内存地址：%p \\n\", &nums) fmt.Printf(\"数组第1个元素的内存地址：%p \\n\", &nums[0]) fmt.Printf(\"数组第2个元素的内存地址：%p \\n\", &nums[1]) fmt.Printf(\"数组第3个元素的内存地址：%p \\n\", &nums[2]) } >>> 输出 数组的内存地址：0xc0000b4004 数组第1个元素的内存地址：0xc0000b4004 数组第2个元素的内存地址：0xc0000b4008 数组第3个元素的内存地址：0xc0000b400c 示例3：16进制每次+16 package main import \"fmt\" func main() { names := [2]string{\"武沛齐\", \"alex\"} fmt.Printf(\"数组的内存地址：%p \\n\", &names) fmt.Printf(\"数组第1个元素的内存地址：%p \\n\", &names[0]) fmt.Printf(\"数组第2个元素的内存地址：%p \\n\", &names[1]) } >>> 输出： 数组的内存地址：0xc000128020 数组第1个元素的内存地址：0xc000128020 数组第2个元素的内存地址：0xc000128030 1.2. 可变和拷贝 可变，数组的元素可以被更改（长度和类型都不可以修改）。 names := [2]string{\"武沛齐\", \"alex\"} names[1] = \"苑昊\" 注意：字符串不可以被修改。 \"武沛齐\" \"武陪齐\" 拷贝，变量赋值时重新拷贝一份。 name1 := [2]string{\"武沛齐\", \"alex\"} name2 := name1 name1[1] = \"苑昊\" fmt.Println(name1,name2) // [武沛齐 苑昊] [武沛齐 alex] 1.3. 长度索引切片和循环 package main import \"fmt\" func main() { // 1. 长度 //name := [2]string{\"武沛齐\", \"alex\"} //fmt.Println(len(name)) // 2. 索引 //name := [2]string{\"武沛齐\", \"alex\"} //data := name[0] //fmt.Println(data) //name[0] = \"eric\" //fmt.Println(name) // 3. 切片 //nums := [3]int32{11, 22, 33} //data := nums[0:2] // 获取 0 1.4. 数组嵌套 // [0,0,0] //var nestData [3]int // [ [ [0,0,0],[0,0,0] ],[ [0,0,0],[0,0,0] ],[ [0,0,0],[0,0,0] ], ] //var nestData [3][2][3]int // [ [0,0,0],[0,0,0] ] //var nestData [2][3]int //nestData[0] = [3]int{11, 22, 33} //nestData[1][1] = 666 //fmt.Println(nestData) //nestData := [2][3]int{[3]int{11, 22, 33}, [3]int{44, 55, 66}} //fmt.Println(nestData) console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"shu-ju-lei-xing/qie-pian/":{"url":"shu-ju-lei-xing/qie-pian/","title":"切片","keywords":"","body":"1. 切片基础 1.1. 切片的定义 1.2. 关于 nil 的认识 1.3. 切片的本质 1.4. 切片的扩容策略 1.5. 切片的长度和容量 2. 切片循环 2.1. 基本遍历 2.2. k，v遍历 3. 定义切片 3.1. 数组定义切片 3.2. make()构造切片 4. append() 4.1. append添加 4.2. append追加多个 4.3. 切片中删除元素 4.4. 切片合并 5. copy() 5.1. 引用问题 5.2. copy()函数 6. sort() 6.1. 正序排序 6.2. sort 降序排序 1. 切片基础 1.1. 切片的定义 切片（Slice）是一个拥有相同类型元素的可变长度的序列。 它是基于数组类型做的一层封装。 它非常灵活，支持自动扩容。 切片是一个引用类型，它的内部结构包含地址、长度和容量。 声明切片类型的基本语法如下： // var name []T // 1、name:表示变量名 // 2、T:表示切片中的元素类型 package main import \"fmt\" func createSlice() { // 切片是引用类型，不支持直接比较，只能和 nil 比较 //声明一个字符串切片 var a []string fmt.Println(a) fmt.Println(a == nil) //声明一个字符串切片并初始化 var b = []string{} fmt.Println(b) fmt.Println(b == nil) //声明一个布尔切片并初始化赋值 var c = []bool{false} fmt.Println(c) fmt.Println(c == nil) } func main() { createSlice() } 切片之间是不能比较的，我们不能使用==操作符来判断两个切片是否含有全部相等元素。 切片唯一合法的比较操作是和 nil 比较。 一个 nil 值的切片并没有底层数组，一个 nil 值的切片的长度和容量都是 0。 但是我们不能说一个长度和容量都是 0 的切片一定是 nil 例如下面的 1.2. 关于 nil 的认识 当你声明了一个变量 , 但却还并没有赋值时 , golang 中会自动给你的变量赋值一个默认零值。 这是每种类型对应的零值 bool -> false numbers -> 0 string-> \"\" pointers -> nil slices -> nil maps -> nil channels -> nil functions -> nil interfaces -> nil 1.3. 切片的本质 切片的本质就是对底层数组的封装，它包含了三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）。 举个例子，现在有一个数组 a := [8]int{0, 1, 2, 3, 4, 5, 6, 7}，切片 s1 := a[:5]，相应示意图如下。 切片 s2 := a[3:6]，相应示意图如下 1.4. 切片的扩容策略 1、首先判断，如果新申请容量（cap）大于 2 倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）。 2、否则判断，如果旧切片的长度小于 1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap=doublecap） 3、否则判断，如果旧切片长度大于等于 1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的 1/4，即（newcap=old.cap,for{newcap+= newcap/4}）直到最终容量newcap）大于等于新申请的容量(cap)，即（newcap > = cap） 4、如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）。 1.5. 切片的长度和容量 切片拥有自己的长度和容量，我们可以通过使用内置的 **len()**函数求长度，使用内置的 **cap()**函数求切片的容量。 切片的长度就是它所包含的元素个数。 切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。 切片 s 的长度和容量可通过表达式 len(s) 和 cap(s) 来获取。 package main import \"fmt\" // 切片的长度和容量 func showCap() { //声明一个字符串切片 var a = []int{2, 3, 4, 5} fmt.Printf(\"长度%v 容量%v 值%v \\n\", len(a), cap(a), a) b := a[:2] fmt.Printf(\"长度%v 容量%v 值%v \\n\", len(b), cap(b), b) b = a[1:4] fmt.Printf(\"长度%v 容量%v 值%v \\n\", len(b), cap(b), b) } func main() { showCap() } 2. 切片循环 切片的循环遍历和数组的循环遍历是一样的 2.1. 基本遍历 package main import \"fmt\" func forSlice(a *[]string) { // *a[i] 语法错误 可以理解为 *(a[i]) 应当 (*a)[i] for i := 0; i 2.2. k，v遍历 package main import \"fmt\" func kv_forSlice(a *[]string) { for k, v := range *a { fmt.Println(k, v) } } func main() { var a = []string{\"test1\", \"test2\", \"test3\"} kv_forSlice(&a) } 3. 定义切片 3.1. 数组定义切片 由于切片的底层就是一个数组，所以我们可以基于数组定义切片。 package main import \"fmt\" func createArraySlice() { var a = [5]int{1, 2, 3, 4, 5} b := a[1:3] fmt.Printf(\"类型%T value%[1]v \\n\", a) fmt.Printf(\"类型%T value%[1]v \\n\", b) c := b[:1] fmt.Printf(\"类型%T value%[1]v \\n\", c) } func main() { createArraySlice() } 3.2. make()构造切片 我们上面都是基于数组来创建的切片，如果需要动态的创建一个切片，我们就需要使用内置的 make()函数 格式如下：make([]T, size, cap) T:切片的元素类型 size:切片中元素的数量 cap:切片的容量 package main import \"fmt\" func makeCreateSlice() { // Type, size cap a := make([]int ,2 ,10) fmt.Printf(\"长度%v 容量%v 值%v \\n\", len(a), cap(a), a) } func main() { makeCreateSlice() } 上面代码中 a 的内部存储空间已经分配了 10 个，但实际上只用了 2 个。 容量并不会影响当前元素的个数，所以 len(a)返回 2，cap(a)则返回该切片的容量。 4. append() Go 语言的内建函数 append()可以为切片动态添加元素，每个切片会指向一个底层数组 这个数组的容量够用就添加新增元素。 当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。 “扩容”操作往往发生在append()函数调用时，所以我们通常都需要用原变量接收 append 函数的返回值。 4.1. append添加 package main import \"fmt\" func appendMethod() { a := make([]int, 2, 3) a = append(a, 10) fmt.Printf(\"长度%v 容量%v 值%v \\n\", len(a), cap(a), a) a = append(a, 100) // 容量不够则 double fmt.Printf(\"长度%v 容量%v 值%v \\n\", len(a), cap(a), a) } func main() { appendMethod() } 4.2. append追加多个 package main import \"fmt\" func appendMethod() { a := make([]int, 2, 3) a = append(a, 10) fmt.Printf(\"长度%v 容量%v 值%v \\n\", len(a), cap(a), a) a = append(a, 100) fmt.Printf(\"长度%v 容量%v 值%v \\n\", len(a), cap(a), a) } func main() { appendManyMethod() } 4.3. 切片中删除元素 Go 语言中并没有删除切片元素的专用方法，我们可以使用切片本身的特性来删除元素 package main import \"fmt\" func delMethod() { a := []int{1, 2, 3, 4, 5, 6, 7} fmt.Printf(\"长度%v 容量%v 值%v \\n\", len(a), cap(a), a) a = append(a[:2], a[3:]...) fmt.Printf(\"长度%v 容量%v 值%v \\n\", len(a), cap(a), a) } func main() { delMethod() } 4.4. 切片合并 package main import \"fmt\" func mergeSlice() { a := []int{1, 2, 3} b := []int{4, 5, 6, 7} c := append(a, b...) fmt.Printf(\"长度%v 容量%v 值%v \\n\", len(c), cap(c), c) } func main() { mergeSlice() } 5. copy() 5.1. 引用问题 直接引用为浅拷贝 package main import \"fmt\" func copySlice() { a := []int{1, 2, 3, 4} fmt.Printf(\"长度%v 容量%v 值%v \\n\", len(a), cap(a), a) b := a fmt.Printf(\"长度%v 容量%v 值%v \\n\", len(b), cap(b), b) b[0] = 998 fmt.Printf(\"a 长度%v 容量%v 值%v \\n\", len(a), cap(a), a) fmt.Printf(\"b 长度%v 容量%v 值%v \\n\", len(b), cap(b), b) } func main() { copySlice() } 5.2. copy()函数 Go 语言内建的 copy()函数可以迅速地将一个切片的数据复制到另外一个切片空间中 copy()函数的使用格式如下： copy(destSlice, srcSlice []T) 其中： srcSlice: 数据来源切片 destSlice: 目标切片 package main import \"fmt\" func deepcopySlice() { a := []int{1, 2, 3, 4} fmt.Printf(\"长度%v 容量%v 值%v \\n\", len(a), cap(a), a) b := []int{5, 6, 7, 8} fmt.Printf(\"长度%v 容量%v 值%v \\n\", len(b), cap(b), b) copy(b, a) fmt.Printf(\"a 长度%v 容量%v 值%v \\n\", len(a), cap(a), a) fmt.Printf(\"b 长度%v 容量%v 值%v \\n\", len(b), cap(b), b) b[0] = 789 fmt.Printf(\"赋值后a 长度%v 容量%v 值%v \\n\", len(a), cap(a), a) fmt.Printf(\"赋值后b 长度%v 容量%v 值%v \\n\", len(b), cap(b), b) } func main() { deepcopySlice() } 6. sort() 6.1. 正序排序 对于 int 、 float64 和 string 数组或是切片的排序 go 分别提供了 sort.Ints() 、sort.Float64s() 和 sort.Strings() 函数， 默认都是从小到大排序 package main import ( \"fmt\" \"sort\" ) func sortSlice() { aSlice := []int{3, 1, 5, 2, 8} sort.Ints(aSlice) fmt.Println(aSlice) bSlice := []string{\"a\", \"c\", \"d\", \"b\"} sort.Strings(bSlice) fmt.Println(bSlice) } func main() { sortSlice() } 6.2. sort 降序排序 Golang的sort 包 可 以 使 用 sort.Reverse(slice) 来 调 换slice.Interface.Less 也就是比较函数，所以， int 、 float64 和 string的逆序排序函数可以这么写 package main import ( \"fmt\" \"sort\" ) func reserveSortSlice() { aSlice := []int{3, 1, 5, 2, 8} sort.Sort(sort.Reverse(sort.IntSlice(aSlice))) fmt.Println(aSlice) bSlice := []string{\"a\", \"c\", \"d\", \"b\"} sort.Sort(sort.Reverse(sort.StringSlice(bSlice))) fmt.Println(bSlice) } func main() { reserveSortSlice() } console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"shu-ju-lei-xing/qie-pian/qie-pian-di-ceng.html":{"url":"shu-ju-lei-xing/qie-pian/qie-pian-di-ceng.html","title":"切片底层","keywords":"","body":" 切片底层1. 切片1.1. 创建切片1.2. 自动扩容2. 常见操作3. 切片嵌套4. 变量赋值 切片底层 1. 切片 切片，动态数组。 切片是Go中重要的数据类型，每个切片对象内部都维护着：数组指针、切片长度、切片容量 三个数据。 type slice struct { array unsafe.Pointer len int cap int 在向切片中追加的数据个数大于容量时，内部会自动扩容且每次扩容都当前容量的2倍（当容量超过1024时每次扩容则只增加 1/4容量）。 1.1. 创建切片 // 创建切片 var nums []int ​ // 创建切片 var data = []int{11,22,33} data:= []int{11,22,33} ​ // 创建切片 // make只用于 切片、字典、channel var users = make([]int,1,3) // 切片的指针类型 var v1 = new([]int) ​ // 指针类型(nil) var v2 *[]int 1.2. 自动扩容 v1 := make([]int,1,3) ​ fmt.Println(len(v1),cap(v1)) ​ // 其他 data := make([]int,3) v1 := make([]int,1,3) ​ v2 := append(v1,66) ​ fmt.Println(v1) // [0 ] fmt.Println(v2) // [0,66] ​ v1[0] = 999 fmt.Println(v1) // [999 ] fmt.Println(v2) // [999,66] ​ // 需求：有一个切片，请往一个切片中追加一个数据。 v3 := make([]int,1,3) v3 = append(v3,999) v1 := []int{11,22,33} v2 := append(v1,44) ​ v1[0] = 999 ​ fmt.Println(v1) // [999 22 33] fmt.Println(v2) // [11 22 33 44] 2. 常见操作 1 长度和容量 v1 := []int{11,22,33} fmt.Println(len(v1), cap(v1)) 2 索引 v1 := []string{\"alex\",\"李杰\",\"老男孩\"} v1[0] v1[1] v1[2] ​ v2 := make([]int,2,5) v2[0] v2[1] v2[2] // 报错 ​ ​ v2[0] = 999 3 切片 v1 := []int{11,22,33,44,55,66} ​ v2 := v1[1:3] v3 := v1[1:] v4 := v1[:3] ​ // 注意：通过切片切出来的数据和原切片内部存储的数据地址相同 4 追加 package main ​ import ( \"fmt\" ) ​ func main() { v1 := []int{11,22,33} ​ v2 := append(v1,44) ​ v3 := append(v1,55,66,77,88) ​ v4 := append(v1, []int{100,200,300}...) ​ fmt.Println(v2) fmt.Println(v3) fmt.Println(v4) } ​ >>> 输出 [11 22 33 44] [11 22 33 55 66 77 88] [11 22 33 100 200 300] 5 删除 package main ​ import \"fmt\" ​ func main() { v1 := []int{11, 22, 33, 44, 55, 66} deleteIndex := 2 ​ // 切片获取到 {11,22,44、55、66} // 又获取到 {44, 55, 66}，将44、55、66要追加到 result := append(v1[:deleteIndex], v1[deleteIndex+1:]...) fmt.Println(result) // [11 22 44 55 66] fmt.Println(v1) //[11 22 44 55 66 66] } 注意：使用切片时不太会使用删除。【链表】 6 插入 package main ​ import \"fmt\" ​ func main() { v1 := []int{11, 22, 33, 44, 55, 66} insertIndex := 3 // 在索引3的位置插入99 ​ result := make([]int, 0, len(v1)+1) result = append(result, v1[:insertIndex]...) result = append(result,99) result = append(result,v1[insertIndex:]...) fmt.Println(result) } 注意：效率低下。【链表】 7 循环 package main ​ import \"fmt\" ​ func main() { v1 := []int{11, 22, 33, 99, 55, 66} ​ for i := 0; i 3. 切片嵌套 package main ​ import \"fmt\" ​ func main() { v1 := []int{11, 22, 33, 99, 55, 66} v2 := [][]int{[]int{11, 22, 33, 44}, []int{44, 55}} v3 := [][2]int{[2]int{1, 2}, [2]int{4, 5}} ​ fmt.Println(v1) fmt.Println(v2) fmt.Println(v3) ​ v1[0] = 111111 v2[0][2] = 222222 v3[1][0] = 99999 ​ fmt.Println(v1) fmt.Println(v2) fmt.Println(v3) } 4. 变量赋值 整型 package main ​ import \"fmt\" ​ func main() { v1 := 1 v2 := v1 ​ fmt.Printf(\"v1的内存地址：%p \\n\", &v1) // 0xc0000b4008 fmt.Printf(\"v2的内存地址：%p \\n\", &v2) // 0xc0000b4010 } 布尔类型 package main ​ import \"fmt\" ​ func main() { v1 := false v2 := v1 ​ fmt.Printf(\"v1的内存地址：%p \\n\", &v1) // 0xc00012a002 fmt.Printf(\"v2的内存地址：%p \\n\", &v2) // 0xc00012a003 } 浮点型 package main ​ import \"fmt\" ​ func main() { v1 := 3.14 v2 := v1 ​ fmt.Printf(\"v1的内存地址：%p \\n\", &v1) // 0xc000016050 fmt.Printf(\"v2的内存地址：%p \\n\", &v2) // 0xc000016058 } 字符串 package main ​ import \"fmt\" ​ func main() { v1 := \"武沛齐\" v2 := v1 ​ fmt.Printf(\"v1的内存地址：%p \\n\", &v1) // 0xc000010200 fmt.Printf(\"v2的内存地址：%p \\n\", &v2) // 0xc000010210 } 注意：字符串内部元素不可被修改。 数组 package main ​ import \"fmt\" ​ func main() { v1 := [2]int{6, 9} v2 := v1 fmt.Println(v1, v2) fmt.Printf(\"v1的内存地址：%p \\n\", &v1) // 0xc0000b4010 fmt.Printf(\"v2的内存地址：%p \\n\", &v2) // 0xc0000b4020 ​ v1[0] = 11111 fmt.Println(v1, v2) } 切片 package main ​ import \"fmt\" ​ func main() { v1 := []int{6, 9} v2 := v1 fmt.Println(v1, v2) // [6 9] [6 9] fmt.Printf(\"v1的内存地址：%p \\n\", &v1) // 0xc0000a6020 fmt.Printf(\"v2的内存地址：%p \\n\", &v2) // 0xc0000a6040 ​ v1[0] = 11111 fmt.Println(v1, v2) // [11111 9] [11111 9] } 如果扩容，那么内部存储数据的数组就会重新开辟区域。 package main ​ import \"fmt\" ​ func main() { v1 := []int{6, 9} v2 := v1 fmt.Println(v1, v2) // [6 9] [6 9] fmt.Printf(\"v1的内存地址：%p \\n\", &v1) // 0xc0000a6020 fmt.Printf(\"v2的内存地址：%p \\n\", &v2) // 0xc0000a6040 ​ v1 = append(v1, 999) fmt.Println(v1, v2) // [11111 9] [11111 9] } 总结，目前所学的所有的数据类型中，在修改切片的内部元素时，会造成所有的赋值的变量同时修改（不扩容）。 扩展：引用类型和值类型。go \\ 1: console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"shu-ju-lei-xing/map/":{"url":"shu-ju-lei-xing/map/","title":"map","keywords":"","body":" map1. 定义map 1.1. map定义：法1 1.2. map定义：法2 1.3. map嵌套map 2. map基本使用 2.1. 判断某个键是否存在 2.2. delete()函数 3. map遍历 3.1. 3.2. 只遍历Key 3.3. 顺序遍历map map map 是一种无序的基于 key-value 的数据结构，Go 语言中的 map 是引用类型，必须初始化才能使用。 Go 语言中 map 的定义语法如下：map[KeyType]ValueType 其中: KeyType:表示键的类型。 ValueType:表示键对应的值的类型。 map 类型的变量默认初始值为 nil，需要使用 make()函数来分配内存。 其中 cap 表示 map 的容量，该参数虽然不是必须的。 注意：获取 map 的容量不能使用 cap, cap 返回的是数组切片分配的空间大小, 根本不能用于map。 要获取 map 的容量，可以用 len 函数。 1. 定义map 1.1. map定义：法1 package main import \"fmt\" func createMap() { aMap := make(map[string]int, 8) aMap[\"小明\"] = 3 aMap[\"小李\"] = 4 fmt.Println(aMap) fmt.Println(aMap[\"小明\"]) fmt.Printf(\"type: %T, value: %[1]v\", aMap) } func main() { createMap() } 1.2. map定义：法2 package main import \"fmt\" func createMap2() { aMap := map[string]int{ \"张三\": 1, \"李四\": 2, } fmt.Println(aMap) fmt.Println(aMap[\"张三\"]) fmt.Printf(\"type: %T, value: %[1]v\", aMap) } func main() { createMap2() } 1.3. map嵌套map package main import \"fmt\" func createMultiMap() { aMap := make([]map[string]string, 2) for k, v := range aMap { fmt.Printf(\"index:%d value:%v\\n\", k, v) } fmt.Println(\"----赋值后----\") aMap[0] = make(map[string]string, 3) aMap[0][\"name\"] = \"张三\" aMap[1] = make(map[string]string, 3) aMap[1][\"age\"] = \"李四\" for k, v := range aMap { fmt.Printf(\"index:%d value:%v\\n\", k, v) } fmt.Printf(\"type: %T, len: %v,value: %[1]v\", aMap, len(aMap)) } func main() { createMultiMap() } 2. map基本使用 2.1. 判断某个键是否存在 package main import \"fmt\" func isMapKey() { aMap := map[string]int{ \"张三\": 1, \"李四\": 2, } name, isKey := aMap[\"张三\"] if isKey { fmt.Println(name) } else { fmt.Println(\"key 不存在\") } } func main() { isMapKey() } 2.2. delete()函数 使用 delete()内建函数从 map 中删除一组键值对，delete()函数的格式如下：delete(map 对象, key) 其中， map 对象:表示要删除键值对的 map 对象 key:表示要删除的键值对的键 package main import \"fmt\" func deleteMap() { aMap := make(map[string]int, 2) aMap[\"小明\"] = 3 aMap[\"小李\"] = 4 delete(aMap, \"小明\") for k, v := range aMap { fmt.Printf(\"key:%v value:%v\\n\", k, v) } } func main() { deleteMap() } 3. map遍历 遍历key和value package main import \"fmt\" func forMap() { aMap := make(map[string]int, 2) aMap[\"小明\"] = 3 aMap[\"小李\"] = 4 for k, v := range aMap { fmt.Printf(\"key:%v value:%v\\n\", k, v) } } func main() { forMap() } 3.1. 3.2. 只遍历Key 注意： 遍历 map 时的元素顺序与添加键值对的顺序无关 package main import \"fmt\" func forMapKey() { aMap := make(map[string]int, 2) aMap[\"小明\"] = 3 aMap[\"小李\"] = 4 for k := range aMap { fmt.Printf(\"key:%v \\n\", k) } } func main() { forMapKey() } 3.3. 顺序遍历map package main import ( \"fmt\" \"sort\" ) func forSortMapKey() { aMap := make(map[string]int, 20) for i := 0; i console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"shu-ju-lei-xing/map/map-di-ceng-yuan-li-pou-xi.html":{"url":"shu-ju-lei-xing/map/map-di-ceng-yuan-li-pou-xi.html","title":"Map底层原理剖析","keywords":"","body":" Map底层原理剖析1. 初始化2. 写入数据3. 读取数据4. 扩容5. 迁移5.1. 翻倍扩容5.2. 等量扩容 Map底层原理剖析 Golang中的Map有自己的一套实现原理，其核心是由hmap和bmap两个结构体实现 1. 初始化 // 初始化一个可容纳10个元素的map info = make(map[string]string,10) 第一步：创建一个hmap结构体对象。 第二步：生成一个哈希因子hash0 并赋值到hmap对象中（用于后续为key创建哈希值）。 第三步：根据hint=10，并根据算法规则来创建 B，当前B应该为1。 hint B 0~8 0 9~13 1 14~26 2 ... 第四步：根据B去创建去创建桶（bmap对象）并存放在buckets数组中，当前bmap的数量应为2. 当B 当B>=4时，根据B创建桶的个数的规则为：$2^B$ + 2�−4（标准桶+溢出桶） 注意：每个bmap中可以存储8个键值对，当不够存储时需要使用溢出桶，并将当前bmap中的overflow字段指向溢出桶的位置 2. 写入数据 info[\"name\"] = \"武沛齐\" 在map中写入数据时，内部的执行流程为： 第一步：结合哈希因子和键 name生成哈希值 011011100011111110111011011。 第二步：获取哈希值的后B位，并根据后B为的值来决定将此键值对存放到那个桶中（bmap）。 将哈希值和桶掩码（B个为1的二进制）进行 & 运算，最终得到哈希值的后B位的值。假设当B为1时，其结果为 0 ： 哈希值：011011100011111110111011010 桶掩码：000000000000000000000000001 结果： 000000000000000000000000000 = 0 通过示例你会发现，找桶的原则实际上是根据后B为的位运算计算出 索引位置，然后再去buckets数组中根据索引找到目标桶（bmap)。 第三步：在上一步确定桶之后，接下来就在桶中写入数据。 获取哈希值的tophash（即：哈希值的`高8位`），将tophash、key、value分别写入到桶中的三个数组中。 如果桶已满，则通过overflow找到溢出桶，并在溢出桶中继续写入。 注意：以后在桶中查找数据时，会基于tophash来找（tophash相同则再去比较key）。 第四步：hmap的个数count++（map中的元素个数+1 3. 读取数据 value := info[\"name\"] 在map中读取数据时，内部的执行流程为： 第一步：结合哈希引子和键 name生成哈希值。 第二步：获取哈希值的后B位，并根据后B为的值来决定将此键值对存放到那个桶中（bmap）。 第三步：确定桶之后，再根据key的哈希值计算出tophash（高8位），根据tophash和key去桶中查找数据。 当前桶如果没找到，则根据overflow再去溢出桶中找，均未找到则表示key不存在 4. 扩容 在向map中添加数据时，当达到某个条件，则会引发字典扩容。 扩容条件： map中数据总个数 / 桶个数 > 6.5 ，引发翻倍扩容。 使用了太多的溢出桶时（溢出桶使用的太多会导致map处理速度降低）。 B = 2� 时，引发等量扩容。 B > 15，已使用的溢出桶个数 >= 215 时，引发等量扩容。 func hashGrow(t *maptype, h *hmap) { // If we've hit the load factor, get bigger. // Otherwise, there are too many overflow buckets, // so keep the same number of buckets and \"grow\" laterally. bigger := uint8(1) if !overLoadFactor(h.count+1, h.B) { bigger = 0 h.flags |= sameSizeGrow } oldbuckets := h.buckets newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger, nil) ... } 当扩容之后： 第一步：B会根据扩容后新桶的个数进行增加（翻倍扩容新B=旧B+1，等量扩容 新B=旧B）。 第二步：oldbuckets指向原来的桶（旧桶）。 第三步：buckets指向新创建的桶（新桶中暂时还没有数据）。 第四步：nevacuate设置为0，表示如果数据迁移的话，应该从原桶（旧桶）中的第0个位置开始迁移。 第五步：noverflow设置为0，扩容后新桶中已使用的溢出桶为0。 第六步：extra.oldoverflow设置为原桶（旧桶）已使用的所有溢出桶。即：h.extra.oldoverflow = h.extra.overflow 第七步：extra.overflow设置为nil，因为新桶中还未使用溢出桶。 第八步：extra.nextOverflow设置为新创建的桶中的第一个溢出桶的位置 5. 迁移 扩容之后，必然要伴随着数据的迁移，即：将旧桶中的数据要迁移到新桶中。 5.1. 翻倍扩容 如果是翻倍扩容，那么迁移规就是将旧桶中的数据分流至新的两个桶中（比例不定），并且桶编号的位置为：同编号位置 和 翻倍后对应编号位置 那么问题来了，如何实现的这种迁移呢？ 首先，我们要知道如果翻倍扩容（数据总个数 / 桶个数 > 6.5），则新桶个数是旧桶的2倍，即：map中的B的值要+1（因为桶的个数等于$2^B$，而翻倍之后新桶的个数就是$2^B$ * 2 ，也就是$2^{B+1}$，所以 新桶的B的值=原桶B + 1 ）。 迁移时会遍历某个旧桶中所有的key（包括溢出桶），并根据key重新生成哈希值，根据哈希值的 底B位 来决定将此键值对分流道那个新桶中 扩容后，B的值在原来的基础上已加1，也就意味着通过多1位来计算此键值对要分流到新桶位置，如上图： 当新增的位（红色）的值为 0，则数据会迁移到与旧桶编号一致的位置。 当新增的位（红色）的值为 1，则数据会迁移到翻倍后对应编号位置。 例如： 旧桶个数为32个，翻倍后新桶的个数为64。 在重新计算旧桶中的所有key哈希值时，红色位只能是0或1，所以桶中的所有数据的后B位只能是以下两种情况： - 000111【7】，意味着要迁移到与旧桶编号一致的位置。 - 100111【39】，意味着会迁移到翻倍后对应编号位置。 特别提醒：同一个桶中key的哈希值的低B位一定是相同的，不然不会放在同一个桶中，所以同一个桶中黄色标记的位都是相同的。 5.2. 等量扩容 如果是等量扩容（溢出桶太多引发的扩容），那么数据迁移机制就会比较简单，就是将旧桶（含溢出桶）中的值迁移到新桶中。 这种扩容和迁移的意义在于：当溢出桶比较多而每个桶中的数据又不多时，可以通过等量扩容和迁移让数据更紧凑，从而减少溢出桶。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"shu-ju-lei-xing/map/map-ji-chu-cao-zuo.html":{"url":"shu-ju-lei-xing/map/map-ji-chu-cao-zuo.html","title":"map基础操作","summary":"map","keywords":"","body":" map基础操作1. 字典类型（Map）2. 声明&初始化3. 常用操作 map基础操作 1. 字典类型（Map） 在学习任何的编程语言时，一般都会一种数据类型称为：字典(dict)或映射(map)，以键值对为元素的数据集合。例如： { \"age\":\"18\", \"name\":\"武沛齐\", \"email\":\"wupeiqi@live.com\" } 这种类型最大的特点就是查找速度非常快，因为他的底层存储是基于哈希表存储的（不同语言还会有一些差异）。 以取模+拉链法来快速了解下哈希表存储原理，如下图 这种结构之所以快，是因为根据key可以直接找到数据存放的位置；而其他的数据类型是需要从前到后去逐一比对，相对来说比较耗时。 以上只是基本的存储模型，而各个编程语言中的字典都会在此基础上进行相应的修改和优化（后续会深入讲解Golang中的map实现机制）。 Map的特点： 键不能重复 键必须可哈希（目前我们已学的数据类型中，可哈希的有：int/bool/float/string/array） 无序 接下来关于map我会从两个维度来进行讲解： 常见使用 底层原理剖析（面试常问） 2. 声明&初始化 // userInfo := map[string]string{} userInfo := map[string]string{\"name\":\"武沛齐\",\"age\":\"18\"} userInfo[\"name\"] // 武沛齐 userInfo[\"age\"] = \"20\" userInfo[\"email\"] = \"wupeiqi@live.com\" // data := make(map[int]int, 10) data := make(map[int]int) data[100] = 998 data[200] = 999 data := make(map[string]int) data[\"100\"] = 998 data[\"200\"] = 999 // 声明，nil var row map[string]int row = data data := make(map[string]int) data[\"100\"] = 998 data[\"200\"] = 999 // 声明，nil value := new(map[string]int) // value[\"k1\"] = 123 # 报错 value = &data 注意：键不重复 & 键必须可哈希（int/bool/float/string/array） v1 := make(map[[2]int]float32) v1[[2]int{1,1}] = 1.6 v1[[2]int{1,2}] = 3.4 v2 := make(map[[2]int][3]string ) v2[[2]int{1,1}] = [3]string{\"武沛齐\",\"alex\",\"老妖\"} 3. 常用操作 长度和容量 data := map[string]string{\"n1\":\"武沛齐\",\"n2\":\"alex\"} value := len(data) // 2 // 根据参数值（10），计算出合适的容量。 // 一个map 中会包含很多桶，每个桶中可以存放8个键值对。 info := make(map[string]string, 10) info[\"n1\"] = \"武沛齐\" info[\"n2\"] = \"alex\" v1 := len(info) // 2 // v2 := cap(info) // 报错 添加 data := map[string]string{\"n1\":\"武沛齐\",\"n2\":\"alex\"} data[\"n3\"] = \"eric\" 修改 data := map[string]string{\"n1\":\"武沛齐\",\"n2\":\"alex\"} data[\"n1\"] = \"eric\" 删除 data := map[string]string{\"n1\":\"武沛齐\",\"n2\":\"alex\"} delete(data,\"n2\") 查看 data := map[string]string{\"n1\":\"武沛齐\",\"n2\":\"alex\"} data[\"n1\"] data := map[string]string{\"n1\":\"武沛齐\",\"n2\":\"alex\"} for key,value := range data{ fmt.Println(key,value) } data := map[string]string{\"n1\":\"武沛齐\",\"n2\":\"alex\"} for key := range data{ fmt.Println(key) } data := map[string]string{\"n1\": \"武沛齐\", \"n2\": \"alex\"} for _, value := range data { fmt.Println(value) } 嵌套 v1 := make(map[string]int) v2 := make(map[string]string) v3 := make(map[string]...) v4 := make(map[string][2]int) v5 := make(map[string][]int) v6 := make(map[string]map[int]int) v7 := make(map[string][2]map[string]string) v7[\"n1\"] = [2]map[string]string{ map[string]string{\"name\":\"武沛齐\",\"age\":\"18\"},map[string]string{\"name\":\"alex\",\"age\":\"78\"}} v7[\"n2\"] = [2]map[string]string{ map[string]string{\"name\":\"eric\",\"age\":\"18\"},map[string]string{\"name\":\"seven\",\"age\":\"78\"}} // 伪代码 v7 = { n1:[ {\"name\":\"武沛齐\",\"age\":\"18\"}, {\"name\":\"alex\",\"age\":\"78\"} ], n2:[ {\"name\":\"eric\",\"age\":\"18\"}, {\"name\":\"seven\",\"age\":\"78\"} ] } 前提：键不重复 & 键必须可哈希 v8 := make(map[int]int) v9 := make(map[string]int) v10 := make(map[float32]int) v11 := make(map[bool]int) v12 := make(map[ [2]int ]int) v13 := make(map[ []int ]int) // 错误,不可哈希 v14 := make(map[ map[int]int ]int) // 错误，不可哈希 v15 := make(map[ [2][]int ]int) // 报错 v16 := make(map[ [2]map[string]string ]int) // 报错 变量赋值 v1 := map[string]string{\"n1\":\"武沛齐\",\"n2\":\"alex\"} v2 := v1 v1[\"n1\"] = \"wupeiqi\" ftm.Println(v1) // {\"n1\":\"wupeiqi\",\"n2\":\"alex\"} ftm.Println(v2) // {\"n1\":\"wupeiqi\",\"n2\":\"alex\"} 特别提醒：无论是否存在扩容都指向同一个地址。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"shu-ju-lei-xing/zhi-zhen.html":{"url":"shu-ju-lei-xing/zhi-zhen.html","title":"指针详解","keywords":"","body":" 指针详解1.1. 关于指针 1.2. &取变量地址 1.3. 指针修改数据 1.4. new 和 make 1.5. 指针的指针1.6. 指针小高级操作1.7. 指针的计算 指针详解 1.1. 关于指针 要搞明白Go语言中的指针需要先知道3个概念：指针地址、指针类型、指针取值 指针地址（&a） 指针取值（*&a） 指针类型（&a）—>*int改变数据传指针 变量的本质是给存储数据的内存地址起了一个好记的别名。 比如我们定义了一个变量 a := 10 ,这个时候可以直接通过 a 这个变量来读取内存中保存的 10 这个值。 在计算机底层 a 这个变量其实对应了一个内存地址。 指针也是一个变量，但它是一种特殊的变量，它存储的数据不是一个普通的值，而是另一个变量的内存地址。 Go语言中的指针操作非常简单，我们只需要记住两个符号：&（取地址）和 *（根据地址取值） package main import \"fmt\" func pointer() { a := 10 // 值 fmt.Printf(\"%d \\n\", a) // 指针地址 fmt.Printf(\"%d \\n\", &a) // 去内存地址取值 fmt.Printf(\"%d \\n\", *&a) // 指针类型 fmt.Printf(\"%T \\n\", &a) } func main() { pointer() } 1.2. &取变量地址 &符号取地址操作 每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。 Go 语言中使用&字符放在变量前面对变量进行取地址操作。 Go 语言中的值类型（int、float、bool、string、array、struct）都有对应的指针类型 取变量指针的语法如下： ptr := &v // 比如 v 的类型为 T v: 代表被取地址的变量，类型为 T ptr: 用于接收地址的变量，ptr的类型就为*T，称做 T 的指针类型。*代表指针。 package main import \"fmt\" func pointer2() { a := 10 b := &a fmt.Printf(\"%d prt: %p \\n\", a, &a) fmt.Printf(\"%v type: %T \\n\", b, b) fmt.Printf(\"取b的地址 %d\", &b) } func main() { pointer2() } b := \\&a 的图示 1.3. 指针修改数据 *指针取值 在对普通变量使用 & 操作符取地址后会获得这个变量的指针，然后可以对指针使用操作，也就是指针取值 package main import \"fmt\" func pointer3() { a := 10 b := &a fmt.Printf(\"type: %T \\n\", b) c := *b fmt.Printf(\"value: %d type: %[1]T \\n\", c) } func main() { pointer3() } 变量、指针地址、指针变量、取地址、取值的相互关系和特性如下： 对变量进行取地址（&）操作，可以获得这个变量的指针变量。 指针变量的值是指针地址。 对指针变量进行取值（*）操作，可以获得指针变量指向的原变量的值。 指针传值示例 package main import \"fmt\" func pointer5(x *int) { *x = 9 fmt.Printf(\"value: %d type: %[1]T \\n\", x) fmt.Printf(\"value: %d type: %[1]T \\n\", *x) } func main() { var a = 10 pointer4(a) fmt.Println(a) pointer5(&a) fmt.Println(a) } 1.4. new 和 make 执行报错 执行下面的代码会引发 panic，为什么呢？ 在 Go 语言中对于引用类型的变量，我们在使用的时候不仅要声明它，还要为它分配内存空间，否则我们的值就没办法存储。 而对于值类型的声明不需要分配内存空间，是因为它们在声明的时候已经默认分配好了内存空间。 要分配内存，就引出来今天的 new 和 make。 Go 语言中 new 和 make 是内建的两个函数，主要用来分配内存。 package main import \"fmt\" func main() { var a map[string]string a[\"name\"] = \"张三\" fmt.Println(a) } make和new比较 new 和 make 是两个内置函数，主要用来创建并分配类型的内存。 make和new区别 make 关键字的作用是创建于 slice、map 和 channel 等内置的数据结构 new 的作用是为类型申请一片内存空间，并返回指向这片内存的指针 package main import \"fmt\" func createMake() { a := make(map[string]string) a[\"name\"] = \"张三\" fmt.Println(a) b := make([]int, 2, 5) b = append(b, 5) fmt.Println(b) b1 := new([]int) *b1 = append(*b1, 3) fmt.Println(b1) } func main() { createMake() } new函数 一：系统默认的数据类型，分配空间 package main import \"fmt\" func createNew() { // 实例化int a := new(int) *a = 10 fmt.Printf(\"value %d, type %[1]T \\n\", *a) // 实例化slice b := new([]int) *b = append(*b, 3) fmt.Printf(\"value %d, type %[1]T \\n\", *b) // 实例化map c := new(map[string]string) *c = map[string]string{} (*c)[\"name\"] = \"张三\" fmt.Printf(\"value %v, type %[1]T \\n\", *c) } func main() { createNew() } 二：自定义类型使用 new 函数来分配空间 package main import \"fmt\" type people struct { name string age int } func main() { var a *people // 分配空间 a = new(people) a.name = \"张三\" fmt.Printf(\"value %v, type %[1]T \\n\", a) } make函数 make 也是用于内存分配的，但是和 new 不同，它只用于 chan、map 以及 slice 的内存创建 而且它返回的类型就是这三个类型本身，而不是他们的指针类型 因为这三种类型就是引用类型，所以就没有必要返回他们的指针了 package main import \"fmt\" func main() { a := make([]int, 2, 4) b := make(map[string]int) var c = make(chan int, 1) fmt.Printf(\"value %v, type %[1]T \\n\", a) fmt.Printf(\"value %v, type %[1]T \\n\", b) fmt.Printf(\"value %v, type %[1]T \\n\", c) } 当我们为slice分配内存的时候，应当尽量预估到slice可能的最大长度 通过给make传第三个参数的方式来给slice预留好内存空间 这样可以避免二次分配内存带来的开销，大大提高程序的性能。 1.5. 指针的指针 name := \"武沛齐\" // 声明一个指针类型变量p1，内部存储name的内存地址 var p1 *string = &name // 声明一个指针的指针类型变量p2，内部存储指针p1的内存地址 var p2 **string = &p1 // 声明一个指针的指针的指针类型变量p3，内部存储指针p2的内存地址 var p3 ***string = &p 因为有指针的指针存在，所以在使用指针进行重置值时，也需要将相应的*号设置好，例如： package main import \"fmt\" func main() { name := \"武沛齐\" // 声明一个指针类型变量p1，内部存储name的内存地址 var p1 *string = &name *p1 = \"张三\" // 将name的内存中的值由 武沛齐 改为 张三 // 声明一个指针的指针类型变量p2，内部存储指针p1的内存地址 var p2 **string = &p1 **p2 = \"啦啦啦\" // 将name的内存中的值由 张三 改为 啦啦啦 var p3 ***string = &p2 ***p3 = \"我靠\" // 将name的内存中的值由 啦啦啦 改为 我靠 } 1.6. 指针小高级操作 数组的地址 == 数组的第一个元素的地址。 dataList := [3]int8{11, 22, 33} fmt.Printf(\"数组的地址：%p；数组第一个元素的地址：%p \\n\", &dataList, &dataList[0]) // &dataList 和 &dataList[0] 的内存中存储的数据虽然相同gogo，但他们是两个不同类型的指针。 // &dataList 是 *[3]int8 类型 // &dataList[0] 是 *int8 类型 1.7. 指针的计算 gogopackage main import ( \"fmt\" \"unsafe\" ) func main() { dataList := [3]int8{11, 22, 33} // 1.获取数组第一个元素的地址（指针） var firstDataPtr *int8 = &dataList[0] // 2.转换成Pointer类型 ptr := unsafe.Pointer(firstDataPtr) // 3.转换成uintptr类型，然后进行内存地址的计算（即：地址加1个字节，意味着取第2个索引位置的值）。 targetAddress := uintptr(ptr) + 1 // 4.根据新地址，重新转换成Pointer类型 newPtr := unsafe.Pointer(targetAddress) // 5.Pointer对象转换为 int8 指针类型 value := (*int8)(newPtr) // 6.根据指针获取值 fmt.Println(\"最终结果为：\", *value) } console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"shu-ju-lei-xing/jie-gou-ti/":{"url":"shu-ju-lei-xing/jie-gou-ti/","title":"结构体","keywords":"","body":" 结构体1. 结构体基础1.1. 什么是结构体1.2. 自定义类型1.3. 类型别名1.4. 自定义类型和类型别名的区别2. 结构体定义2.1. 基本实例化（法1）2.2. new实例化（法2）2.3. &取地址实例化（法3）2.4. 键值对初始化（法4）2.5. 值列表初始化（法5）2.6. 结构体的匿名字段3. 嵌套结构体3.1. 普通嵌套结构体3.2. 嵌套匿名结构体4. 结构体方法和接收者4.1. 结构体说明4.2. 结构体方法和接收者4.3. 值类型和指针类型接收者5. 结构体继承5.1. 普通传值5.2. 指针传值6. 给任意类型添加方法 结构体 1. 结构体基础 1.1. 什么是结构体 Go语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。 Go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性。 1.2. 自定义类型 在 Go 语言中有一些基本的数据类型，如 string、整型、浮点型、布尔等数据类型 Go 语言中可以使用 type 关键字来定义自定义类型。 将 myInt 定义为 int 类型，通过 type 关键字的定义，myInt 就是一种新的类型，它具有 int 的特性 type myInt int 1.3. 类型别名 Golang1.9 版本以后添加的新功能。 类型别名规定：TypeAlias 只是 Type 的别名，本质上 TypeAlias 与 Type 是同一个类型 就像 一个孩子小时候有大名、小名、英文名，但这些名字都指的是他本人。 type TypeAlias = Type 1.4. 自定义类型和类型别名的区别 类型别名与自定义类型表面上看只有一个等号的差异 结果显示 a 的类型是 main.newInt，表 示 main 包下定义的 newInt 类型。 b 的类型是 int 类型。 package main import \"fmt\" type name string // 类型定义 type age = int // 类型别名 func main() { var a_name name a_name = \"张三\" var a_age age a_age = 11 fmt.Printf(\"type: %T value:%[1]s \\n\", a_name) fmt.Printf(\"type: %T value:%[1]v \\n\", a_age) } 2. 结构体定义 2.1. 基本实例化（法1） 只有当结构体实例化时，才会真正地分配内存，也就是必须实例化后才能使用结构体的字段。 结构体本身也是一种类型，我们可以像声明内置类型一样使用 var 关键字声明结构体类型 package main import \"fmt\" type person struct { name string age int sex string } func main() { var p1 person p1.name = \"张三\" p1.age = 15 p1.sex = \"男\" fmt.Printf(\"type:%T value:%[1]v \\n\", p1) fmt.Printf(\"type:%T value:%#[1]v \\n\", p1) } 2.2. new实例化（法2） 我们还可以通过使用 new 关键字对结构体进行实例化，得到的是结构体的地址 从打印的结果中我们可以看出 p2 是一个结构体指针。 注意：在 Golang 中支持对结构体指针直接使用.来访问结构体的成员。 p2.name = \"张三\" 其实在底层是 (*p2).name = \"张三\" package main import \"fmt\" type person2 struct { name string age int sex string } func main() { var p1 = new(person2) p1.name = \"zs\" p1.age = 111 p1.sex = \"女\" fmt.Printf(\"type:%T value:%[1]v\", p1) fmt.Printf(\"type:%T value:%#[1]v\", p1) } 2.3. &取地址实例化（法3） 使用&对结构体进行取地址操作相当于对该结构体类型进行了一次 new 实例化操作 package main import \"fmt\" type person2 struct { name string age int sex string } func main() { var p1 = &person2{ name: \"张三\", age: 55, sex: \"中\", } (*p1).age = 40 //这样也是可以的 fmt.Printf(\"type:%T value:%[1]v \\n\", p1) fmt.Printf(\"type:%T value:%#[1]v \\n\", p1) } 2.4. 键值对初始化（法4） 注意：最后一个属性的,要加上, package main import \"fmt\" type person2 struct { name string age int sex string } func main() { p1 := person2{ name: \"张三\", age: 55, sex: \"中\", } fmt.Printf(\"type:%T value:%[1]v \\n\", p1) fmt.Printf(\"type:%T value:%#[1]v \\n\", p1) } 2.5. 值列表初始化（法5） 初始化结构体的时候可以简写，也就是初始化的时候不写键，直接写值 必须初始化结构体的所有字段。 初始值的填充顺序必须与字段在结构体中的声明顺序一致。 该方式不能和键值初始化方式混用 package main import \"fmt\" type person2 struct { name string age int sex string } func main() { p1 := &person2{ name: \"张三\", age: 55, sex: \"中\", } (*p1).name = \"qqq\" fmt.Printf(\"type:%T value:%[1]v \\n\", *p1) fmt.Printf(\"type:%T value:%#[1]v \\n\", *p1) } 2.6. 结构体的匿名字段 结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就称为匿名字段。 匿名字段默认采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个。 package main import \"fmt\" type person3 struct { name string age int string } func main() { p1 := person3{ \"张三\", 55, \"嬲\", } fmt.Printf(\"type:%T value:%[1]v \\n\", p1) fmt.Printf(\"type:%T value:%#[1]v \\n\", p1) } 3. 嵌套结构体 3.1. 普通嵌套结构体 一个结构体中可以嵌套包含另一个结构体或结构体指针。 package main import \"fmt\" type room struct { name string } type floor struct { name string room room } type building struct { name name floor floor } func structTest1() { info := building{ \"大厦A\", floor{ \"2楼\", room{ \"A-2-3\", }, }, } fmt.Printf(\"type:%T value:%[1]v \\n\", info) fmt.Printf(\"type:%T value:%#[1]v \\n\", info) } func main() { structTest1() } 3.2. 嵌套匿名结构体 注意：当访问结构体成员时会先在结构体中查找该字段，找不到再去匿名结构体中查找。 package main import \"fmt\" type Room2 struct { name string } type Floor2 struct { name string Room2 } type Building2 struct { name string Floor2 } func structTest2() { // 需先初始化 //info := new(Building2) info := Building2{} info.name = \"B\" info.Floor2.name = \"5层\" info.Room2.name = \"B-5-6\" fmt.Printf(\"type:%T value:%[1]v \\n\", info) fmt.Printf(\"type:%T value:%#[1]v \\n\", info) } func main() { structTest2() } 4. 结构体方法和接收者 4.1. 结构体说明 在 go 语言中，没有类的概念但是可以给类型（结构体，自定义类型）定义方法。 所谓方法就是定义了接收者的函数。 Go语言中的方法（Method）是一种作用于特定类型变量的函数。 这种特定类型变量叫做接收者（Receiver）。 接收者的概念就类似于其他语言中的this或者 self。 方法的定义格式如下： func (接收者变量 接收者类型) 方法名(参数列表) (返回参数) { 函数体 } 给结构体 Person 定义一个方法打印 Person 的信息 4.2. 结构体方法和接收者 package main import \"fmt\" type room struct { name string } func (r room) structFunc() { fmt.Printf(\"type:%T value:%[1]v \\n\", r) fmt.Printf(\"type:%T value:%#[1]v \\n\", r) } func main() { r := room{ name: \"小王子\", } r.structFunc() } 4.3. 值类型和指针类型接收者 实例1：给结构体 Person 定义一个方法打印 Person 的信息 1、值类型的接收者 当方法作用于值类型接收者时，Go 语言会在代码运行时将接收者的值复制一份。 在值类型接收者的方法中可以获取接收者的成员值，但修改操作只是针对副本，无法修改接收者变量本身。 2、指针类型的接收者 指针类型的接收者由一个结构体的指针组成 由于指针的特性，调用方法时修改接收者指针的任意成员变量，在方法结束后，修改都是有效的。 这种方式就十分接近于其他语言中面向对象中的 this 或者 self。 package main import \"fmt\" type Person4 struct { name string age int } //值类型接受者 func (p Person4) personName() { p.name = \"张三\" fmt.Printf(\"type:%T value:%#[1]v \\n\", p) } // 指针类型接受者 func (p *Person4) personAge() { p.age = 998 fmt.Printf(\"type:%T value:%#[1]v \\n\", p) } func main() { p := Person4{} p.personAge() p.personName() } 5. 结构体继承 Go 语言中使用结构体也可以实现其他编程语言中的继承 5.1. 普通传值 package main import \"fmt\" type room3 struct { name string } type floor3 struct { name string room3 // 通过嵌套匿名结构体实现继承 } func (r *room3) room() { r.name = \"301\" } func (f *floor3) floor() { f.name = \"3层\" } func main() { f := floor3{} f.room() f.floor() fmt.Printf(\"%v的%v室\", f.name, f.room3.name) } 5.2. 指针传值 package main import \"fmt\" type room3 struct { name string } func (f *floor4) floor4() { f.name = \"4层\" } func main() { f := &floor4{ name: \"\", room3: &room3{ \"403\", }, } f.floor4() fmt.Printf(\"%v的%v室\", f.name, f.room3.name) } 6. 给任意类型添加方法 在 Go 语言中，接收者的类型可以是任何类型，不仅仅是结构体，任何类型都可以拥有方法。 举个例子，我们基于内置的 int 类型使用 type 关键字可以定义新的自定义类型，然后为我们的自定义类型添加方法。 注意事项： 非本地类型不能定义方法，也就是说我们不能给别的包的类型定义方法。 package main import \"fmt\" type myInt int func (i *myInt) myType() { fmt.Printf(\"type:%T value:%#[1]v \\n\", *i) } func main() { var i myInt i = 100 i.myType() } console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"shu-ju-lei-xing/jie-gou-ti/jie-gou-ti.html":{"url":"shu-ju-lei-xing/jie-gou-ti/jie-gou-ti.html","title":"结构体","keywords":"","body":" 结构体1. 内存管理2. 赋值2.1. 赋值拷贝2.2. 结构体指针赋值2.3. 嵌套赋值拷贝2.4. 谁不拷贝？3. 结构体标签 结构体 什么是结构体？ 结构体是一个复合类型，用于表示一组数据。 结构体由一系列属性组成，每个属性都有自己的类型和值。 1. 内存管理 type Person struct { name string age int } // 初始化结构体 p1 := Person{\"武沛齐\", 18} fmt.Println(p1.name, p1.age) // 初始化结构体指针 p2 := &Person{\"武沛齐\", 1} fmt.Println(p2.name, p2.age 2. 赋值 2.1. 赋值拷贝 type Person struct { name string age int } p1 := Person{name: \"武沛齐\", age: 18} p2 := p1 // 内部将p1重新拷贝一份 fmt.Println(p1) // {武沛齐 18} fmt.Println(p2) // {武沛齐 18} p1.name = \"alex\" fmt.Println(p1) // {alex 19} fmt.Println(p2) // {武沛齐 19 2.2. 结构体指针赋值 type Person struct { name string age int } p1 := &Person{\"武沛齐\", 18} p2 := p1 fmt.Println(p1) // &{武沛齐 18} fmt.Println(p2) // &{武沛齐 18} p1.name = \"alex\" fmt.Println(p1) // &{alex 18} fmt.Println(p2) // &{alex 18 基于结合结构体和结构体指针的特性，基于指针实现数据变化后同步遍布。 type Person struct { name string age int } p1 := Person{name: \"二狗子\", age: 19} p2 := &p1 fmt.Println(p1) // {二狗子 19} fmt.Println(p2) // &{二狗子 19} p1.name = \"alex\" fmt.Println(p1) // {alex 19} fmt.Println(p2) // &{alex 19 2.3. 嵌套赋值拷贝 在存在结构体嵌套时，赋值会拷贝一份所有的数据。 type Address struct { city, state string } type Person struct { name string age int address Address } p1 := Person{name:\"二狗子\",age:19,address: Address{\"北京\", \"BJ\"}} p2 := p1 fmt.Println(p1.address) // {\"北京\" \"BJ\"} fmt.Println(p2.address) // {\"北京\" \"BJ\"} p1.address.city = \"上海\" fmt.Println(p1.address) // {\"上海\" \"BJ\"} fmt.Println(p2.address) // {\"北京\" \"BJ\"} 2.4. 谁不拷贝？ 其实本质上都拷贝了，只不过由于数据存储方式的不同，导致拷贝的有些是数据，有些是内存地址（指针）。 感觉拷贝：字符串、数组、整型等。 感觉不拷贝：map、切片。 package main import \"fmt\" func main() { type Person struct { name string age int hobby [2]string num []int parent map[string]string } p1 := Person{ name: \"二狗子\", age: 19, hobby: [2]string{\"裸奔\", \"大保健\"}, // 拷贝 num: []int{69, 19, 99, 38}, // 未拷贝 (内部维护指针指向数据存储的地方) parent: map[string]string{\"father\": \"Alex\", \"mother\": \"Monika\"}, // 未拷贝 (内部维护指针指向数据存储的地方) } p2 := p1 fmt.Println(p1) fmt.Println(p2) p1.parent[\"father\"] = \"武沛齐\" fmt.Println(p1) fmt.Println(p2) } 注意：对于那些默认拷贝的情况，可以改变为指针类型，让数据实现同步修改。 type Address struct { city, state string } type Person struct { name string age int hobby *[2]string num []int parent map[string]string address Address } p1 := Person{ name: \"二狗子\", age: 19, hobby: &[2]string{\"裸奔\", \"大保健\"}, num: []int{69, 19, 99, 38}, parent: map[string]string{\"father\": \"Alex\", \"mother\": \"Monika\"}, } p2 := p1 p1.hobby[0] = \"洗澡\" fmt.Println(p1.hobby) // &[洗澡 大保健] fmt.Println(p2.hobby) // &[洗澡 大保健] 3. 结构体标签 package main import ( \"fmt\" \"reflect\" ) func main() { type Person struct { name string \"姓名\" age int32 \"年龄\" blog string \"博客\" } p1 := Person{name: \"武沛齐\", age: 18, blog: \"https://www.pythonav.com\"} p1Type := reflect.TypeOf(p1) // 方式1 filed1 := p1Type.Field(0) fmt.Println(filed1.Tag) // 姓名 filed1.Name -> name // 方式2 filed2, _ := p1Type.FieldByName(\"blog\") fmt.Println(filed2.Tag) // // 循环获取 fieldNum := p1Type.NumField() // 总共有多少个字段 3 // 循环：0 1 2 for index := 0; index console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"shu-ju-lei-xing/interfacejie-kou.html":{"url":"shu-ju-lei-xing/interfacejie-kou.html","title":"interface接口","keywords":"","body":" interface接口1. Golang接口的定义1.1. Golang 中的接口1.2. 定义一个Usber接口2. 空接口2.1. 空接口说明2.2. 空接口作为函数的参数2.3. 切片实现空接口2.4. map 的值实现空接口3. 类型断言4. 值接收者和指针接收者4.1. 值接收者4.2. 指针接收者5. 一个结构体实现多个接口6. 接口嵌套 interface接口 1. Golang接口的定义 1.1. Golang 中的接口 在Go语言中接口（interface）是一种类型，一种抽象的类型。 接口（interface）定义了一个对象的行为规范，只定义规范不实现，由具体的对象来实现规范的细节。 实现接口的条件 一个对象只要全部实现了接口中的方法，那么就实现了这个接口。 换句话说，接口就是一个需要实现的方法列表。 1.2. 定义一个Usber接口 定义一个 Usber 接口让 Phone 和 Camera 结构体实现这个接口 package main import \"fmt\" // User 接口是一个规范 type User interface { start() end() } // Phone 如果接口里面有方法的话，必要要通过结构体或者通过自定义类型实现这个接口 type Phone struct { Name string } // 手机实现开机方法 func (p Phone) start() { fmt.Println(p.Name, \"开机\") } // 手机实现关机方法 func (p Phone) end() { fmt.Println(p.Name, \"关机\") } func main() { p := Phone{Name: \"Iphone\"} var p1 User // golang中接口就是一个数据类型 p1 = p // 表示获取手机数据 p1.start() p1.end() } 2. 空接口 2.1. 空接口说明 golang中空接口也可以直接当做类型来使用，可以表示任意类型 Golang 中的接口可以不定义任何方法，没有定义任何方法的接口就是空接口。 空接口表示没有任何约束，因此任何类型变量都可以实现空接口。 空接口在实际项目中用的是非常多的，用空接口可以表示任意数据类型。 2.2. 空接口作为函数的参数 package main import \"fmt\" //空接口作为函数的参数 func show(a interface{}) { fmt.Printf(\"type：%T value:%[1]v \\n\", a) } func main() { show(20) show(\"hello word\") slice := []int{1, 2, 3, 4} show(slice) } 2.3. 切片实现空接口 package main import \"fmt\" func main() { var slice = []interface{}{1, 2, 3, 4} fmt.Printf(\"type：%T value:%[1]v \\n\", slice) } 2.4. map 的值实现空接口 package main import \"fmt\" func main() { // 空接口作为 map 值 var aMap = make(map[string]interface{}) aMap[\"age\"] = 123 aMap[\"name\"] = \"张三\" fmt.Printf(\"type：%T value:%[1]v \\n\", aMap) } 3. 类型断言 一个接口的值（简称接口值）是由一个具体类型和具体类型的值两部分组成的。 这两部分分别称为接口的动态类型和动态值。 如果我们想要判断空接口中值的类型，那么这个时候就可以使用类型断言 其语法格式：x.(T) x : 表示类型为 interface{}的变量 T : 表示断言 x 可能是的类型 package main import \"fmt\" func main() { var x interface{} x = 123 v, ok := x.(string) if ok { fmt.Println(\"ok\", v, ok) } else { fmt.Println(\"no\", v, ok) } } 4. 值接收者和指针接收者 4.1. 值接收者 如果结构体中的方法是值接收者，那么实例化后的结构体值类型和结构体指针类型都可以赋值给接口变量 package main import \"fmt\" // User 接口是一个规范 type User interface { start() end() } // Phone 如果接口里面有方法的话，必要要通过结构体或者通过自定义类型实现这个接口 type Phone struct { Name string } // 手机实现开机方法 func (p Phone) start() { fmt.Println(p.Name, \"开机\") } // 手机实现关机方法 func (p Phone) end() { fmt.Println(p.Name, \"关机\") } func main() { //p := Phone{Name: \"Iphone\"} //var p1 User // golang中接口就是一个数据类型 //p1 = p // 表示获取手机数据 //p1.start() //p1.end() i := Phone{Name: \"苹果\"} var p1 User = i //苹果 实现了 开关机 接口 p1 是 Phone 类型 p1.start() p1.end() m := &Phone{Name: \"小米\"} var p2 User = m //小米 实现了 开关机 接口 p2 是 *Phone 类型 p2.start() p2.end() } 4.2. 指针接收者 如果结构体中的方法是指针接收者，那么实例化后结构体指针类型都可以赋值给接口变量，结构体值类型没法赋值给接口变量。 package main import \"fmt\" // Usb 接口定义 type Usb interface { start() end() } // MyPhone 结构体 type MyPhone struct { Name string } func (p *MyPhone) start() { fmt.Println(p.Name, \"开启了Usb接口\") } func (p *MyPhone) end() { fmt.Println(p.Name, \"结束了Usb接口\") } func main() { // 错误写法 //i := MyPhone{Name: \"华为手机\"} //var p Usb = i //p.start() //p.end() // 正确写法 i := MyPhone{Name: \"华为手机\"} var p Usb = &i p.start() p.end() } 5. 一个结构体实现多个接口 Golang 中一个结构体也可以实现多个接口 package main import \"fmt\" // Age 我的年龄 type Age interface { MyAge() } // Sex 我的性别 type Sex interface { MySex() } // SetAgeAndSex 修改我的信息 type SetAgeAndSex interface { SetMyInfo(*string, *int) } // My 我的信息 type My struct { Sex string Age int } // SetMyInfo 修改我的信息 func (m *My) SetMyInfo(s *string, a *int) { m.Sex = *s m.Age = *a fmt.Println(\"修改信息\") } // MySex 我的性别 func (m My) MySex() { fmt.Println(\"我的性别为\", m.Sex) } // MyAge 我的年龄 func (m *My) MyAge() { fmt.Println(\"我\", m.Age, \"岁\") } func main() { // 初始化我的信息 my := &My{ Sex: \"男\", Age: 998, } var age Age = my var sex Sex = my // 输出我的信息 age.MyAge() sex.MySex() // 获取我的信息 var setInfo SetAgeAndSex = my s := \"娚\" a := 18 // 修改我的信息 setInfo.SetMyInfo(&s, &a) age.MyAge() sex.MySex() } 6. 接口嵌套 接口与接口间可以通过嵌套创造出新的接口。 package main import \"fmt\" type Append interface { add() } type Delete interface { pop() } // SliceMethod 接口嵌套 type SliceMethod interface { Append Delete } // Slice 创建切片 type Slice []int // 给切片添加元素 func (s *Slice) add() { *s = append(*s, 6) } // 给切片删除元素 func (s *Slice) pop() { *s = append((*s)[:2], (*s)[4:]...) } func run() *Slice { // 初始化数据 s := &Slice{1, 2, 3, 4, 5} fmt.Println(*s) // 接口赋值 var sm SliceMethod = s // 执行添加/删除方法 sm.add() sm.pop() return s } func main() { s := run() fmt.Println(*s) } console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"mian-xiang-dui-xiang.html":{"url":"mian-xiang-dui-xiang.html","title":"面向对象","keywords":"","body":" console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"mian-xiang-dui-xiang/han-shu.html":{"url":"mian-xiang-dui-xiang/han-shu.html","title":"函数","keywords":"","body":" 函数1. 函数基础1.1. 函数定义1.2. 可变参数1.3. 函数返回值1.4. 函数类型与变量2. 函数变量作用域2.1. 全局变量2.2. 局部变量2.3. 语句块定义的变量2.4. for 循环语句中定义的变量3. 高阶函数4. 匿名函数5. 闭包5.1. 闭包的概念5.2. 闭包变量作用域5.3. 闭包的三种形式5.4. 闭包进阶示例 25.5. 闭包进阶示例 3 函数 1. 函数基础 1.1. 函数定义 函数是组织好的、可重复使用的、用于执行指定任务的代码块。 本文介绍了 Go 语言中函数的相关内容。 Go 语言中支持：函数、匿名函数和闭包 package main import \"fmt\" func inSum(a, b int) int { return a + b } func main() { ret := inSum(1, 2) fmt.Println(ret) } 1.2. 可变参数 可变参数是指函数的参数数量不固定。 Go 语言中的可变参数通过在参数名后加...来标识。 注意：可变参数通常要作为函数的最后一个参数。 package main import \"fmt\" func inSum2(a string, x ...int) int { fmt.Println(a) // zs fmt.Println(x) // x是一个切片 = [1, 2] sum := 0 for _, i := range x { sum += i } return sum } func main() { str := \"zs\" ret := inSum2(str, 1, 2) fmt.Println(ret) } 1.3. 函数返回值 Go 语言中通过 return 关键字向外输出返回值。 函数多返回值，Go 语言中函数支持多返回值，函数如果有多个返回值时必须用()将所有返回值包裹起来 package main import \"fmt\" func calc(a, b int) (int, int) { var sum = a + b var sub = a - b return sum, sub } func main() { sum, sub := calc(1, 2) fmt.Println(sum, sub) } 1.4. 函数类型与变量 定义函数类型，我们可以使用 type 关键字来定义一个函数类型 具体格式如下： type calculation func(int, int) int 上面语句定义了一个 calculation 类型，它是一种函数类型，这种函数接收两个 int 类型的参数并且返回一个 int 类型的返回值。 简单来说，凡是满足这个条件的函数都是 calc 类型的函数，例如下面的 add 和 sub 是calculation 类型。 package main import \"fmt\" func inSum(a, b int) int { return a + b } type test func(int, int) int func main() { var t test // 声明一个 test 类型的变量 t t = inSum // 把 inSum 赋值给 t fmt.Println(t(1, 3)) fmt.Printf(\"type of t:%T\\n\", t) } 2. 函数变量作用域 2.1. 全局变量 全局变量是定义在函数外部的变量，它在程序整个运行周期内都有效。 在函数中可以访问到全局变量 package main import \"fmt\" const age int = 998 func main() { fmt.Printf(\"type of age:%T value: %[1]v \\n\", age) } 2.2. 局部变量 局部变量是函数内部定义的变量， 函数内定义的变量无法在该函数外使用 例如下面的示例代码 main 函数中无法使用 testLocalVar 函数中定义的变量 x package main import \"fmt\" func test2() { name := \"张三\" fmt.Println(name) } func main() { //fmt.Printf(\"type of age:%T value: %[1]v \\n\", name) } 2.3. 语句块定义的变量 接下来我们来看一下语句块定义的变量，通常我们会在 if 条件判断、for 循环、switch 语句上使用这种定义变量的方式 package main import \"fmt\" func test3(x, y int) { fmt.Println(x, y) //函数的参数也是只在本函数中生效 if x 2.4. for 循环语句中定义的变量 我们之前讲过的 for 循环语句中定义的变量，也是只在 for 语句块中生效 package main import \"fmt\" func forTest() { for i := 0; i 3. 高阶函数 高阶函数分为函数作为参数和函数作为返回值两部分。 函数作为参数，函数也可以作为返回值 package main import \"fmt\" func add(x, y int) int { return x + y } func sub(x, y int) int { return x - y } func do(s string) func(int, int) int { switch s { case \"+\": return add case \"-\": return sub default: return nil } } func main() { a := do(\"+\") b := do(\"-\") fmt.Println(a(1, 3)) fmt.Println(b(1, 3)) } 4. 匿名函数 匿名函数由一个不带函数名的函数声明和函数体组成。 匿名函数的优越性在于可以直接使用函数内的变量，不必申明。 匿名函数因为没有函数名，所以没办法像普通函数那样调用，所以匿名函数需要保存到某个变量或者作为立即执行函数 匿名函数多用于实现回调函数和闭包 package main import \"fmt\" func main() { // 一：匿名函数 匿名自执行函数 func() { fmt.Println(\"test\") }() // 二：匿名函数 var fn = func(a, b int) int { return a + b } fmt.Println(fn(1, 2)) // 三：匿名函数 自动执行 接收参数 func(x, y int) { fmt.Println(x, y) }(10, 20) } 5. 闭包 5.1. 闭包的概念 闭包可以理解成“定义在一个函数内部的函数“。 在本质上，闭包是将函数内部和函数外部连接起来的桥梁。 举例： 变量 f 是一个函数并且它引用了其外部作用域中的 x 变量，此时 f 就是一个闭包。 在 f 的生命周期内，变量 x 也一直有效。 package main import \"fmt\" func adder() func(int) int { var x int return func(y int) int { x += y return x } } func main() { var f = adder() fmt.Println(f(10)) fmt.Println(f(20)) fmt.Println(f(30)) f1 := adder() fmt.Println(f1(30)) fmt.Println(f1(30)) } 5.2. 闭包变量作用域 全局变量特点： 1、常驻内存 2、污染全局 局部变量的特点： 1、不常驻内存 2、不污染全局 闭包： 1、可以让一个变量常驻内存 2、可以让一个变量不污染全局 闭包 1、闭包是指有权访问另一个函数作用域中的变量的函数。 2、创建闭包的常见的方式就是在一个函数内部创建另一个函数，通过另一个函数访问这个函数的局部变量。 注意： 由于闭包里作用域返回的局部变量资源不会被立刻销毁回收，所以可能会占用更多的内存。 过度使用闭包会导致性能下降，建议在非常有必要的时候才使用闭包。 5.3. 闭包的三种形式 闭包进阶示例 1 package main import \"fmt\" func adder2(x int) func(int) int { return func(y int) int { x += y return x } } func main() { f1 := adder2(2) fmt.Println(f1(30)) fmt.Println(f1(30)) } 5.4. 闭包进阶示例 2 package main import ( \"fmt\" \"strings\" ) func makeSuffixFunc(suffix string) func(string2 string) string { return func(name string) string { // 判断 name 是否以 suffix 结尾 // 判断 name 是否以 suffix 结尾 if !strings.HasSuffix(name, suffix) { return name + suffix } return name } } func main() { jpg := makeSuffixFunc(\".jpg\") txt := makeSuffixFunc(\".txt\") fmt.Println(jpg(\"test\")) fmt.Println(txt(\"test.txt\")) } 5.5. 闭包进阶示例 3 package main import ( \"fmt\" ) func calcTest(base int) (func(int) int, func(int) int) { add := func(i int) int { base += i return base } sub := func(i int) int { base -= i return base } return add, sub } func main() { f1, f2 := calcTest(2) fmt.Println(f1(1), f2(1)) } console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"mian-xiang-dui-xiang/deferyan-chi-diao-yong.html":{"url":"mian-xiang-dui-xiang/deferyan-chi-diao-yong.html","title":"defer延迟调用","keywords":"","body":" defer延时调用1. defer介绍1.1. defer特性1.2. defer用途1.3. defer语句使用说明1.4. defer 执行时机1.5. defer案例2. defer陷阱2.1. defer 碰上闭包 defer延时调用 1. defer介绍 1.1. defer特性 1.关键字defer用于注册延迟调用。 2.这些调用直到return前才被执。因此，可以用来做资源清理。 3.多个defer语句，按先进后出的方式执行。 4.defer语句中的变量，在defer声明时就决定了。 1.2. defer用途 1.关闭文件句柄 2.锁资源释放 3.数据库连接释放 1.3. defer语句使用说明 defer实现类似于栈，先进后出 而且是在函数执行完成到return返回之间调用 package main import \"fmt\" func main() { fmt.Println(\"start\") defer fmt.Println(1) defer fmt.Println(2) defer fmt.Println(3) fmt.Println(\"end\") } 1.4. defer 执行时机 在 Go 语言的函数中 return 语句在底层并不是原子操作，它分为给返回值赋值和 RET 指令两步。 而 defer 语句执行的时机就在返回值赋值操作后，RET 指令执行前。 具体如下图所示： 1.5. defer案例 defer 注册要延迟执行的函数时该函数所有的参数都需要确定其值 package main import \"fmt\" func calc(index string, a, b int) int { ret := a + b fmt.Println(index, a, b, ret) return ret } func main() { var x, y int defer calc(\"AA\", x, calc(\"A\", x, y)) x = 10 defer calc(\"BB\", x, calc(\"B\", x, y)) y = 10 } 2. defer陷阱 2.1. defer 碰上闭包 也就是说函数正常执行,由于闭包用到的变量 i 在执行的时候已经变成4,所以输出全都是4 package main import \"fmt\" func main() { var whatever [5]struct{} for i := range whatever { defer func() { fmt.Println(i) }() } } console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"mian-xiang-dui-xiang/yi-chang-chu-li.html":{"url":"mian-xiang-dui-xiang/yi-chang-chu-li.html","title":"异常处理","keywords":"","body":" 异常处理1. 异常处理介绍1.1. go中异常处理介绍1.2. panic1.3. recover1.4. 注意2. panic/recover异常处理2.1. panic触发程序奔溃2.2. defer 、recover 实现异常处理2.3. defer 、panic、recover 抛出异常 异常处理 1. 异常处理介绍 1.1. go中异常处理介绍 Golang 没有结构化异常，使用 panic 抛出错误，recover 捕获错误。 Go中可以抛出一个panic的异常，然后在defer中通过recover捕获这个异常，然后正常处理。 panic可以在任何地方引发，但 recover 只有在 defer 调用的函数中有效。 1.2. panic 1、内置函数 2、假如函数F中书写了panic语句，会终止其后要执行的代码，在panic所在函数F内如果存在要执行的defer函数列表，按照defer的逆序执行 3、返回函数F的调用者G，在G中，调用函数F语句之后的代码不会执行，假如函数G中存在要执行的defer函数列表，按照defer的逆序执行 4、直到goroutine整个退出，并报告错误 1.3. recover 1、内置函数 2、用来控制一个goroutine的panicking行为，捕获panic，从而影响应用的行为 3、一般的调用建议 a). 在defer函数中，通过recever来终止一个goroutine的panicking过程，从而恢复正常代码的执行 b). 可以获取通过panic传递的error 1.4. 注意 利用recover处理panic指令，defer 必须放在 panic 之前定义，另外 recover 只有在 defer 调用的函数中才有效。 否则当panic时，recover无法捕获到panic，无法防止panic扩散。 recover 处理异常后，逻辑并不会恢复到 panic 那个点去，函数跑到 defer 之后的那个点。 多个 defer 会形成 defer 栈，后定义的 defer 语句会被最先调用。 2. panic/recover异常处理 2.1. panic触发程序奔溃 程序运行期间 funcB 中引发了 panic 导致程序崩溃，异常退出了。 这个时候我们就可以通过recover 将程序恢复回来，继续往后执行。 package main func test1() { panic(\"panic in 1\") } func test2() { test1() } func main() { test2() } 2.2. defer 、recover 实现异常处理 recover()必须搭配 defer 使用 defer 一定要在可能引发 panic 的语句之前定义 package main import \"fmt\" func funcA() { defer func() { if err := recover(); err != nil { fmt.Println(err) } }() num1 := 10 num2 := 0 res := num1 / num2 fmt.Println(res) } func main() { funcA() } 2.3. defer 、panic、recover 抛出异常 package main import ( \"errors\" \"fmt\" ) func readFile(fileName string) error { if fileName == \"main.go\" { return nil } return errors.New(\"读取文件错误\") } func main() { defer func() { if err := recover(); err != nil { fmt.Println(err) } }() var err = readFile(\"xxx.go\") if err != nil { println(err) } fmt.Println(\"继续执行\") } 参数替换为 main.go console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"mian-xiang-dui-xiang/zhuang-shi-qi.html":{"url":"mian-xiang-dui-xiang/zhuang-shi-qi.html","title":"装饰器","keywords":"","body":" 装饰器1. golang装饰器1.1. 简单timer装饰器1.2. 项目中认证实现 装饰器 1. golang装饰器 1.1. 简单timer装饰器 package main import ( \"fmt\" \"time\" ) func timer(fn func()) func() { return func() { startTime := time.Now().Unix() fn() endTime := time.Now().Unix() fmt.Println(\"运行时间: \", endTime-startTime) } } func testFunc() { fmt.Println(\"运行 testFunc\") time.Sleep(time.Second * 2) } func main() { test := timer(testFunc) test() } 1.2. 项目中认证实现 package main import ( \"fmt\" \"log\" \"net/http\" ) type DecoratorHandler func(handlerFunc http.HandlerFunc) http.HandlerFunc func middlewareHandlerFunc(hp http.HandlerFunc, decors ...DecoratorHandler) http.HandlerFunc { for _, fn := range decors { dp := fn hp = dp(hp) } return hp } func verifyHeader(h http.HandlerFunc) http.HandlerFunc { return func(w http.ResponseWriter, request *http.Request) { token := request.URL.Query().Get(\"token\") if token == \"\" { fmt.Fprintf(w, request.URL.Path+\"verifyHeader:token is null\") return } h(w, request) } } func verifyHeader2(h http.HandlerFunc) http.HandlerFunc { return func(w http.ResponseWriter, request *http.Request) { token := request.URL.Query().Get(\"token\") if token != \"mimi\" { fmt.Fprintf(w, request.URL.Path+\"verifyHeader:token is mimi\") return } h(w, request) } } func Pong(w http.ResponseWriter, request *http.Request) { fmt.Fprintf(w, request.URL.Path+\"--> success\") } func main() { http.HandleFunc(\"/test\", middlewareHandlerFunc(Pong, verifyHeader, verifyHeader2)) err := http.ListenAndServe(\":8888\", nil) if err != nil { log.Fatal(\"ListenAndServe:\", err) } } console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"bing-fa-bian-cheng.html":{"url":"bing-fa-bian-cheng.html","title":"并发编程","keywords":"","body":"123 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"bing-fa-bian-cheng/goroutinejie-shao.html":{"url":"bing-fa-bian-cheng/goroutinejie-shao.html","title":"goroutine介绍","keywords":"","body":" goroutine介绍1. 并发介绍1.1. 并发和并行1.2. 协程和线程2. goroutine2.1. 多线程编程缺点2.2. gouroutine goroutine介绍 1. 并发介绍 1.1. 并发和并行 A. 多线程程序在一个核的cpu上运行，就是并发。 B. 多线程程序在多个核的cpu上运行，就是并行。 并发：本质还是串行 并行：任务分布在不同CPU上，同一时间点同时执行 1.2. 协程和线程 协程：独立的栈空间，共享堆空间，调度由用户自己控制，本质上有点类似于用户级线程，这些用户级线程的调度也是自己实现的。 线程：一个线程上可以跑多个协程，协程是轻量级的线程。 2. goroutine 2.1. 多线程编程缺点 在java/c++中我们要实现并发编程的时候，我们通常需要自己维护一个线程池 并且需要自己去包装一个又一个的任务，同时需要自己去调度线程执行任务并维护上下文切换 2.2. gouroutine Go语言中的goroutine就是这样一种机制，goroutine的概念类似于线程，但 goroutine是由Go的运行时（runtime）调度和管理的。 Go程序会智能地将 goroutine 中的任务合理地分配给每个CPU。 Go语言之所以被称为现代化的编程语言，就是因为它在语言层面已经内置了调度和上下文切换的机制。 在Go语言编程中你不需要去自己写进程、线程、协程，你的技能包里只有一个技能–goroutine 当你需要让某个任务并发执行的时候，你只需要把这个任务包装成一个函数 开启一个goroutine去执行这个函数就可以了，就是这么简单粗暴。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"bing-fa-bian-cheng/xie-cheng-diao-du-grm-mo-xing.html":{"url":"bing-fa-bian-cheng/xie-cheng-diao-du-grm-mo-xing.html","title":"协程调度GRM模型","keywords":"","body":" 协程调度GRM模型1. 线程调度1.1. 早期单线程操作系统1.2. 多进程/线程时代1.3. Go协程goroutine1.4. 协程与线程区别2. 调度器GMP模型2.1. GM模型2.2. GMP模型3. GPM流程分析3.1. P本地队列获取G3.2. 本地队列中G移动到全局队列3.3. 从其他P本地队列的G放到自己P队列3.4. M从P获取下一个G，不断重复 协程调度GRM模型 1. 线程调度 1.1. 早期单线程操作系统 一切的软件都是跑在操作系统上，真正用来干活(计算)的是CPU。 早期的操作系统每个程序就是一个进程，知道一个程序运行完，才能进行下一个进程，就是“单进程时代” 一切的程序只能串行发生。 1.2. 多进程/线程时代 在多进程/多线程的操作系统中，就解决了阻塞的问题，因为一个进程阻塞cpu可以立刻切换到其他进程中去执行 而且调度cpu的算法可以保证在运行的进程都可以被分配到cpu的运行时间片 这样从宏观来看，似乎多个进程是在同时被运行。 但新的问题就又出现了，进程拥有太多的资源，进程的创建、切换、销毁，都会占用很长的时间 CPU虽然利用起来了，但如果进程过多，CPU有很大的一部分都被用来进行进程调度了 大量的进程/线程出现了新的问题 高内存占用 调度的高消耗CPU 进程虚拟内存会占用4GB[32位操作系统], 而线程也要大约4MB 1.3. Go协程goroutine Go中，协程被称为goroutine，它非常轻量，一个goroutine只占几KB，并且这几KB就足够goroutine运行完 这就能在有限的内存空间内支持大量goroutine，支持了更多的并发 虽然一个goroutine的栈只占几KB，但实际是可伸缩的，如果需要更多内容，runtime会自动为goroutine分配。 Goroutine特点： 占用内存更小（几kb） 调度更灵活(runtime调度) 1.4. 协程与线程区别 协程跟线程是有区别的，线程由CPU调度是抢占式的 协程由用户态调度是协作式的，一个协程让出CPU后，才执行下一个协程 2. 调度器GMP模型 G：goroutine（协程） M：thread（内核线程，不是用户态线程） P：processer（调度器） 2.1. GM模型 G（协程），通常在代码里用 go 关键字执行一个方法，那么就等于起了一个G。 M（内核线程），操作系统内核其实看不见G和P，只知道自己在执行一个线程。 G和P都是在用户层上的实现。 并发量小的时候还好，当并发量大了，这把大锁，就成为了性能瓶颈。 GPM由来 基于没有什么是加一个中间层不能解决的思路，golang在原有的GM模型的基础上加入了一个调度器P 可以简单理解为是在G和M中间加了个中间层 于是就有了现在的GMP模型里的P 2.2. GMP模型 3. GPM流程分析 我们通过 go func()来创建一个goroutine； 3.1. P本地队列获取G M想要运行G，就得先获取P，然后从P的本地队列获取G 3.2. 本地队列中G移动到全局队列 新建 G 时，新G会优先加入到 P 的本地队列； 如果本地队列满了，则会把本地队列中一半的 G 移动到全局队列 3.3. 从其他P本地队列的G放到自己P队列 如果全局队列为空时，M 会从其他 P 的本地队列偷（stealing）一半G放到自己 P 的本地队列。 3.4. M从P获取下一个G，不断重复 M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"bing-fa-bian-cheng/xie-cheng-ji-ben-shi-yong.html":{"url":"bing-fa-bian-cheng/xie-cheng-ji-ben-shi-yong.html","title":"协程基本使用","keywords":"","body":" 协程基本使用1. 协程基本使用1.1. 启动一个协程1.2. WaitGroup等待协程执行完毕2. 多携程案例2.1. 开启多个协程2.2. 多协程统计素数 协程基本使用 1. 协程基本使用 1.1. 启动一个协程 主线程中每个100毫秒打印一次，总共打印2次 另外开启一个协程，打印10次 情况一：打印是交替，证明是并行的 情况二：开启的协程打印两次，就退出了（因为主线程退出了） package main import ( \"fmt\" \"time\" ) func main() { go test() //表示开启一个协程 for i := 0; i 1.2. WaitGroup等待协程执行完毕 主线程退出后所有的协程无论有没有执行完毕都会退出 所以我们在主进程中可以通过WaitGroup等待协程执行完毕 sync.WaitGroup内部维护着一个计数器，计数器的值可以增加和减少。 例如当我们启动了N 个并发任务时，就将计数器值增加N。 每个任务完成时通过调用Done()方法将计数器减1。 通过调用Wait()来等待并发任务执行完，当计数器值为0时，表示所有并发任务已经完成。 var wg sync.WaitGroup // 第一步：定义一个计数器 wg.Add(1) // 第二步：开启一个协程计数器+1 wg.Done() // 第三步：协程执行完毕，计数器-1 wg.Wait() // 第四步：计数器为0时推出 package main import ( \"fmt\" \"sync\" \"time\" ) var wg sync.WaitGroup // 第一步：定义一个计数器 func test1() { for i := 0; i 2. 多携程案例 2.1. 开启多个协程 在 Go 语言中实现并发就是这样简单，我们还可以启动多个 goroutine。 这里使用了 sync.WaitGroup 来实现等待 goroutine 执行完毕 多次执行上面的代码，会发现每次打印的数字的顺序都不一致。 这是因为 10 个 goroutine是并发执行的，而 goroutine 的调度是随机的。 package main import ( \"fmt\" \"sync\" ) var wg1 sync.WaitGroup func hello(i int) { defer wg1.Done() // goroutine结束就登记-1 fmt.Println(\"hello world\", i) } func main() { for i := 0; i 2.2. 多协程统计素数 需求：要统计1-120000的数字中那些是素数？goroutine for循环实现 1 协程 统计 1-30000 2 协程 统计 30001-60000 3 协程 统计 60001-90000 4 协程 统计 90001-120000 start:(n-1)*30000+1 end:n*30000 package main import ( \"fmt\" \"sync\" \"time\" ) var wg2 sync.WaitGroup func test3(n int) { for num := (n-1)*30000 + 1; num 1 { var flag = true for i := 2; i console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"bing-fa-bian-cheng/channel.html":{"url":"bing-fa-bian-cheng/channel.html","title":"Channel","keywords":"","body":" Channel1. Channel 管道1.1. Channel说明1.2. channel类型1.3. 创建channel2. channel操作2.1. 发送（将数据放在管道内）2.2. 接收（从管道内取值）2.3. 关闭管道2.4. 管道阻塞3. 从channel取值3.1. 优雅的从channel取值3.2. Goroutine结合Channel管道4. 单向管道5. Goroutine池 Channel 1. Channel 管道 1.1. Channel说明 共享内存交互数据弊端 单纯地将函数并发执行是没有意义的。函数与函数间需要交换数据才能体现并发执行函数的意义。 虽然可以使用共享内存进行数据交换，但是共享内存在不同的goroutine中容易发生竞态问题。 为了保证数据交换的正确性，必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。 channel好处 Go 语言中的通道（channel）是一种特殊的类型。 通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。 每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。 如果说goroutine是Go程序并发的执行体，channel就是它们之间的连接。 channel是可以让一个goroutine发送特定值到另一个goroutine的通信机制。 1.2. channel类型 channel 是一种类型，一种引用类型 声明管道类型的格式如下: var 变量 chan 元素类型 var ch1 chan int // 声明一个传递整型的管道 var ch2 chan bool // 声明一个传递布尔型的管道 var ch3 chan []int // 声明一个传递 int 切片的管道 1.3. 创建channel 声明的管道后需要使用 make 函数初始化之后才能使用。 创建 channel 的格式如下：make(chan 元素类型, 容量) // 创建一个能存储 10 个 int 类型数据的管道 ch1 := make(chan int, 10) // 创建一个能存储 4 个 bool 类型数据的管道 ch2 := make(chan bool, 4) // 创建一个能存储 3 个[]int 切片类型数据的管道 ch3 := make(chan []int, 3) 2. channel操作 管道有发送（send）、接收(receive）和关闭（close）三种操作。 发送和接收都使用 现在我们先使用以下语句定义一个管道： ch := make(chan int, 3) 2.1. 发送（将数据放在管道内） 将一个值发送到管道中。 ch 2.2. 接收（从管道内取值） 从一个管道中接收值。 x := 2.3. 关闭管道 我们通过调用内置的 close 函数来关闭管道: close(ch) 关于关闭管道需要注意的事情是，只有在通知接收方 goroutine 所有的数据都发送完毕的时候才需要关闭管道。 管道是可以被垃圾回收机制回收的，它和关闭文件是不一样的，在结束操作之后关闭文件是必须要做的，但关闭管道不是必须的。 关闭后的管道有以下特点： 对一个关闭的管道再发送值就会导致 panic。 对一个关闭的管道进行接收会一直获取值直到管道为空 对一个关闭的并且没有值的管道执行接收操作会得到对应类型的零值。 关闭一个已经关闭的管道会导致 panic。 2.4. 管道阻塞 无缓冲的管道 如果创建管道的时候没有指定容量，那么我们可以叫这个管道为无缓冲的管道 无缓冲的管道又称为阻塞的管道。 package main import \"fmt\" func main() { ch := make(chan int) ch 有缓冲的管道 解决上面问题的方法还有一种就是使用有缓冲区的管道。 我们可以在使用 make 函数初始化管道的时候为其指定管道的容量 只要管道的容量大于零，那么该管道就是有缓冲的管道，管道的容量表示管道中能存放元素的数量。 就像你小区的快递柜只有那么个多格子，格子满了就装不下了，就阻塞了，等到别人取走一个快递员就能往里面放一个。 package main import \"fmt\" func main() { ch := make(chan int, 5) ch 3. 从channel取值 3.1. 优雅的从channel取值 当通过通道发送有限的数据时，我们可以通过close函数关闭通道来告知从该通道接收值的goroutine停止等待。 当通道被关闭时，往该通道发送值会引发panic，从该通道里接收的值一直都是类型零值。 那如何判断一个通道是否被关闭了呢？ for range的方式判断通道关闭 package main import \"fmt\" func test1(ch chan int) { for i := 0; i 3.2. Goroutine结合Channel管道 需求 1：定义两个方法，一个方法给管道里面写数据，一个给管道里面读取数据，要求同步进行。 1、开启一个 fn1 的的协程给向管道 inChan 中写入 100 条数据 2、开启一个 fn2 的协程读取 inChan 中写入的数据 3、注意：fn1 和 fn2 同时操作一个管道 4、主线程必须等待操作完成后才可以退出 注：for range的方式判断通道关闭，推出程序 package main import ( \"fmt\" \"sync\" \"time\" ) var wg sync.WaitGroup func main() { intCh := make(chan int, 10) wg.Add(2) go write(intCh) go read(intCh) wg.Wait() fmt.Println(\"读取完毕\") } func write(intCh chan int) { defer wg.Done() for i := 0; i 4. 单向管道 有的时候我们会将管道作为参数在多个任务函数间传递 很多时候我们在不同的任务函数中使用管道都会对其进行限制 比如限制管道在函数中只能发送或只能接收 package main import \"fmt\" func main() { // 1. 在默认情况下下，管道是双向 // var chan1 chan int //可读可写 // 2.声明为只写 var chan2 chan 5. Goroutine池 本质上是生产者消费者模型 在工作中我们通常会使用可以指定启动的goroutine数量–worker pool模式，控制goroutine的数量，防止goroutine泄漏和暴涨。 一个简易的work pool示例代码如下： package main import ( \"fmt\" \"time\" ) func worker(id int, jobs console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"bing-fa-bian-cheng/select.html":{"url":"bing-fa-bian-cheng/select.html","title":"select","keywords":"","body":"1. select 多路复用1.1. select说明1.2. select 的使用1. select 多路复用 1.1. select说明 传统的方法在遍历管道时，如果不关闭会阻塞而导致 deadlock，在实际开发中，可能我们不好确定什么关闭该管道。 这种方式虽然可以实现从多个管道接收值的需求，但是运行性能会差很多。 为了应对这种场景，Go 内置了 select 关键字，可以同时响应多个管道的操作。 select 的使用类似于 switch 语句，它有一系列 case 分支和一个默认的分支。 每个 case 会对应一个管道的通信（接收或发送）过程。 select 会一直等待，直到某个 case 的通信操作完成时，就会执行 case 分支对应的语句。 具体格式如下： select { case 1.2. select 的使用 使用 select 语句能提高代码的可读性。 可处理一个或多个 channel 的发送/接收操作。 如果多个 case 同时满足，select 会随机选择一个。 对于没有 case 的 select{}会一直等待，可用于阻塞 main 函数。 package main import ( \"fmt\" \"time\" ) func main() { // 在某些场景下我们需要同时从多个通道接收数据,这个时候就可以用到golang中给我们提供的select多路复用 //1.定义一个管道 10个数据int intChan := make(chan int, 10) for i := 0; i console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"bing-fa-bian-cheng/bing-fa-an-quan-he-suo.html":{"url":"bing-fa-bian-cheng/bing-fa-an-quan-he-suo.html","title":"并发安全和锁","keywords":"","body":"1. 并发安全与锁1.1. 并发安全1.2. 互斥锁1.3. 读写互斥锁2. sync其他方法2.1. sync.WaitGroup2.2. sync.Once2.3. sync.Map1. 并发安全与锁 1.1. 并发安全 有时候在Go代码中可能会存在多个goroutine同时操作一个资源（临界区），这种情况会发生竞态问题（数据竞态）。 类比现实生活中的例子有十字路口被各个方向的的汽车竞争；还有火车上的卫生间被车厢里的人竞争。 下面开启两个协程，对变量x加一操作，分别加5000次，理想结果是10000，实际三次结果都不相同 package main import ( \"fmt\" \"sync\" ) var x int64 var wg sync.WaitGroup func add() { for i := 0; i 1.2. 互斥锁 互斥锁是一种常用的控制共享资源访问的方法，它能够保证同时只有一个goroutine可以访问共享资源。 Go语言中使用sync包的Mutex类型来实现互斥锁。 使用互斥锁来修复上面代码的问题： package main import ( \"fmt\" \"sync\" ) var x int64 var wg sync.WaitGroup var lock sync.Mutex func add2() { for i := 0; i 1.3. 读写互斥锁 互斥锁是完全互斥的，但是有很多实际的场景下是读多写少的 当我们并发的去读取一个资源不涉及资源修改的时候是没有必要加锁的，这种场景下使用读写锁是更好的一种选择。 读写锁在Go语言中使用sync包中的RWMutex类型。 读写锁分为两种：读锁和写锁 当一个goroutine获取读锁之后，其他的goroutine如果是获取读锁会继续获得锁，如果是获取写锁就会等待； 当一个goroutine获取写锁之后，其他的goroutine无论是获取读锁还是写锁都会等待。 注意：是读写锁非常适合读多写少的场景，如果读和写的操作差别不大，读写锁的优势就发挥不出来。 package main import ( \"fmt\" \"sync\" \"time\" ) var wg sync.WaitGroup var mutex sync.RWMutex //写的方法 func write() { mutex.Lock() fmt.Println(\"执行写操作\") time.Sleep(time.Second * 2) mutex.Unlock() wg.Done() } //读的方法 func read() { mutex.RLock() fmt.Println(\"---执行读操作\") time.Sleep(time.Second * 2) mutex.RUnlock() wg.Done() } func main() { for i := 0; i 2. sync其他方法 2.1. sync.WaitGroup 在代码中生硬的使用time.Sleep肯定是不合适的，Go语言中可以使用sync.WaitGroup来实现并发任务的同步。 sync.WaitGroup有以下几个方法： 方法名 功能 (wg * WaitGroup) Add(delta int) 计数器+delta (wg *WaitGroup) Done() 计数器-1 (wg *WaitGroup) Wait() 阻塞直到计数器变为0 sync.WaitGroup内部维护着一个计数器，计数器的值可以增加和减少。 例如当我们启动了N 个并发任务时，就将计数器值增加N。 每个任务完成时通过调用Done()方法将计数器减1。 通过调用Wait()来等待并发任务执行完，当计数器值为0时，表示所有并发任务已经完成。 我们利用sync.WaitGroup将上面的代码优化一下： package main import ( \"fmt\" \"sync\" ) var wg3 sync.WaitGroup func hello() { defer wg3.Done() fmt.Println(\"Hello Goroutine!\") } func main() { wg3.Add(1) go hello() // 启动另外一个goroutine去执行hello函数 fmt.Println(\"main goroutine done !\") wg3.Wait() } 2.2. sync.Once 在编程的很多场景下我们需要确保某些操作在高并发的场景下只执行一次，例如只加载一次配置文件、只关闭一次通道等。 Go语言中的sync包中提供了一个针对只执行一次场景的解决方案–sync.Once。 sync.Once只有一个Do方法，其签名如下： package main import ( \"fmt\" \"sync\" \"time\" ) var once sync.Once func onces() { fmt.Println(\"onces\") } func onced() { fmt.Println(\"onced\") } func main() { for i, v := range make([]string, 10) { once.Do(onces) fmt.Println(\"count:\", v, \"---\", i) } for i := 0; i 2.3. sync.Map Go语言中内置的map不是并发安全的。请看下面的示例 下面的代码开启少量几个goroutine的时候可能没什么问题 当并发多了之后执行上面的代码就会报fatal error: concurrent map writes错误。 原因： 因为 map 变量为 指针类型变量，并发写时，多个协程同时操作一个内存 类似于多线程操作同一个资源会发生竞争关系，共享资源会遭到破坏 因此golang 出于安全的考虑，抛出致命错误：fatal error: concurrent map writes。 package main import ( \"fmt\" \"strconv\" \"sync\" ) var m = make(map[string]int) func get(key string) int { return m[key] } func set(key string, value int) { m[key] = value } func main() { wg := sync.WaitGroup{} for i := 0; i 像这种场景下就需要为map加锁来保证并发的安全性了，Go语言的sync包中提供了一个开箱即用的并发安全版map–sync.Map。 开箱即用表示不用像内置的map一样使用make函数初始化就能直接使用。 同时sync.Map内置了诸如Store、Load、LoadOrStore、Delete、Range等操作方法。 package main import ( \"fmt\" \"strconv\" \"sync\" ) var wg4 sync.WaitGroup func main() { var m2 = sync.Map{} for i := 0; i console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"bing-fa-bian-cheng/goroutineyuan-li.html":{"url":"bing-fa-bian-cheng/goroutineyuan-li.html","title":"goroutine原理","keywords":"","body":" goroutine原理(Not finishing)1. 设计思路1.1. 设计描述1.2. Pool struct1.3. 初始化 Pool 并启动定期清理过期 worker 任务1.4. 提交任务到 Pool1.5. 获取可用 worker(核心)1.6. 执行任务1.7. worker回收(goroutine 复用)1.8. 动态扩容或者缩小池容量1.9. 定期清理过期 Worker2. pool使用2.1. 公共池2.2. 方法绑定池 goroutine原理(Not finishing) 1. 设计思路 参考博客 goroutine 1.1. 设计描述 启动服务之时先初始化一个 Goroutine Pool 池，这个 Pool 维护了一个类似栈的 LIFO 队列 ，里面存放负责处理任务的 Worker 然后在 client 端提交 task 到 Pool 中之后，在 Pool 内部，接收 task 之后的核心操作是 检查当前 Worker 队列中是否有可用的 Worker，如果有，取出执行当前的 task； 没有可用的 Worker，判断当前在运行的 Worker 是否已超过该 Pool 的容量 每个 Worker 执行完任务之后，放回 Pool 的队列中等待 1.2. Pool struct type sig struct{} type f func() error // pool从客户端获取任务，它限制goroutines总数，并且回收再使用 type Pool struct { capacity int32 // 协程池容量 running int32 // 正在运行的goroutine数量 expiryDuration time.Duration // 为每个worker设置一个过期时间 workers []*Worker // 存放空闲 worker,请求进入 Pool先检查workers若有则取出绑定任务执行 release chan sig // 当关闭该 Pool 支持通知所有 worker 退出运行以防 goroutine 泄露 lock sync.Mutex // 同步操作锁 once sync.Once // 确保 Pool 关闭操作只会执行一次 } 1.3. 初始化 Pool 并启动定期清理过期 worker 任务 // 新建一个线程池实例 func NewPool(size int) (*Pool, error) { return NewTimingPool(size, DefaultCleanIntervalTime) } // 产生一个带有自定义定时器的线程池实例 func NewTimingPool(size, expiry int) (*Pool, error) { if size 1.4. 提交任务到 Pool 第一个 if 判断当前 Pool 是否已被关闭，若是则不再接受新任务，否则获取一个 Pool 中可用的 worker，绑定该 task 执行。 // Submit submit a task to pool func (p *Pool) Submit(task f) error { if len(p.release) > 0 { return ErrPoolClosed } w := p.getWorker() w.task 1.5. 获取可用 worker(核心) p.getWorker() 源码 // 返回一个可用的worker来运行这些任务。 func (p *Pool) getWorker() *Worker { var w *Worker waiting := false // 标志变量，判断当前正在运行的worker数量是否已到达Pool的容量上限 p.lock.Lock() // 加锁，检测队列中是否有可用worker，并进行相应操作 idleWorkers := p.workers n := len(idleWorkers) - 1 if n = p.Cap() } else { // 当前队列有可用worker，从队列尾部取出一个使用 w = idleWorkers[n] idleWorkers[n] = nil p.workers = idleWorkers[:n] } p.lock.Unlock() // 检测完成，解锁 if waiting { // Pool容量已满，新请求等待 for { // 利用锁阻塞等待直到有空闲worker p.lock.Lock() idleWorkers = p.workers l := len(idleWorkers) - 1 if l 1.6. 执行任务 结合前面的 p.Submit(task f) 和 p.getWorker() ，提交任务到 Pool 之后，获取一个可用 worker 每新建一个 worker 实例之时都需要调用 w.run() 启动一个 goroutine 监听 worker 的任务列表 task ，一有任务提交进来就执行； 所以，当调用 worker 的 sendTask(task f) 方法提交任务到 worker 的任务队列之后，马上就可以被接收并执行 当任务执行完之后，会调用 w.pool.putWorker(w *Worker) 方法将这个已经执行完任务的 worker 从当前任务解绑放回 Pool 中，以供下个任务可以使用 至此，一个任务从提交到完成的过程就此结束，Pool 调度将进入下一个循环。 // Worker是运行任务的实际执行者，它启动一个接受任务并执行函数调用的goroutine type Worker struct { pool *Pool // 每个pool对应一个worker task chan f // 任务是一项应该完成的工作 recycleTime time.Time // 当将一个worker放回队列时，recycleTime将被更新。 } // Run启动一个goroutine以重复执行函数调用的过程 func (w *Worker) run() { go func() { // 循环监听任务列表，一旦有任务立马取出运行 for f := range w.task { if f == nil { // 退出goroutine，运行worker数减一 w.pool.decRunning() return } f() // worker回收复用 w.pool.putWorker(w) } }() } 1.7. worker回收(goroutine 复用) // putWorker将一个worker放回空闲池，回收goroutines func (p *Pool) putWorker(worker *Worker) { // 写入回收时间，亦即该worker的最后一次结束运行的时间 worker.recycleTime = time.Now() p.lock.Lock() p.workers = append(p.workers, worker) p.lock.Unlock() } 1.8. 动态扩容或者缩小池容量 // ReSize更改此池的容量 func (p *Pool) ReSize(size int) { if size == p.Cap() { return } atomic.StoreInt32(&p.capacity, int32(size)) diff := p.Running() - size if diff > 0 { for i := 0; i 1.9. 定期清理过期 Worker 定期检查空闲 worker 队列中是否有已过期的 worker 并清理 因为采用了 LIFO 后进先出队列存放空闲 worker，所以该队列默认已经是按照 worker 的最后运行时间由远及近排序 可以方便地按顺序取出空闲队列中的每个 worker 并判断它们的最后运行时间与当前时间之差是否超过设置的过期时长 若是，则清理掉该 goroutine，释放该 worker，并且将剩下的未过期 worker 重新分配到当前 Pool 的空闲 worker 队列中，进一步节省系统资源 // 定期清理过期 Worker func (p *Pool) periodicallyPurge() { heartbeat := time.NewTicker(p.expiryDuration) for range heartbeat.C { currentTime := time.Now() p.lock.Lock() idleWorkers := p.workers if len(idleWorkers) == 0 && p.Running() == 0 && len(p.release) > 0 { p.lock.Unlock() return } n := 0 for i, w := range idleWorkers { if currentTime.Sub(w.recycleTime) = len(idleWorkers) { p.workers = idleWorkers[:0] } else { p.workers = idleWorkers[n:] } p.lock.Unlock() } } 2. pool使用 2.1. 公共池 package main import ( \"fmt\" \"sync\" \"time\" \"github.com/panjf2000/ants/v2\" ) func demoFunc() { time.Sleep(10 * time.Millisecond) fmt.Println(\"Hello World!\") } func main() { // 在retrieveWorker()中可能有一些调用者在等待，因此我们需要唤醒它们来防止那些无限阻塞的调用者 defer ants.Release() var wg sync.WaitGroup syncCalculateSum := func() { demoFunc() wg.Done() } for i := 0; i 2.2. 方法绑定池 package main import ( \"fmt\" \"github.com/panjf2000/ants/v2\" \"sync\" ) func myFunc(i interface{}) { fmt.Printf(\"run with %d\\n\", i) } func main() { defer ants.Release() var wg sync.WaitGroup // 使用池和函数，设置goroutine pool的容量为10，超时时间为1秒。 p, _ := ants.NewPoolWithFunc(10, func(i interface{}) { myFunc(i) wg.Done() }) defer p.Release() // 逐个提交任务 for i := 0; i console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"bing-fa-bian-cheng/goroutinebian-cheng.html":{"url":"bing-fa-bian-cheng/goroutinebian-cheng.html","title":"goroutine编程","keywords":"","body":" goroutine编程1. goroutine池2. 打印奇数偶数2.1. 一个无缓冲管道实现2.2. 两个无缓冲管道实现3. 超时控制3.1. 基础版3.2. time.After控制超时 goroutine编程 1. goroutine池 本质上是生产者消费者模型 在工作中我们通常会使用可以指定启动的goroutine数量–worker pool模式，控制goroutine的数量，防止goroutine泄漏和暴涨。 一个简易的work pool示例代码如下： package main import ( \"fmt\" \"time\" ) func worker(id int, jobs 2. 打印奇数偶数 2.1. 一个无缓冲管道实现 首先我们这里通过make(chan int)，开辟的通道是一种无缓冲通道 所以当对这个缓冲通道写的时候，会一直阻塞等到某个协程对这个缓冲通道读 而这里我讲 ch ，他却是需要等到某个协程读了再能继续运行 package main import ( \"fmt\" \"sync\" ) var wg sync.WaitGroup func printJS(ch chan bool) { defer wg.Done() for i := 1; i 2.2. 两个无缓冲管道实现 package main import ( \"fmt\" \"sync\" ) var ch1 = make(chan bool) var ch2 = make(chan bool) var wg sync.WaitGroup func go1JS() { defer wg.Done() for i := 1; i 3. 超时控制 3.1. 基础版 package main import ( \"fmt\" \"math/rand\" \"time\" ) // 在 main 函数里调用给定的 rpc 方法，并设置超时时间为 10 秒 // 在等待过程中如果超时则取消等待并打印 \"timeout\" ，如果没有超时则打印出 rpc 的返回结果。 // rpc 方法不可以修改 func main() { ch := make(chan bool) var ret int go func() { ret = rpc() = 10 { ch 3.2. time.After控制超时 package main import ( \"fmt\" \"time\" ) func main() { workDoneCh := make(chan bool, 1) go func() { LongTimeWork() //这是我们要控制超时的函数 workDoneCh console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"shu-ju-ku-cao-zuo.html":{"url":"shu-ju-ku-cao-zuo.html","title":"数据库操作","keywords":"","body":" console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"gorm.html":{"url":"gorm.html","title":"GORM","keywords":"","body":" console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"gorm/gormru-men.html":{"url":"gorm/gormru-men.html","title":"GORM入门","keywords":"","body":" GORM入门1. 介绍1.1. 概览1.2. 安装1.3. 快速开始2. 模型定义2.1. 模型定义2.2. 支持的结构标签2.3. 关联的结构标签3. 惯例3.1. gorm.Model3.2. ID 作为主键3.3. 复数表名3.4. 蛇形列名3.5. 时间戳跟踪4. 连接数据库4.1. 连接数据库4.2. MySQL4.3. PostgreSQL4.4. Sqlite34.5. SQL Server GORM入门 1. 介绍 一个神奇的，对开发人员友好的 Golang ORM 库 1.1. 概览 全特性 ORM (几乎包含所有特性) 模型关联 (一对一， 一对多，一对多（反向）， 多对多， 多态关联) 钩子 (Before/After Create/Save/Update/Delete/Find) 预加载 事务 复合主键 SQL 构造器 自动迁移 日志 基于GORM回调编写可扩展插件 全特性测试覆盖 开发者友好 1.2. 安装 go get -u github.com/jinzhu/gorm 1.3. 快速开始 package main import ( \"github.com/jinzhu/gorm\" _ \"github.com/jinzhu/gorm/dialects/sqlite\" ) type Product struct { gorm.Model Code string Price uint } func main() { db, err := gorm.Open(\"sqlite3\", \"sqlite3.db\") if err != nil { panic(\"failed to connect database\") } defer db.Close() //自动检查 Product 结构是否变化，变化则进行迁移 db.AutoMigrate(&Product{}) // 增 db.Create(&Product{ Code: \"ok\", Price: 200, }) // 查 var product Product db.First(&product, 1) // 找到id为1的产品 db.First(&product, \"code = ?\", \"ok\") // 改 db.Model(&product).Update(\"Price\", 2000) // 删 db.Delete(&product) } 增改删(逻辑删除) 2. 模型定义 2.1. 模型定义 模型一般都是普通的 Golang 的结构体，Go的基本数据类型，或者指针。 sql.Scanner 和 driver.Valuer，同时也支持接口。 例子： type User struct { gorm.Model Name string Age sql.NullInt64 Birthday *time.Time Email string `gorm:\"type:varchar(100);unique_index\"` Role string `gorm:\"size:255\"` //设置字段的大小为255个字节 MemberNumber *string `gorm:\"unique;not null\"` // 设置 memberNumber 字段唯一且不为空 Num int `gorm:\"AUTO_INCREMENT\"` // 设置 Num字段自增 Address string `gorm:\"index:addr\"` // 给Address 创建一个名字是 `addr`的索引 IgnoreMe int `gorm:\"-\"` //忽略这个字段 } 2.2. 支持的结构标签 标签是声明模型时可选的标记 标签 说明 Column 指定列的名称 Type 指定列的类型 Size 指定列的大小，默认是 255 PRIMARY_KEY 指定一个列作为主键 UNIQUE 指定一个唯一的列 DEFAULT 指定一个列的默认值 PRECISION 指定列的数据的精度 NOT NULL 指定列的数据不为空 AUTO_INCREMENT 指定一个列的数据是否自增 INDEX 创建带或不带名称的索引，同名创建复合索引 UNIQUE_INDEX 类似 索引，创建一个唯一的索引 EMBEDDED 将 struct 设置为 embedded EMBEDDED_PREFIX 设置嵌入式结构的前缀名称 - 忽略这些字段 2.3. 关联的结构标签 有关详细信息，请查看「关联」部分 标签 说明 MANY2MANY 指定连接表名称 FOREIGNKEY 指定外键 ASSOCIATION_FOREIGNKEY 指定关联外键 POLYMORPHIC 指定多态类型 POLYMORPHIC_VALUE 指定多态的值 JOINTABLE_FOREIGNKEY 指定连接表的外键 ASSOCIATION_JOINTABLE_FOREIGNKEY 指定连接表的关联外键 SAVE_ASSOCIATIONS 是否自动保存关联 ASSOCIATION_AUTOUPDATE 是否自动更新关联 ASSOCIATION_AUTOCREATE 是否自动创建关联 ASSOCIATION_SAVE_REFERENCE 是否引用自动保存的关联 PRELOAD 是否自动预加载关联 3. 惯例 3.1. gorm.Model gorm.Model 是一个包含一些基本字段的结构体, 包含的字段有 ID，CreatedAt， UpdatedAt， DeletedAt。 你可以用它来嵌入到你的模型中，或者也可以用它来建立自己的模型。 // gorm.Model 定义 type Model struct { ID uint `gorm:\"primary_key\"` CreatedAt time.Time UpdatedAt time.Time DeletedAt *time.Time } // 将字段 `ID`, `CreatedAt`, `UpdatedAt`, `DeletedAt` 注入到 `User` 模型中 type User struct { gorm.Model Name string } // 声明 gorm.Model 模型 type User struct { ID int Name string } 3.2. ID 作为主键 GORM 默认使用 ID 作为主键名。 type User struct { ID string // 字段名 `ID` 将被作为默认的主键名 } // 设置字段 `AnimalID` 为默认主键 type Animal struct { AnimalID int64 `gorm:\"primary_key\"` Name string Age int64 } 3.3. 复数表名 表名是结构体名称的复数形式 type User struct {} // 默认的表名是 `users` // 设置 `User` 的表名为 `profiles` func (User) TableName() string { return \"profiles\" } func (u User) TableName() string { if u.Role == \"admin\" { return \"admin_users\" } else { return \"users\" } } // 如果设置禁用表名复数形式属性为 true，`User` 的表名将是 `user` db.SingularTable(true) 指定表名 // 用 `User` 结构体创建 `delete_users` 表 db.Table(\"deleted_users\").CreateTable(&User{}) var deleted_users []User db.Table(\"deleted_users\").Find(&deleted_users) //// SELECT * FROM deleted_users; db.Table(\"deleted_users\").Where(\"name = ?\", \"jinzhu\").Delete() //// DELETE FROM deleted_users WHERE name = 'jinzhu'; 修改默认表名 你可以通过定义 DefaultTableNameHandler 字段来对表名使用任何规则。 gorm.DefaultTableNameHandler = func (db *gorm.DB, defaultTableName string) string { return \"prefix_\" + defaultTableName; } 3.4. 蛇形列名 列名是字段名的蛇形小写形式 type User struct { ID uint // 字段名是 `id` Name string // 字段名是 `name` Birthday time.Time // 字段名是 `birthday` CreatedAt time.Time // 字段名是 `created_at` } // 重写列名 type Animal struct { AnimalId int64 `gorm:\"column:beast_id\"` // 设置列名为 `beast_id` Birthday time.Time `gorm:\"column:day_of_the_beast\"` // 设置列名为 `day_of_the_beast` Age int64 `gorm:\"column:age_of_the_beast\"` // 设置列名为 `age_of_the_beast` } 3.5. 时间戳跟踪 reatedAt 对于有 CreatedAt 字段的模型，它将被设置为首次创建记录的当前时间。 db.Create(&user) // 将设置 `CreatedAt` 为当前时间 // 你可以使用 `Update` 方法来更改默认时间 db.Model(&user).Update(\"CreatedAt\", time.Now()) UpdatedAt 对于有 UpdatedAt 字段的模型，它将被设置为记录更新时的当前时间。 db.Save(&user) // 将设置 `UpdatedAt` 为当前时间 db.Model(&user).Update(\"name\", \"jinzhu\") // 将设置 `UpdatedAt` 为当前时间 DeletedAt 对于有 DeletedAt 字段的模型，当删除它们的实例时，它们并没有被从数据库中删除，只是将 DeletedAt 字段设置为当前时间。参考 Soft Delete 4. 连接数据库 4.1. 连接数据库 为了连接数据库，你首先要导入数据库驱动程序。例如： import _ \"github.com/go-sql-driver/mysql\" GORM 已经包含了一些驱动程序，为了方便的去记住它们的导入路径，你可以像下面这样导入 mysql 驱动程序 import _ \"github.com/jinzhu/gorm/dialects/mysql\" // import _ \"github.com/jinzhu/gorm/dialects/postgres\" // import _ \"github.com/jinzhu/gorm/dialects/sqlite\" // import _ \"github.com/jinzhu/gorm/dialects/mssql\" 4.2. MySQL 注意： 为了正确的处理 time.Time ，你需要包含 parseTime 作为参数。 (More supported parameters) import ( \"github.com/jinzhu/gorm\" _ \"github.com/jinzhu/gorm/dialects/mysql\" ) func main() { db, err := gorm.Open(\"mysql\", \"user:password@/dbname?charset=utf8&parseTime=True&loc=Local\") defer db.Close() } 4.3. PostgreSQL import ( \"github.com/jinzhu/gorm\" _ \"github.com/jinzhu/gorm/dialects/postgres\" ) func main() { db, err := gorm.Open(\"postgres\", \"host=myhost port=myport user=gorm dbname=gorm password=mypassword\") defer db.Close() } 4.4. Sqlite3 import ( \"github.com/jinzhu/gorm\" _ \"github.com/jinzhu/gorm/dialects/sqlite\" ) func main() { db, err := gorm.Open(\"sqlite3\", \"/tmp/gorm.db\") defer db.Close() } 4.5. SQL Server import ( \"github.com/jinzhu/gorm\" _ \"github.com/jinzhu/gorm/dialects/mssql\" ) func main() { db, err := gorm.Open(\"mssql\", \"sqlserver://username:password@localhost:1433?database=dbname\") defer db.Close() } console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"gorm/gormcao-zuo.html":{"url":"gorm/gormcao-zuo.html","title":"GORM操作","keywords":"","body":" GORM操作1. GORM介绍1.1. GORM是什么1.2. GORM功能介绍1.3. 创建一个项目2. GORM基本使用2.1. 安装gorm2.2. 建立数据库链接2.3. 关闭数据库链接2.4. 定义数据库模型2.5. 自动创建表3. GORM增删改查3.1. 基本增删改查3.2. 定义路由 GORM操作 1. GORM介绍 1.1. GORM是什么 GORM 是 golang 的一个 orm 框架，它是一个单独的 ORM 框架。 相比 beego 自带的 orm 框架，语法要更友好一些，关联查询更简单、功能更强大一些。 简单说，ORM 就是通过实例对象的语法，完成关系型数据库的操作的技术 是\"对象-关系 映射\"（Object/Relational Mapping） 的缩写 1.2. GORM功能介绍 Gorm 官方文档 全功能 ORM (无限接近) 关联 (Has One, Has Many, Belongs To, Many To Many, 多态) 钩子 (在创建/保存/更新/删除/查找之前或之后) 预加载 事务 复合主键 SQL 生成器 数据库自动迁移 自定义日志 可扩展性, 可基于 GORM 回调编写插件 所有功能都被测试覆盖 开发者友好 1.3. 创建一个项目 bee new beegogorm go mod init beegogorm go build -mod=mod 2. GORM基本使用 2.1. 安装gorm go get -u github.com/jinzhu/gorm 2.2. 建立数据库链接 models/core.go package models import ( \"github.com/astaxie/beego\" \"github.com/jinzhu/gorm\" _ \"github.com/jinzhu/gorm/dialects/mysql\" ) var DB *gorm.DB var err error func init() { //和数据库建立连接 DB, err = gorm.Open(\"mysql\", \"root:root@/beego_test?charset=utf8&parseTime=True&loc=Local\") if err != nil { beego.Error() } } 2.3. 关闭数据库链接 package main import ( \"beegogorm/models\" _ \"beegogorm/routers\" \"github.com/astaxie/beego\" ) func main() { beego.Run() defer models.DB.Close() //关闭数据库连接 } 2.4. 定义数据库模型 models/user.go package models type User struct { Id int UserName string Age int Email string AddTime int } // TableName 定义结构体操作的数据库表 func (User) TableName() string { return \"user\" } 2.5. 自动创建表 models/core.go 注意：GORM 的AutoMigrate函数，仅支持建表，不支持修改字段和删除字段，避免意外导致丢失数据。 GORM更多用法 func init() { //和数据库建立连接 DB, err = gorm.Open(\"mysql\", \"root:root@/beego_test?charset=utf8&parseTime=True&loc=Local\") if err != nil { beego.Error() } if !DB.HasTable(&User{}) { // 创建表 DB.CreateTable(&User{}) // 根据User结构体建表 DB.Set(\"gorm:table_options\", \"ENGINE=InnoDB\").CreateTable(&User{}) // 设置表结构的存储引擎为InnoDB } } 3. GORM增删改查 3.1. 基本增删改查 controllers/user.go package controllers import ( \"beegogorm/models\" \"github.com/astaxie/beego\" \"time\" ) type UserController struct { beego.Controller } // UserAdd 增加用户 func (c *UserController) UserAdd() { user := models.User{ UserName: \"zs\", Age: 22, Email: \"email@email\", AddTime: int(time.Now().Unix()), } models.DB.Create(&user) c.Ctx.WriteString(\"添加数据成功\") } // UserDelete 删除用户 func (c *UserController) UserDelete() { user := models.User{Id: 1} models.DB.Delete(&user) c.Ctx.WriteString(\"删除成功\") } // UserUpdate 更新用户 func (c *UserController) UserUpdate() { // 查找id=9的数据 user := models.User{Id: 9} // models.DB.First(&user) // 执行修改 user.UserName = \"秀儿\" models.DB.Save(&user) c.Ctx.WriteString(\"修改成功\") } // GetUser 获取用户 func (c *UserController) GetUser() { // 查询单个 //user := models.User{UserName: \"秀儿\"} //models.DB.Find(&user) // 查询所有 var user []models.User models.DB.Find(&user) c.Data[\"json\"] = user c.ServeJSON() } 3.2. 定义路由 package routers import ( \"beegogorm/controllers\" \"github.com/astaxie/beego\" ) func init() { beego.Router(\"/user/add/\", &controllers.UserController{},\"get:UserAdd\") beego.Router(\"/user/delete/\", &controllers.UserController{},\"get:UserDelete\") beego.Router(\"/user/edit/\", &controllers.UserController{},\"get:UserEdit\") beego.Router(\"/user/select/\", &controllers.UserController{},\"get:UserSelect\") } 添加 删除修改查询 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"gorm/gormji-ben-cha-xun.html":{"url":"gorm/gormji-ben-cha-xun.html","title":"GORM基本查询","keywords":"","body":" GORM查询1. GORM基本查询1.1. 基本查询1.2. 用主键检索2. 条件查询2.1. String 条件2.2. Struch & Map 查询2.3. Not条件2.4. Or条件3. 高级查询3.1. 选择特定字段3.2. Order3.3. Limit & Offset3.4. Group & Having3.5. Distinct4. 连表查询4.1. Joins4.2. Joins 预加载 GORM查询 1. GORM基本查询 官方文档 1.1. 基本查询 func (c *UserController) UserSelect() { //1、查询id=3的用户 user := models.User{Id: 3} models.DB.Find(&user) //2、查询所有数据 user := []models.User{} result := models.DB.Find(&user) //5 （统计有几条数据） fmt.Println(result.RowsAffected ) //3、查询第一条数据 users := models.User{} models.DB.First(&users) c.Data[\"json\"] = user c.ServeJSON() } 1.2. 用主键检索 func (c *UserController) UserSelect() { user := []models.User{} //1) SELECT * FROM users WHERE id = 2; models.DB.First(&user, 2) //2) SELECT * FROM users WHERE id IN (1,2,3); models.DB.Find(&user, []int{1,2,3}) c.Data[\"json\"] = user c.ServeJSON() } 2. 条件查询 2.1. String 条件 func (c *UserController) UserSelect() { user := []models.User{} //1) Get first matched record models.DB.Where(\"username = ?\", \"zhangsan\").First(&user) // SELECT * FROM users WHERE name = 'jinzhu' limit 1; //2) Get all matched records models.DB.Where(\"username = ?\", \"zhangsan\").Find(&user) // SELECT * FROM users WHERE name = 'jinzhu'; //3） <> models.DB.Where(\"username <> ?\", \"jinzhu\").Find(&user) //SELECT * FROM users WHERE name <> 'jinzhu'; //4） IN models.DB.Where(\"username IN (?)\", []string{\"jinzhu\", \"jinzhu 2\"}).Find(&user) //5） SELECT * FROM users WHERE name in ('jinzhu','jinzhu 2'); //6） LIKE models.DB.Where(\"username LIKE ?\", \"%jin%\").Find(&user) // SELECT * FROM users WHERE name LIKE '%jin%'; //7） AND models.DB.Where(\"username = ? AND age >= ?\", \"jinzhu\", \"22\").Find(&user) // SELECT * FROM users WHERE name = 'jinzhu' AND age >= 22; //8） Time models.DB.Where(\"updated_at > ?\", lastWeek).Find(&user) // SELECT * FROM users WHERE updated_at > '2000-01-01 00:00:00'; //9） BETWEEN models.DB.Where(\"created_at BETWEEN ? AND ?\", lastWeek, today).Find(&user) // SELECT * FROM users WHERE created_at BETWEEN '2000-01-01 00:00:00' AND '2000-01-08 00:00:00'; c.Data[\"json\"] = user c.ServeJSON() } 2.2. Struch & Map 查询 func (c *UserController) UserSelect() { user := []models.User{} // 1）Struct models.DB.Where(&models.User{Username: \"zhangsan\", Age: 26}).First(&user) // SELECT * FROM users WHERE name = \"jinzhu\" AND age = 20 LIMIT 1; // 2）Map models.DB.Where(map[string]interface{}{\"username\": \"zhangsan\", \"age\": 26}).Find(&user) // SELECT * FROM users WHERE name = \"jinzhu\" AND age = 20; // 3）主键的切片 models.DB.Where([]int64{1, 2, 3}).Find(&user) //SELECT * FROM users WHERE id IN (20, 21, 22); c.Data[\"json\"] = user c.ServeJSON() } 定义的结构体 type User struct { Id int Username string Age int Email string AddTime int } 2.3. Not条件 func (c *UserController) UserSelect() { user := []models.User{} //1）不等于 models.DB.Not(\"zhangsan\", \"lisi\").First(&user) // SELECT * FROM users WHERE name <> \"jinzhu\" LIMIT 1; //2） Not In models.DB.Not(\"username\", []string{\"zhangsan\", \"lisi\"}).Find(&user) //// SELECT * FROM users WHERE name NOT IN (\"jinzhu\", \"jinzhu 2\"); //3） Not In slice of primary keys models.DB.Not([]int64{1,2,3}).First(&user) // SELECT * FROM users WHERE id NOT IN (1,2,3); //4） Plain SQL models.DB.Not(\"name = ?\", \"jinzhu\").First(&user) // SELECT * FROM users WHERE NOT(name = \"jinzhu\"); //5） Struct models.DB.Not(models.User{Username: \"jinzhu\"}).First(&user) // SELECT * FROM users WHERE name <> \"jinzhu\"; c.Data[\"json\"] = user c.ServeJSON() } 2.4. Or条件 func (c *UserController) UserSelect() { user := []models.User{} //1） models.DB.Where(\"role = ?\", \"admin\").Or(\"role = ?\", \"super_admin\").Find(&user) // SELECT * FROM users WHERE role = 'admin' OR role = 'super_admin'; //2） Struct models.DB.Where(\"name = 'jinzhu'\").Or(models.User{Username: \"jinzhu 2\"}).Find(&user) // SELECT * FROM users WHERE name = 'jinzhu' OR name = 'jinzhu 2'; //3） Map models.DB.Where(\"name = 'jinzhu'\").Or(map[string]interface{}{\"name\": \"jinzhu 2\"}).Find(&user) // SELECT * FROM users WHERE name = 'jinzhu' OR name = 'jinzhu 2'; c.Data[\"json\"] = user c.ServeJSON() } 3. 高级查询 3.1. 选择特定字段 选择您想从数据库中检索的字段，默认情况下会选择全部字段 db.Select(\"name\", \"age\").Find(&users) // SELECT name, age FROM users; db.Select([]string{\"name\", \"age\"}).Find(&users) // SELECT name, age FROM users; db.Table(\"users\").Select(\"COALESCE(age,?)\", 42).Rows() // SELECT COALESCE(age,'42') FROM users; 3.2. Order 指定从数据库检索记录时的排序方式 db.Order(\"age desc, name\").Find(&users) // SELECT * FROM users ORDER BY age desc, name; // 多个 order db.Order(\"age desc\").Order(\"name\").Find(&users) // SELECT * FROM users ORDER BY age desc, name; db.Clauses(clause.OrderBy{ Expression: clause.Expr{SQL: \"FIELD(id,?)\", Vars: []interface{}{[]int{1, 2, 3}}, WithoutParentheses: true}, }).Find(&User{}) // SELECT * FROM users ORDER BY FIELD(id,1,2,3) 3.3. Limit & Offset db.Limit(3).Find(&users) // SELECT * FROM users LIMIT 3; // 通过 -1 消除 Limit 条件 db.Limit(10).Find(&users1).Limit(-1).Find(&users2) // SELECT * FROM users LIMIT 10; (users1) // SELECT * FROM users; (users2) db.Offset(3).Find(&users) // SELECT * FROM users OFFSET 3; db.Limit(10).Offset(5).Find(&users) // SELECT * FROM users OFFSET 5 LIMIT 10; // 通过 -1 消除 Offset 条件 db.Offset(10).Find(&users1).Offset(-1).Find(&users2) // SELECT * FROM users OFFSET 10; (users1) // SELECT * FROM users; (users2) 3.4. Group & Having type result struct { Date time.Time Total int } db.Model(&User{}).Select(\"name, sum(age) as total\").Where(\"name LIKE ?\", \"group%\").Group(\"name\").First(&result) // SELECT name, sum(age) as total FROM `users` WHERE name LIKE \"group%\" GROUP BY `name` db.Model(&User{}).Select(\"name, sum(age) as total\").Group(\"name\").Having(\"name = ?\", \"group\").Find(&result) // SELECT name, sum(age) as total FROM `users` GROUP BY `name` HAVING name = \"group\" rows, err := db.Table(\"orders\").Select(\"date(created_at) as date, sum(amount) as total\").Group(\"date(created_at)\").Rows() for rows.Next() { ... } rows, err := db.Table(\"orders\").Select(\"date(created_at) as date, sum(amount) as total\").Group(\"date(created_at)\").Having(\"sum(amount) > ?\", 100).Rows() for rows.Next() { ... } type Result struct { Date time.Time Total int64 } db.Table(\"orders\").Select(\"date(created_at) as date, sum(amount) as total\").Group(\"date(created_at)\").Having(\"sum(amount) > ?\", 100).Scan(&results) 3.5. Distinct db.Distinct(\"name\", \"age\").Order(\"name, age desc\").Find(&results) 4. 连表查询 4.1. Joins type result struct { Name string Email string } db.Model(&User{}).Select(\"users.name, emails.email\").Joins(\"left join emails on emails.user_id = users.id\").Scan(&result{}) // SELECT users.name, emails.email FROM `users` left join emails on emails.user_id = users.id rows, err := db.Table(\"users\").Select(\"users.name, emails.email\").Joins(\"left join emails on emails.user_id = users.id\").Rows() for rows.Next() { ... } db.Table(\"users\").Select(\"users.name, emails.email\").Joins(\"left join emails on emails.user_id = users.id\").Scan(&results) // 带参数的多表连接 db.Joins(\"JOIN emails ON emails.user_id = users.id AND emails.email = ?\", \"jinzhu@example.org\").Joins(\"JOIN credit_cards ON credit_cards.user_id = users.id\").Where(\"credit_cards.number = ?\", \"411111111111\").Find(&user) 4.2. Joins 预加载 您可以使用 Joins 实现单条 SQL 预加载关联记录，例如： db.Joins(\"Company\").Find(&users) // SELECT `users`.`id`,`users`.`name`,`users`.`age`,`Company`.`id` AS `Company__id`,`Company`.`name` AS `Company__name` FROM `users` LEFT JOIN `companies` AS `Company` ON `users`.`company_id` = `Company`.`id`; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"}}