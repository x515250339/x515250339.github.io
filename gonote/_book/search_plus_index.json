{"qian-yan.html":{"url":"qian-yan.html","title":"前言","keywords":"","body":"go基础语法-快速入门前言 go基础语法-快速入门 https://github1s.com/515250339/goland/blob/HEAD/00基础语法/ 前言 “Go是一个开源的编程语言，它很容易用于构建简单、可靠和高效的软件。”（摘自Go语言官方网站：http://golang.org） Go语言由来自Google公司的Robert Griesemer，Rob Pike和Ken Thompson三位大牛于2007年9月开始设计和实现，然后于2009年的11月对外正式发布（译注：关于Go语言的创世纪过程请参考http://talks.golang.org/2015/how-go-was-made.slide）。语言及其配套工具的设计目标是具有表达力，高效的编译和执行效率，有效地编写高效和健壮的程序。 Go语言有着和C语言类似的语法外表，和C语言一样是专业程序员的必备工具，可以用最小的代价获得最大的战果。 但是它不仅仅是一个更新的C语言。它还从其他语言借鉴了很多好的想法，同时避免引入过度的复杂性。 Go语言中和并发编程相关的特性是全新的也是有效的，同时对数据抽象和面向对象编程的支持也很灵活。 Go语言同时还集成了自动垃圾收集技术用于更好地管理内存。 Go语言尤其适合编写网络服务相关基础设施，同时也适合开发一些工具软件和系统软件。 但是Go语言确实是一个通用的编程语言，它也可以用在图形图像驱动编程、移动应用程序开发 和机器学习等诸多领域。目前Go语言已经成为受欢迎的作为无类型的脚本语言的替代者： 因为Go编写的程序通常比脚本语言运行的更快也更安全，而且很少会发生意外的类型错误。 Go语言还是一个开源的项目，可以免费获取编译器、库、配套工具的源代码。 Go语言的贡献者来自一个活跃的全球社区。Go语言可以运行在类UNIX系统—— 比如Linux、FreeBSD、OpenBSD、Mac OSX——和Plan9系统和Microsoft Windows操作系统之上。 Go语言编写的程序无需修改就可以运行在上面这些环境。 本书是为了帮助你开始以有效的方式使用Go语言，充分利用语言本身的特性和自带的标准库去编写清晰地道的Go程序。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"qian-yan/goyu-yan-qi-yuan.html":{"url":"qian-yan/goyu-yan-qi-yuan.html","title":"Go语言起源","keywords":"","body":"Go语言起源 Go语言起源 编程语言的演化跟生物物种的演化类似，一个成功的编程语言的后代一般都会继承它们祖先的优点；当然有时多种语言杂合也可能会产生令人惊讶的特性；还有一些激进的新特性可能并没有先例。通过观察这些影响，我们可以学到为什么一门语言是这样子的，它已经适应了怎样的环境。 下图展示了有哪些早期的编程语言对Go语言的设计产生了重要影响。 Go语言有时候被描述为“C类似语言”，或者是“21世纪的C语言”。Go从C语言继承了相似的表达式语法、控制流结构、基础数据类型、调用参数传值、指针等很多思想，还有C语言一直所看中的编译后机器码的运行效率以及和现有操作系统的无缝适配。 但是在Go语言的家族树中还有其它的祖先。其中一个有影响力的分支来自Niklaus Wirth所设计的Pascal语言。然后Modula-2语言激发了包的概念。然后Oberon语言摒弃了模块接口文件和模块实现文件之间的区别。第二代的Oberon-2语言直接影响了包的导入和声明的语法，还有Oberon语言的面向对象特性所提供的方法的声明语法等。 Go语言的另一支祖先，带来了Go语言区别其他语言的重要特性，灵感来自于贝尔实验室的Tony Hoare于1978年发表的鲜为外界所知的关于并发研究的基础文献顺序通信进程（communicating sequential processes，缩写为CSP。在CSP中，程序是一组中间没有共享状态的平行运行的处理过程，它们之间使用管道进行通信和控制同步。不过Tony Hoare的CSP只是一个用于描述并发性基本概念的描述语言，并不是一个可以编写可执行程序的通用编程语言。 接下来，Rob Pike和其他人开始不断尝试将CSP引入实际的编程语言中。他们第一次尝试引入CSP特性的编程语言叫Squeak（老鼠间交流的语言），是一个提供鼠标和键盘事件处理的编程语言，它的管道是静态创建的。然后是改进版的Newsqueak语言，提供了类似C语言语句和表达式的语法和类似Pascal语言的推导语法。Newsqueak是一个带垃圾回收的纯函数式语言，它再次针对键盘、鼠标和窗口事件管理。但是在Newsqueak语言中管道是动态创建的，属于第一类值，可以保存到变量中。 在Plan9操作系统中，这些优秀的想法被吸收到了一个叫Alef的编程语言中。Alef试图将Newsqueak语言改造为系统编程语言，但是因为缺少垃圾回收机制而导致并发编程很痛苦。（译注：在Alef之后还有一个叫Limbo的编程语言，Go语言从其中借鉴了很多特性。 具体请参考Pike的讲稿：http://talks.golang.org/2012/concurrency.slide#9） Go语言的其他的一些特性零散地来自于其他一些编程语言；比如iota语法是从APL语言借鉴，词法作用域与嵌套函数来自于Scheme语言（和其他很多语言）。当然，我们也可以从Go中发现很多创新的设计。比如Go语言的切片为动态数组提供了有效的随机存取的性能，这可能会让人联想到链表的底层的共享机制。还有Go语言新发明的defer语句。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"qian-yan/goyu-yan-xiang-mu.html":{"url":"qian-yan/goyu-yan-xiang-mu.html","title":"Go语言项目","keywords":"","body":"Go语言项目 Go语言项目 所有的编程语言都反映了语言设计者对编程哲学的反思，通常包括之前的语言所暴露的一些不足地方的改进。Go项目是在Google公司维护超级复杂的几个软件系统遇到的一些问题的反思（但是这类问题绝不是Google公司所特有的）。 正如Rob Pike所说，“软件的复杂性是乘法级相关的”，通过增加一个部分的复杂性来修复问题通常将慢慢地增加其他部分的复杂性。通过增加功能、选项和配置是修复问题的最快的途径，但是这很容易让人忘记简洁的内涵，即从长远来看，简洁依然是好软件的关键因素。 简洁的设计需要在工作开始的时候舍弃不必要的想法，并且在软件的生命周期内严格区别好的改变和坏的改变。通过足够的努力，一个好的改变可以在不破坏原有完整概念的前提下保持自适应，正如Fred Brooks所说的“概念完整性”；而一个坏的改变则不能达到这个效果，它们仅仅是通过肤浅的和简单的妥协来破坏原有设计的一致性。只有通过简洁的设计，才能让一个系统保持稳定、安全和持续的进化。 Go项目包括编程语言本身，附带了相关的工具和标准库，最后但并非代表不重要的是，关于简洁编程哲学的宣言。就事后诸葛的角度来看，Go语言的这些地方都做的还不错：拥有自动垃圾回收、一个包系统、函数作为一等公民、词法作用域、系统调用接口、只读的UTF8字符串等。但是Go语言本身只有很少的特性，也不太可能添加太多的特性。例如，它没有隐式的数值转换，没有构造函数和析构函数，没有运算符重载，没有默认参数，也没有继承，没有泛型，没有异常，没有宏，没有函数修饰，更没有线程局部存储。但是，语言本身是成熟和稳定的，而且承诺保证向后兼容：用之前的Go语言编写程序可以用新版本的Go语言编译器和标准库直接构建而不需要修改代码。 Go语言有足够的类型系统以避免动态语言中那些粗心的类型错误，但是，Go语言的类型系统相比传统的强类型语言又要简洁很多。虽然，有时候这会导致一个“无类型”的抽象类型概念，但是Go语言程序员并不需要像C++或Haskell程序员那样纠结于具体类型的安全属性。在实践中，Go语言简洁的类型系统给程序员带来了更多的安全性和更好的运行时性能。 Go语言鼓励当代计算机系统设计的原则，特别是局部的重要性。它的内置数据类型和大多数的准库数据结构都经过精心设计而避免显式的初始化或隐式的构造函数，因为很少的内存分配和内存初始化代码被隐藏在库代码中了。Go语言的聚合类型（结构体和数组）可以直接操作它们的元素，只需要更少的存储空间、更少的内存写操作，而且指针操作比其他间接操作的语言也更有效率。由于现代计算机是一个并行的机器，Go语言提供了基于CSP的并发特性支持。Go语言的动态栈使得轻量级线程goroutine的初始栈可以很小，因此，创建一个goroutine的代价很小，创建百万级的goroutine完全是可行的。 Go语言的标准库（通常被称为语言自带的电池），提供了清晰的构建模块和公共接口，包含I/O操作、文本处理、图像、密码学、网络和分布式应用程序等，并支持许多标准化的文件格式和编解码协议。库和工具使用了大量的约定来减少额外的配置和解释，从而最终简化程序的逻辑，而且，每个Go程序结构都是如此的相似，因此，Go程序也很容易学习。使用Go语言自带工具构建Go语言项目只需要使用文件名和标识符名称，一个偶尔的特殊注释来确定所有的库、可执行文件、测试、基准测试、例子、以及特定于平台的变量、项目的文档等；Go语言源代码本身就包含了构建规范。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"goji-chu-zhi-shi.html":{"url":"goji-chu-zhi-shi.html","title":"GO基础知识","keywords":"","body":"安装go安装go go安装文档 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"goji-chu-zhi-shi/gogai-shu.html":{"url":"goji-chu-zhi-shi/gogai-shu.html","title":"go概述","keywords":"","body":"Go 语言的起源，发展与普及语言的主要特性与发展的环境和影响因素Go 语言的起源，发展与普及 Go 语言起源 2007 年，并于 2009 年正式对外发布。它从 2009 年 9 月 21 日开始作为谷歌公司 20% 兼职项目，即相关员工利用 20% 的空余时间来参与 Go 语言的研发工作。该项目的三位领导者均是著名的 IT 工程师：Robert Griesemer，参与开发 Java HotSpot 虚拟机；Rob Pike，Go 语言项目总负责人，贝尔实验室 Unix 团队成员，参与的项目包括 Plan 9，Inferno 操作系统和 Limbo 编程语言；Ken Thompson，贝尔实验室 Unix 团队成员，C 语言、Unix 和 Plan 9 的创始人之一，与 Rob Pike 共同开发了 UTF-8 字符集规范。自 2008 年 1 月起，Ken Thompson 就开始研发一款以 C 语言为目标结果的编译器来拓展 Go 语言的设计思想。 这是一个由计算机领域 “发明之父” 所组成的黄金团队，他们对系统编程语言，操作系统和并行都有着非常深刻的见解 在 2008 年年中，Go 语言的设计工作接近尾声，一些员工开始以全职工作状态投入到这个项目的编译器和运行实现上。Ian Lance Taylor 也加入到了开发团队中，并于 2008 年 5 月创建了一个 gcc 前端。 Russ Cox 加入开发团队后着手语言和类库方面的开发，也就是 Go 语言的标准包。在 2009 年 10 月 30 日，Rob Pike 以 Google Techtalk 的形式第一次向人们宣告了 Go 语言的存在。 直到 2009 年 11 月 10 日，开发团队将 Go 语言项目以 BSD-style 授权（完全开源）正式公布了 Linux 和 Mac OS X 平台上的版本。Hector Chu 于同年 11 月 22 日公布了 Windows 版本。 作为一个开源项目，Go 语言借助开源社区的有生力量达到快速地发展，并吸引更多的开发者来使用并改善它。自该开源项目发布以来，超过 200 名非谷歌员工的贡献者对 Go 语言核心部分提交了超过 1000 个修改建议。在过去的 18 个月里，又有 150 开发者贡献了新的核心代码。这俨然形成了世界上最大的开源团队，并使该项目跻身 Ohloh 前 2% 的行列。大约在 2011 年 4 月 10 日，谷歌开始抽调员工进入全职开发 Go 语言项目。开源化的语言显然能够让更多的开发者参与其中并加速它的发展速度。Andrew Gerrand 在 2010 年加入到开发团队中成为共同开发者与支持者。 在 Go 语言在 2010 年 1 月 8 日被 Tiobe（闻名于它的编程语言流行程度排名）宣布为 “2009 年年度语言” 后，引起各界很大的反响。目前 Go 语言在这项排名中的最高记录是在 2017 年 1 月创下的第13名，流行程度 2.325%。 时间轴： 2007 年 9 月 21 日：雏形设计 2009 年 11 月 10日：首次公开发布 2010 年 1 月 8 日：当选 2009 年年度语言 2010 年 5 月：谷歌投入使用 2011 年 5 月 5 日：Google App Engine 支持 Go 语言 从 2010 年 5 月起，谷歌开始将 Go 语言投入到后端基础设施的实际开发中，例如开发用于管理后端复杂环境的项目。有句话叫 “吃你自己的狗食”，这也体现了谷歌确实想要投资这门语言，并认为它是有生产价值的。 Go 语言的官方网站是 golang.org，这个站点采用 Python 作为前端，并且使用 Go 语言自带的工具 godoc 运行在 Google App Engine 上来作为 Web 服务器提供文本内容。在官网的首页有一个功能叫做 Go Playground，是一个 Go 代码的简单编辑器的沙盒，它可以在没有安装 Go 语言的情况下在你的浏览器中编译并运行 Go，它提供了一些示例，其中包括国际惯例 “Hello, World!”。 语言的主要特性与发展的环境和影响因素 影响 Go 语言发展的早期编程语言 正如 “21 世纪的 C 语言” 这句话所说，Go 语言并不是凭空而造的，而是和 C++、Java 和 C# 一样属于 C 系。不仅如此，设计者们还汲取了其它编程语言的精粹部分融入到 Go 语言当中。 在声明和包的设计方面，Go 语言受到 Pascal、Modula 和 Oberon 系语言的影响；在并发原理的设计上，Go 语言从同样受到 Tony Hoare 的 CSP（通信序列进程 Communicating Squential Processes）理论影响的 Limbo 和 Newsqueak 的实践中借鉴了一些经验，并使用了和 Erlang 类似的机制。 这是一门完全开源的编程语言，因为它使用 BSD 授权许可，所以任何人都可以进行商业软件的开发而不需要支付任何费用。 尽管为了能够让目前主流的开发者们能够对 Go 语言中的类 C 语言的语法感到非常亲切而易于转型，但是它在极大程度上简化了这些语法，使得它们比 C/C++ 的语法更加简洁和干净。同时，Go 语言也拥有一些动态语言的特性，这使得使用 Python 和 Ruby 的开发者们在使用 Go 语言的时候感觉非常容易上手。 为什么要创造一门编程语言 C/C++ 的发展速度无法跟上计算机发展的脚步，十多年来也没有出现一门与时代相符的主流系统编程语言，因此人们需要一门新的系统编程语言来弥补这个空缺，尤其是在计算机信息时代。 相比计算机性能的提升，软件开发领域不被认为发展得足够快或者比硬件发展得更加成功（有许多项目均以失败告终），同时应用程序的体积始终在不断地扩大，这就迫切地需要一门具备更高层次概念的低级语言来突破现状。 在 Go 语言出现之前，开发者们总是面临非常艰难的抉择，究竟是使用执行速度快但是编译速度并不理想的语言（如：C++），还是使用编译速度较快但执行效率不佳的语言（如：.NET、Java），或者说开发难度较低但执行速度一般的动态语言呢？显然，Go 语言在这 3 个条件之间做到了最佳的平衡：快速编译，高效执行，易于开发。 Go 语言的发展目标 Go 语言的主要目标是将静态语言的安全性和高效性与动态语言的易开发性进行有机结合，达到完美平衡，从而使编程变得更加有乐趣，而不是在艰难抉择中痛苦前行。 因此，Go 语言是一门类型安全和内存安全的编程语言。虽然 Go 语言中仍有指针的存在，但并不允许进行指针运算。 Go 语言的另一个目标是对于网络通信、并发和并行编程的极佳支持，从而更好地利用大量的分布式和多核的计算机，这一点对于谷歌内部的使用来说就非常重要了。设计者通过 goroutine 这种轻量级线程的概念来实现这个目标，然后通过 channel 来实现各个 goroutine 之间的通信。他们实现了分段栈增长和 goroutine 在线程基础上多路复用技术的自动化。 这个特性显然是 Go 语言最强有力的部分，不仅支持了日益重要的多核与多处理器计算机，也弥补了现存编程语言在这方面所存在的不足。 Go 语言中另一个非常重要的特性就是它的构建速度（编译和链接到机器代码的速度），一般情况下构建一个程序的时间只需要数百毫秒到几秒。作为大量使用 C++ 来构建基础设施的谷歌来说，无疑从根本上摆脱了 C++ 在构建速度上非常不理想的噩梦。这不仅极大地提升了开发者的生产力，同时也使得软件开发过程中的代码测试环节更加紧凑，而不必浪费大量的时间在等待程序的构建上。 依赖管理是现今软件开发的一个重要组成部分，但是 C 语言中“头文件”的概念却导致越来越多因为依赖关系而使得构建一个大型的项目需要长达几个小时的时间。人们越来越需要一门具有严格的、简洁的依赖关系分析系统从而能够快速编译的编程语言。这正是 Go 语言采用包模型的根本原因，这个模型通过严格的依赖关系检查机制来加快程序构建的速度，提供了非常好的可量测性。 整个 Go 语言标准库的编译时间一般都在 20 秒以内，其它的常规项目也只需要半秒钟的时间来完成编译工作。这种闪电般的编译速度甚至比编译 C 语言或者 Fortran 更加快，使得编译这一环节不再成为在软件开发中困扰开发人员的问题。在这之前，动态语言将快速编译作为自身的一大亮点，像 C++ 那样的静态语言一般都有非常漫长的编译和链接工作。而同样作为静态语言的 Go 语言，通过自身优良的构建机制，成功地去除了这个弊端，使得程序的构建过程变得微不足道，拥有了像脚本语言和动态语言那样的高效开发的能力。 另外，Go 语言在执行速度方面也可以与 C/C++ 相提并论。 由于内存问题（通常称为内存泄漏）长期以来一直伴随着 C++ 的开发者们，Go 语言的设计者们认为内存管理不应该是开发人员所需要考虑的问题。因此尽管 Go 语言像其它静态语言一样执行本地代码，但它依旧运行在某种意义上的虚拟机，以此来实现高效快速的垃圾回收（使用了一个简单的标记-清除算法）。 尽管垃圾回收并不容易实现，但考虑这将是未来并发应用程序发展的一个重要组成部分，Go 语言的设计者们还是完成了这项艰难的任务。 Go 语言还能够在运行时进行反射相关的操作。 使用 go install 能够很轻松地对第三方包进行部署。 此外，Go 语言还支持调用由 C 语言编写的海量库文件，从而能够将过去开发的软件进行快速迁移。 指导设计原则 Go语言通过减少关键字的数量（25 个）来简化编码过程中的混乱和复杂度。干净、整齐和简洁的语法也能够提高程序的编译速度，因为这些关键字在编译过程中少到甚至不需要符号表来协助解析。 这些方面的工作都是为了减少编码的工作量，甚至可以与 Java 的简化程度相比较。 Go 语言有一种极简抽象艺术家的感觉，因为它只提供了一到两种方法来解决某个问题，这使得开发者们的代码都非常容易阅读和理解。众所周知，代码的可读性是软件工程里最重要的一部分。代码是写给人看的，不是写给机器看的。 这些设计理念没有建立其它概念之上，所以并不会因为牵扯到一些概念而将某个概念复杂化，他们之间是相互独立的。 Go 语言有一套完整的编码规范，不像 Ruby 那样通过实现过程来定义编码规范。作为一门具有明确编码规范的语言，它要求可以采用不同的编译器如 gc 和 gccgo进行编译工作，这对语言本身拥有更好的编码规范起到很大帮助。LALR是 Go 语言的语法标准，这种语法标准在编译时不需要符号表来协助解析。 语言的特性 Go 语言从本质上（程序和结构方面）来实现并发编程。因为 Go 语言没有类和继承的概念，所以它和 Java 或 C++ 看起来并不相同。但是它通过接口（interface）的概念来实现多态性。Go 语言有一个清晰易懂的轻量级类型系统，在类型之间也没有层级之说。因此可以说这是一门混合型的语言。 在传统的面向对象语言中，使用面向对象编程技术显得非常臃肿，它们总是通过复杂的模式来构建庞大的类型层级，这违背了编程语言应该提升生产力的宗旨。 函数是 Go 语言中的基本构件，它们的使用方法非常灵活。在第六章，我们会看到 Go 语言在函数式编程方面的基本概念。 Go 语言使用静态类型，所以它是类型安全的一门语言，加上通过构建到本地代码，程序的执行速度也非常快。 作为强类型语言，隐式的类型转换是不被允许的，记住一条原则：让所有的东西都是显式的。 Go 语言其实也有一些动态语言的特性（通过关键字 var），所以它对那些逃离 Java 和 .Net 世界而使用 Python、Ruby、PHP 和 JavaScript 的开发者们也具有很大的吸引力。 Go 语言支持交叉编译，比如说你可以在运行 Linux 系统的计算机上开发运行 Windows 下运行的应用程序。这是第一门完全支持 UTF-8 的编程语言，这不仅体现在它可以处理使用 UTF-8 编码的字符串，就连它的源码文件格式都是使用的 UTF-8 编码。Go 语言做到了真正的国际化！ 语言的用途 Go 语言被设计成一门应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言。对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。它提供了海量并行的支持，这对于游戏服务端的开发而言是再好不过了。 Go 语言一个非常好的目标就是实现所谓的复杂事件处理（CEP），这项技术要求海量并行支持，高度的抽象化和高性能。当我们进入到物联网时代，CEP 必然会成为人们关注的焦点。 但是 Go 语言同时也是一门可以用于实现一般目标的语言，例如对于文本的处理，前端展现，甚至像使用脚本一样使用它。 值得注意的是，因为垃圾回收和自动内存分配的原因，Go 语言不适合用来开发对实时性要求很高的软件。 越来越多的谷歌内部的大型分布式应用程序都开始使用 Go 语言来开发，例如谷歌地球的一部分代码就是由 Go 语言完成的。 如果你想知道一些其它组织使用Go语言开发的实际应用项目，你可以到 使用 Go 的组织页面进行查看。出于隐私保护的考虑，许多公司的项目都没有展示在这个页面。我们将会在第 21 章讨论到一个使用 Go 语言开发的大型存储区域网络（SAN）案例。 在 Chrome 浏览器中内置了一款 Go 语言的编译器用于本地客户端（NaCl），这很可能会被用于在 Chrome OS 中执行 Go 语言开发的应用程序。 Go 语言可以在 Intel 或 ARM 处理器上运行，因此它也可以在安卓系统下运行，例如 Nexus 系列的产品。 关于特性缺失 许多能够在大多数面向对象语言中使用的特性 Go 语言都没有支持，但其中的一部分可能会在未来被支持。 为了简化设计，不支持函数重载和操作符重载 为了避免在 C/C++ 开发中的一些 Bug 和混乱，不支持隐式转换 Go 语言通过另一种途径实现面向对象设计（第 10-11 章）来放弃类和类型的继承 尽管在接口的使用方面（第 11 章）可以实现类似变体类型的功能，但本身不支持变体类型 不支持动态加载代码 不支持动态链接库 不支持泛型 通过 recover 和 panic 来替代异常机制 不支持静态变量 使用 Go 语言编程 如果你有其它语言的编程经历（面向对象编程语言，如：Java、C#、Object-C、Python、Ruby），在你进入到 Go 语言的世界之后，你将会像迷恋你的 X 语言一样无法自拔。Go 语言使用了与其它语言不同的设计模式，所以当你尝试将你的X语言的代码迁移到 Go 语言时，你将会非常失望，所以你需要从头开始，用 Go 的理念来思考。 如果你在至高点使用 Go 的理念来重新审视和分析一个问题，你通常会找到一个适用于 Go 语言的优雅的解决方案。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"goji-chu-zhi-shi/di-yi-ge-go-cheng-xu.html":{"url":"goji-chu-zhi-shi/di-yi-ge-go-cheng-xu.html","title":"第一个go程序","keywords":"","body":"Go 语言教程Go 语言特色Go 语言用途第一个 Go 程序Go 语言教程 Go 是一个开源的编程语言，它能让构造简单、可靠且高效的软件变得容易。 Go是从2007年末由Robert Griesemer, Rob Pike, Ken Thompson主持开发，后来还加入了Ian Lance Taylor, Russ Cox等人，并最终于2009年11月开源，在2012年早些时候发布了Go 1稳定版本。现在Go的开发已经是完全开放的，并且拥有一个活跃的社区。 Go 语言特色 简洁、快速、安全 并行、有趣、开源 内存管理、数组安全、编译迅速 Go 语言用途 Go 语言被设计成一门应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言。 对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。它提供了海量并行的支持，这对于游戏服务端的开发而言是再好不过了。 第一个 Go 程序 接下来我们来编写第一个 Go 程序 hello.go（Go 语言源文件的扩展是 .go），代码如下： package main import \"fmt\" func main() { fmt.Println(\"Hello, World!\") } 运行 $ go run hello.go Hello, World! 此外我们还可以使用 go build 命令来生成二进制文件： $ go build hello.go $ ls hello hello.go $ ./hello Hello, World! 执行命令 E:\\go\\代码\\Project\\基础\\hello_word\\main>go run hello_word.go Hello WordHello Word Hello Word E:\\go\\代码\\Project\\基础\\hello_word\\main>go build E:\\go\\代码\\Project\\基础\\hello_word\\main>dir 驱动器 E 中的卷是 study 卷的序列号是 DCA4-4E82 E:\\go\\代码\\Project\\基础\\hello_word\\main 的目录 2021/05/31 23:10 . 2021/05/31 23:10 .. 2021/05/31 23:09 480 hello_word.go 2021/05/31 23:10 2,144,256 main.exe 2 个文件 2,144,736 字节 2 个目录 108,196,679,680 可用字节 E:\\go\\代码\\Project\\基础\\hello_word\\main>go build hello_word.go E:\\go\\代码\\Project\\基础\\hello_word\\main>dir 驱动器 E 中的卷是 study 卷的序列号是 DCA4-4E82 E:\\go\\代码\\Project\\基础\\hello_word\\main 的目录 2021/05/31 23:10 . 2021/05/31 23:10 .. 2021/05/31 23:10 2,144,256 hello_word.exe 2021/05/31 23:09 480 hello_word.go 2021/05/31 23:10 2,144,256 main.exe 3 个文件 4,288,992 字节 2 个目录 108,194,533,376 可用字节 E:\\go\\代码\\Project\\基础\\hello_word\\main>go build -o hello hello_word.go E:\\go\\代码\\Project\\基础\\hello_word\\main>dir 驱动器 E 中的卷是 study 卷的序列号是 DCA4-4E82 E:\\go\\代码\\Project\\基础\\hello_word\\main 的目录 2021/05/31 23:11 . 2021/05/31 23:11 .. 2021/05/31 23:11 2,144,256 hello 2021/05/31 23:10 2,144,256 hello_word.exe 2021/05/31 23:09 480 hello_word.go 2021/05/31 23:10 2,144,256 main.exe 4 个文件 6,433,248 字节 2 个目录 108,192,387,072 可用字节 转义符 \\ \\t 相当于一个table \\n 换行 \\t \\\\ console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"goji-chu-zhi-shi/zhu-shi.html":{"url":"goji-chu-zhi-shi/zhu-shi.html","title":"注释","keywords":"","body":"1.3 注释(comment)介绍注释1.3 注释(comment) 介绍注释 用于注解说明解释程序的文字就是注释，注释提高了代码的阅读性； 注释是一个程序员必须要具有的良好编程习惯。将自己的思想通过注释先整理出来，再用代码去 体现。 2.11.2 在 Golang 中注释有两种形式 1) 行注释 基本语法 // 注释内容 举例 2) 块注释(多行注释) 基本语法 /* 注释内容 */ 举例说明 使用细节 1) 对于行注释和块注释，被注释的文字，不会被 Go 编译器执行。 2) 块注释里面不允许有块注释嵌套 [注意一下] console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"goji-chu-zhi-shi/golangguan-fang-bian-cheng-zhi-nan.html":{"url":"goji-chu-zhi-shi/golangguan-fang-bian-cheng-zhi-nan.html","title":"Golang官方编程指南","keywords":"","body":"Golang 官方编程指南Golang 标准库 API 文档Golang 官方编程指南 说明： Golang 官方网站 https://golang.org 点击上图的 tour -> 选择 简体中文就可以进入中文版的 Go 编程指南 。 Golang 官方标准库 API 文档， https://golang.org/pkg 可以查看 Golang 所有包下的函数和使用 解释术语：API api ： application program interface :应用程序编程接口。 就是我们 Go 的各个包的各个函数。 Golang 标准库 API 文档 1) API （Application Programming Interface,应用程序编程接口）是 Golang 提供的基本编程接口。 2) Go 语言提供了大量的标准库，因此 google 公司 也为这些标准库提供了相应的 API 文档，用于告 诉开发者如何使用这些标准库，以及标准库包含的方法。 3) Golang 中文网 在线标准库文档： https://studygolang.com/pkgdoc 4) Golang 的包和源文件和函数的关系简图 5) 有一个离线版的 Golang_Manual_By_AstaXie_20120522.chm console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"goji-chu-zhi-shi/dai-ma-gui-830326-zhuan-yi-fu.html":{"url":"goji-chu-zhi-shi/dai-ma-gui-830326-zhuan-yi-fu.html","title":"代码规范&转义符","keywords":"","body":"Go 规范的代码风格&语言的转义字符(escape char)说明:常用的转义字符有如下规范的代码风格Go 规范的代码风格&语言的转义字符(escape char) 说明:常用的转义字符有如下 1) \\t : 表示一个制表符，通常使用它可以排版。尚硅谷 Go 语言课程 2) \\n ：换行符 3) \\ ：一个\\ 4) \\\" ：一个\" 5) \\r ：一个回车 fmt.Println(\"天龙八部雪山飞狐\\r 张飞\"); 6) 案例截图 规范的代码风格 2.12.1 正确的注释和注释风格： 1) Go 官方推荐使用行注释来注释整个方法和语句。 2) 带看 Go 源码 2.12.2 正确的缩进和空白 1) 使用一次 tab 操作，实现缩进,默认整体向右边移动，时候用 shift+tab 整体向左移 看老师的演示： 2) 或者使用 gofmt 来进行格式化 [演示] 3) 运算符两边习惯性各加一个空格。比如：2 + 4 * 5。 4) Go 语言的代码风格. package main import \"fmt\" func main() { fmt.Println(\"hello,world!\") } 上面的写法是正确的. package main import \"fmt\" func main() { fmt.Println(\"hello,world!\") } 上面的写法不是正确，Go 语言不允许这样编写。 【Go 语言不允许这样写，是错误的！】 Go 设计者思想: 一个问题尽量只有一个解决方法 5) 一行最长不超过 80 个字符，超过的请使用换行展示，尽量保持格式优雅 举例说明 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"./":{"url":"./","title":"入门练习","keywords":"","body":"go基础语法 https://github1s.com/515250339/goland/blob/HEAD/00%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/ console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"hello-world.html":{"url":"hello-world.html","title":"Hello, World","keywords":"","body":"1.1. Hello, World 1.1. Hello, World 我们以现已成为传统的“hello world”案例来开始吧，这个例子首次出现于1978年出版的C语言圣经《The C Programming Language》（译注：本书作者之一Brian W. Kernighan也是《The C Programming Language》一书的作者）。C语言是直接影响Go语言设计的语言之一。这个例子体现了Go语言一些核心理念。 gopl.io/ch1/helloworld package main import \"fmt\" func main() { fmt.Println(\"Hello, World\") } Go是一门编译型语言，Go语言的工具链将源代码及其依赖转换成计算机的机器指令（译注：静态编译）。Go语言提供的工具都通过一个单独的命令go调用，go命令有一系列子命令。最简单的一个子命令就是run。这个命令编译一个或多个以.go结尾的源文件，链接库文件，并运行最终生成的可执行文件。（本书使用$表示命令行提示符。） $ go run helloworld.go 毫无意外，这个命令会输出： Hello, World Go语言原生支持Unicode，它可以处理全世界任何语言的文本。 如果不只是一次性实验，你肯定希望能够编译这个程序，保存编译结果以备将来之用。可以用build子命令： $ go build helloworld.go 这个命令生成一个名为helloworld的可执行的二进制文件（译注：Windows系统下生成的可执行文件是helloworld.exe，增加了.exe后缀名），之后你可以随时运行它（译注：在Windows系统下在命令行直接输入helloworld.exe命令运行），不需任何处理（译注：因为静态编译，所以不用担心在系统库更新的时候冲突，幸福感满满）。 $ ./helloworld Hello, World 本书中所有示例代码上都有一行标记，利用这些标记可以从gopl.io网站上本书源码仓库里获取代码： gopl.io/ch1/helloworld 执行go get gopl.io/ch1/helloworld命令，就会从网上获取代码，并放到对应目录中（需要先安装Git或Hg之类的版本管理工具，并将对应的命令添加到PATH环境变量中。序言已经提及，需要先设置好GOPATH环境变量，下载的代码会放在$GOPATH/src/gopl.io/ch1/helloworld目录）。2.6和10.7节有这方面更详细的介绍。 来讨论下程序本身。Go语言的代码通过包（package）组织，包类似于其它语言里的库（libraries）或者模块（modules）。一个包由位于单个目录下的一个或多个.go源代码文件组成，目录定义包的作用。每个源文件都以一条package声明语句开始，这个例子里就是package main，表示该文件属于哪个包，紧跟着一系列导入（import）的包，之后是存储在这个文件里的程序语句。 Go的标准库提供了100多个包，以支持常见功能，如输入、输出、排序以及文本处理。比如fmt包，就含有格式化输出、接收输入的函数。Println是其中一个基础函数，可以打印以空格间隔的一个或多个值，并在最后添加一个换行符，从而输出一整行。 main包比较特殊。它定义了一个独立可执行的程序，而不是一个库。在main里的main函数也很特殊，它是整个程序执行时的入口（译注：C系语言差不多都这样）。main函数所做的事情就是程序做的。当然了，main函数一般调用其它包里的函数完成很多工作（如：fmt.Println）。 必须告诉编译器源文件需要哪些包，这就是跟随在package声明后面的import声明扮演的角色。hello world例子只用到了一个包，大多数程序需要导入多个包。 必须恰当导入需要的包，缺少了必要的包或者导入了不需要的包，程序都无法编译通过。这项严格要求避免了程序开发过程中引入未使用的包（译注：Go语言编译过程没有警告信息，争议特性之一）。 import声明必须跟在文件的package声明之后。随后，则是组成程序的函数、变量、常量、类型的声明语句（分别由关键字func、var、const、type定义）。这些内容的声明顺序并不重要（译注：最好还是定一下规范）。这个例子的程序已经尽可能短了，只声明了一个函数，其中只调用了一个其他函数。为了节省篇幅，有些时候示例程序会省略package和import声明，但是，这些声明在源代码里有，并且必须得有才能编译。 一个函数的声明由func关键字、函数名、参数列表、返回值列表（这个例子里的main函数参数列表和返回值都是空的）以及包含在大括号里的函数体组成。第五章进一步考察函数。 Go语言不需要在语句或者声明的末尾添加分号，除非一行上有多条语句。实际上，编译器会主动把特定符号后的换行符转换为分号，因此换行符添加的位置会影响Go代码的正确解析（译注：比如行末是标识符、整数、浮点数、虚数、字符或字符串文字、关键字break、continue、fallthrough或return中的一个、运算符和分隔符++、--、)、]或}中的一个）。举个例子，函数的左括号{必须和func函数声明在同一行上，且位于末尾，不能独占一行，而在表达式x + y中，可在+后换行，不能在+前换行（译注：以+结尾的话不会被插入分号分隔符，但是以x结尾的话则会被分号分隔符，从而导致编译错误）。 Go语言在代码格式上采取了很强硬的态度。gofmt工具把代码格式化为标准格式（译注：这个格式化工具没有任何可以调整代码格式的参数，Go语言就是这么任性），并且go工具中的fmt子命令会对指定包，否则默认为当前目录中所有.go源文件应用gofmt命令。本书中的所有代码都被gofmt过。你也应该养成格式化自己的代码的习惯。以法令方式规定标准的代码格式可以避免无尽的无意义的琐碎争执（译注：也导致了Go语言的TIOBE排名较低，因为缺少撕逼的话题）。更重要的是，这样可以做多种自动源码转换，如果放任Go语言代码格式，这些转换就不大可能了。 很多文本编辑器都可以配置为保存文件时自动执行gofmt，这样你的源代码总会被恰当地格式化。还有个相关的工具，goimports，可以根据代码需要，自动地添加或删除import声明。这个工具并没有包含在标准的分发包中，可以用下面的命令安装： $ go get golang.org/x/tools/cmd/goimports 对于大多数用户来说，下载、编译包、运行测试用例、察看Go语言的文档等等常用功能都可以用go的工具完成。10.7节详细介绍这些知识。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"ming-ling-xing-can-shu.html":{"url":"ming-ling-xing-can-shu.html","title":"命令行参数","keywords":"","body":"命令行参数命令行参数 1.编译 go build hello.go 2.go get gopl.io/ch1/helloworld命令，就会从网上获取代码，并放到对应目录中 下载的可执行程序会放在$GOPATH/bin/helloworld目录 3.Go语言不需要在语句或者声明的末尾添加分号，除非一行上有多条语句。 4.Go语言在代码格式上采取了很强硬的态度。gofmt工具把代码格式化为标准格式 gofmt -w hello.go重写回源文件 5.goimports，可以根据代码需要,自动地添加或删除import声明 go get golang.org/x/tools/cmd/goimports （被墙不能用） 命令行参数： 1.os包以跨平台的方式，提供了一些与操作系统交互的函数和变量。程序的命令行参数可从os包的Args变量获取；os包外部使用os.Args访问该变量。 2.切片是Go语言的基础概念，现在先把切片s当作数组元素序列,序列的长度动态变化,用s[i]访问单个元素，用s[m:n]获取子序列，序列的元素数目为len(s) a = [1, 2, 3, 4, 5], a[0:3] = [1, 2, 3] 3.os.Args的第一个元素，os.Args[0],是命令本身的名字，其他参数是os.Args[1:len(os.Args)] => os.Args[1:] 4.import导入两个包，括号括起来 5.Go语言只有for循环这一种循环语句 for initialization; condition; post { } for condition { } for {//无限循环 } 6.for循环的另一种形式,在某种数据类型的区间（range）上遍历，如字符串或切片。 循环迭代，range产生一对值；索引以及在该索引处的元素值。 _空标识符丢弃索引，arg是索引所对应的值 7.使用strings包的Join函数 package main import ( \"fmt\" \"os\" \"strings\" ) /* 练习 1.1 修改 echo 程序输出 os.Args[0] ,即命令的名字 练习 1.2 修改 echo 输出参数的索引和值，每行一个 练习1.3：尝试测量可能低效的程序和使用 strings.Join 的程序在执行时间上的差昇 （1.6节有time 包，11.4 节展示如何撰写系统性的性能评估测试。 */ // 练习 1.1 func test1() { var s, sep string for _, arg := range os.Args[1:] { s += sep + arg sep = \"****\" } fmt.Println(s) } //练习 1.2 func test2() { var s, sep string for i := 1; i 8.只是为了调试可以直接打印 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"zhao-chu-zhong-fu-xing.html":{"url":"zhao-chu-zhong-fu-xing.html","title":"找出重复行","keywords":"","body":"从标准输入中读取数据 1.if语句条件两边也不加括号，但是主体部分需要加{} 2.map存储了键/值（key/value）的集合，对集合元素，提供常数时间的存、取操作，map[string]int ==> key的类型string和value的类型int 3.内置函数make创建空map, counts := make(map[string]int) 4.bufio包Scanner类型读取输入并将其拆成行或单词input := bufio.NewScanner(os.Stdin) 短变量声明一个input变量 5.调用input.Scan()，读入下一行，在读到一行时返回true，不再有输入时返回false 6.fmt.Printf函数对一些表达式产生格式化输出 注意： go语言中的input.Scan() 停止输入是 EOF 终端情况下请使用 ctrl+d我是windows11使用 ctrl+z或者增加判断条件输入end直接结束循环 文件的是直接 cat input | go run main.go dup1,go package main import ( \"bufio\" \"fmt\" \"os\" ) func test1() { // 定义一个 map 对象 key:str value:int counts := make(map[string]int) input := bufio.NewScanner(os.Stdin) for input.Scan() { if input.Text() == \"end\" { break } counts[input.Text()]++ } for line, n := range counts { if n > 1 { fmt.Printf(\"%d\\t%s\\n\", n, line) } } } func main() { test1() } 从文件中读取数据 1.os.Open函数返回两个值。第一个值是被打开的文件(*os.File） 2.os.Open返回的第二个值是内置error类型的值，如果不等于内置值nil（NULL）说明出错了 3.使用fmt.Fprintf表示打印任意类型默认格式值的动词%v 4.map是一个由make函数创建的数据结构的引用，作为参数传递给某函数时相当于引用传递 package main import ( \"bufio\" \"fmt\" \"os\" ) func test1() { // 定义一个 map 对象 key:str value:int counts := make(map[string]int) input := bufio.NewScanner(os.Stdin) for input.Scan() { if input.Text() == \"end\" { break } counts[input.Text()]++ } for line, n := range counts { if n > 1 { fmt.Printf(\"%d\\t%s\\n\", n, line) } } } func test2() { // 创建 map counts := make(map[string]int) // 切片截取命令行输入数据 files := os.Args[1:] // 判断命令行是否输入文件名 if len(files) == 0 { // 无输入则调用 countLines 方法 countLines(os.Stdin, counts) } else { // 输入则打开文件 支持多个文件 for _, arg := range files { f, err := os.Open(arg) if err != nil { fmt.Println(os.Stderr, \"dup2: %v\\n\", err) } // 判断有无重复数据 countLines(f, counts) // 关闭文件 err = f.Close() if err != nil { return } } } for line, n := range counts { // 打印 counst数据 fmt.Printf(\"%d\\t%s\\n\", n, line) } } func countLines(f *os.File, counts map[string]int) { input := bufio.NewScanner(f) for input.Scan() { counts[input.Text()]++ } } func main() { test2() } 多文件 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"gifdong-hua.html":{"url":"gifdong-hua.html","title":"GIF动画","keywords":"","body":"1.常量声明的值必须是一个数字值、字符串或者一个固定的boolean值。2.常量声明和变量声明一般都会出现在包级别3.[]color.Color{...}生成的是一个slice切片和gif.GIF{...}生成的是一个struct结构体这两个表达式就是我们说的复合声明4.struct是一组值或者叫字段的集合，不同的类型集合在一个struct可以让我们以一个统一的单元进行处理，struct内部的变量可以以一个点(.)来进行访问5.import了一个包路径包含有多个单词的package时，比如image/color（image和color两个单词），通常我们只需要用最后那个单词表示这个包就可以 练习 1.5： 修改前面的Lissajous程序里的调色板，由黑色改为绿色。我们可以用color.RGBA{0xRR, 0xGG, 0xBB, 0xff}来得到#RRGGBB这个色值，三个十六进制的字符串分别代表红、绿、蓝像素。 package main import ( \"image\" \"image/color\" \"image/gif\" \"io\" \"log\" \"math\" \"math/rand\" \"net/http\" \"os\" \"time\" ) var palette = []color.Color{color.White, color.Black} const ( whiteIndex = 0 // 第一种颜色 OpaqueIndex = 1 //第二种颜色 ) func main() { rand.Seed(time.Now().UTC().UnixNano()) if len(os.Args) > 1 && os.Args[1] == \"web\" { handler := func(w http.ResponseWriter, r *http.Request) { lissajous(w) } http.HandleFunc(\"/\", handler) log.Fatal(http.ListenAndServe(\"localhost:8000\", nil)) return } lissajous(os.Stdout) } func lissajous(out io.Writer) { const ( cycles = 5 res = 0.001 size = 100 nframes = 64 delay = 8 ) freq := rand.Float64() * 3.0 anim := gif.GIF{LoopCount: nframes} phase := 0.0 for i := 0; i console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"huo-qu-url.html":{"url":"huo-qu-url.html","title":"获取url","keywords":"","body":"1.主要使用net/http和io/ioutil包 2.http.Get函数是创建HTTP请求的函数,resp这个结构体中,Body字段包括一个可读的服务器响应流 3.ioutil.ReadAll函数从response中读取到全部内容,resp.Body.Close关闭resp的Body流 4.用os.Exit函数来终止进程，并且返回一个status错误码 5.使用Fprintf与表示任意类型默认格式值的动词%v，向标准错误流打印一条信息 6.strings.HasPrefix(s, prefix string) bool,判断字符串s是否以prefix 开头 练习 1.7： 函数调用io.Copy(dst, src)会从src中读取内容，并将读到的结果写入到dst中，使用这个函数替代掉例子中的ioutil.ReadAll来拷贝响应结构体到os.Stdout，避免申请一个缓冲区（例子中的b）来存储。记得处理io.Copy返回结果中的错误。 练习 1.8： 修改fetch这个范例，如果输入的url参数没有 http:// 前缀的话，为这个url加上该前缀。你可能会用到strings.HasPrefix这个函数。 练习 1.9： 修改fetch打印出HTTP协议的状态码，可以从resp.Status变量得到该状态码。 package main import ( \"fmt\" \"io\" \"net/http\" \"os\" \"strings\" ) func main() { // 循环命令行参数 for _, url := range os.Args[1:] { //加入前缀 当参数不为 http:// 开头 则进行拼接 if !strings.HasPrefix(url, \"http://\") { url = \"http://\" + url } // 获取当前 url resp, err := http.Get(url) // 异常捕获 if err != nil { //向标准错误流打印信息 fmt.Fprintf(os.Stderr, \"fetch: v%\\n\", err) //终止进程 os.Exit(1) } // 获取 resp 中 Body 信息 // b, err := ioutil.ReadAll(resp.Body) // 避免申请一个缓冲区,直接到标准输出流 从 resp.Body 读，并且写入 os.Stdout io.Copy(os.Stdout, resp.Body) // 关闭 Body 避免资源泄露 resp.Body.Close() if err != nil { fmt.Fprintf(os.Stderr, \"fetch: reading %s: %v\\n\", url, err) os.Exit(1) } fmt.Println(\"\") // 输出 code 码 fmt.Printf(\"%s\", resp.Status) } } 执行 go run .\\exercise\\获取一个url\\main.go gopl.io 或 go build {文件名} --> ./文件名 gopl.io console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"bing-fa-huo-qu-duo-ge-url.html":{"url":"bing-fa-huo-qu-duo-ge-url.html","title":"并发获取多个url","keywords":"","body":"go语言圣经-并发获取多个URL 1.GO最新奇的特性就是对并发编程的支持,goroutine和channel 2.goroutine是一种函数的并发执行方式，而channel是用来在goroutine之间进行参数传递 go function则表示创建一个新的goroutine，并在这个新的goroutine中执行这个函数。 3.make函数创建了一个传递string类型参数的channel 4.io.Copy把响应的Body内容拷贝到ioutil.Discard输出流中,扔到一个垃圾桶 5.goroutine尝试在一个channel上做send或者receive操作时，这个goroutine会阻塞在调用处,直到另一个goroutine往这个channel里写入、或者接收值 6.用main函数来接收所有fetch函数传回的字符串，可以避免在goroutine异步执行还没有完成时main函数提前退出。 练习 1.10： 找一个数据量比较大的网站，用本小节中的程序调研网站的缓存策略，对每个URL执行两遍请求，查看两次时间是否有较大的差别，并且每次获取到的响应内容是否一致，修改本节中的程序，将响应结果输出，以便于进行对比。 练习 1.11： 在fetchall中尝试使用长一些的参数列表，比如使用在alexa.com的上百万网站里排名靠前的。如果一个网站没有回应，程序将采取怎样的行为？ （Section8.9 描述了在这种情况下的应对机制）。 package main import ( \"fmt\" \"io\" \"io/ioutil\" \"net/http\" \"os\" \"time\" ) func main() { // 获取当前时间 start := time.Now() // make函数创建了一个传递string类型参数的channel ch := make(chan string) // for循环命令行参数 for _, url := range os.Args[1:] { // 开启一个goroutine go fetch(url, ch) } for range os.Args[1:] { // 接收并打印channel,for循环不需要key value fmt.Println( console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"da-jian-yi-ge-web-fu-wu-qi.html":{"url":"da-jian-yi-ge-web-fu-wu-qi.html","title":"搭建一个web服务器","keywords":"","body":"我们这里搭建一个gin框架 https://yanxiang.wang/win%E7%8E%AF%E5%A2%83%E5%90%AF%E5%8A%A8gin/?t=1646224462365 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"cheng-xu-jie-gou.html":{"url":"cheng-xu-jie-gou.html","title":"常量、变量及基本数据类型","keywords":"","body":" console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"cheng-xu-jie-gou/ming-ming.html":{"url":"cheng-xu-jie-gou/ming-ming.html","title":"标识符和关键字","keywords":"","body":"Go语言中的函数名、变量名、常量名、类型名、语句标号和包名等所有的命名，都遵循一个简单的命名规则：一个名字必须以一个字母（Unicode字母）或下划线开头，后面可以跟任意数量的字母、数字或下划线。大写字母和小写字母是不同的：heapSort和Heapsort是两个不同的名字。 Go语言中类似if和switch的关键字有25个；关键字不能用于自定义名字，只能在特定语法结构中使用。 break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var var和const ：变量和常量的声明 package and import: 导入 func： 用于定义函数和方法 return ：用于从函数返回 defer someCode ：在函数退出之前执行 go : 用于并行 select 用于选择不同类型的通讯 interface 用于定义接口 struct用于定义抽象数据类型 break、case、continue、for、fallthrough、else、if、switch、goto、default 流程控制 chan用于channel通讯 type用于声明自定义类型 map用于声明map类型数据 range用于读取slice、map、channel数据 此外，还有大约30多个预定义的名字，比如int和true等，主要对应内建的常量、类型和函数。 内建常量: true false iota nil 内建类型: int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr float32 float64 complex128 complex64 bool byte rune string error 内建函数: make len cap new append copy close delete complex real imag panic recover 这些内部预先定义的名字并不是关键字，你可以在定义中重新使用它们。在一些特殊的场景中重新定义它们也是有意义的，但是也要注意避免过度而引起语义混乱。 如果一个名字是在函数内部定义，那么它就只在函数内部有效。如果是在函数外部定义，那么将在当前包的所有文件中都可以访问。名字的开头字母的大小写决定了名字在包外的可见性。如果一个名字是大写字母开头的（译注：必须是在函数外部定义的包级名字；包级函数名本身也是包级名字），那么它将是导出的，也就是说可以被外部的包访问，例如fmt包的Printf函数就是导出的，可以在fmt包外部访问。包本身的名字一般总是用小写字母。 名字的长度没有逻辑限制，但是Go语言的风格是尽量使用短小的名字，对于局部变量尤其是这样；你会经常看到i之类的短名字，而不是冗长的theLoopIndex命名。通常来说，如果一个名字的作用域比较大，生命周期也比较长，那么用长的名字将会更有意义。 在习惯上，Go语言程序员推荐使用 驼峰式 命名，当名字由几个单词组成时优先使用大小写分隔，而不是优先用下划线分隔。因此，在标准库有QuoteRuneToASCII和parseRequestLine这样的函数命名，但是一般不会用quote_rune_to_ASCII和parse_request_line这样的命名。而像ASCII和HTML这样的缩略词则避免使用大小写混合的写法，它们可能被称为htmlEscape、HTMLEscape或escapeHTML，但不会是escapeHtml。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"cheng-xu-jie-gou/sheng-ming.html":{"url":"cheng-xu-jie-gou/sheng-ming.html","title":"声明、变量、常量","keywords":"","body":"声明常量 、变量demo变量的生命周期声明 1.四种类型的声明语句：var、const、type和func，分别对应变量、常量、类型和函数实体对象的声明2.包一级声明语句声明的名字可在整个包对应的每个源文件中访问,局部声明的名字就只能在函数内部很小的范围被访问 常量 、变量 var 变量名字 类型 = 表达式 零值初始化机制,数值类型零值是0，布尔类型变量对应的零值是false，字符串类型对应的零值是空字符串，接口或引用类型（包括slice、指针、map、chan和函数）变量对应的零值是nil 同时声明一组变量,用逗号分隔 简短变量声明 := ,只有对已经在同级词法域声明过的变量才和赋值操作语句等价 demo package main import \"fmt\" // 常量声明 const boilingF = 212.0 //func main() { // var f = boilingF // var c = (f - 32) * 5 / 9 // fmt.Printf(\"%g° or %g℃\", f, c) //} func main() { // 变量声明 const freezingF, boiling = 32.0, boilingF // 调用函数 fToC 计算 入参为 float64 类型，返回参数为 float64 类型 fmt.Printf(\"%g°F = %g°C\\n\", freezingF, fToC(freezingF)) // \"32°F = 0°C\" fmt.Printf(\"%g°F = %g°C\\n\", boiling, fToC(boiling)) // \"212°F = 100°C\" } // 入参为 float64 类型，返回参数为 float64 类型 func fToC(f float64) float64 { // 计算并返回 return (f - 32) * 5 / 9 } 变量的生命周期 变量的生命周期指的是在程序运行期间变量有效存在的时间段。对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。而相比之下，局部变量的生命周期则是动态的：每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。 Go语言的自动垃圾收集器对编写正确的代码是一个巨大的帮助，但也并不是说你完全不用考虑内存了。你虽然不需要显式地分配和释放内存，但是要编写高效的程序你依然需要了解变量的生命周期。例如，如果将指向短生命周期对象的指针保存到具有长生命周期的对象中，特别是保存到全局变量时，会阻止对短生命周期对象的垃圾回收（从而可能影响程序的性能）。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"cheng-xu-jie-gou/zhi-zhen.html":{"url":"cheng-xu-jie-gou/zhi-zhen.html","title":"指针、new函数","keywords":"","body":"指针demonew函数指针 1.一个指针的值是另一个变量的地址,指针名字为p，那么可以说“p指针指向变量x”，或者说“p指针保存了x变量的内存地址”2.聚合类型每个成员,可以被取地址3.函数返回局部变量的地址也是安全的4.将指针作为参数调用函数，那将可以在函数中通过该指针来更新变量的值。5.我们对一个变量取地址，或者复制指针，我们都是为原变量创建了新的别名6.指针是实现标准库中flag包的关键技术，它使用命令行参数来设置对应变量的值 demo /* &是“取地址运算符”，是从一个变量获取地址 *是“解引用运算符”，可以简单理解为“从地址取值”， 是&的逆运算 你 testd 是一个 Test*类型，也就是指向 Test 的指针 然后&testd 就是 testd 变量本身的地址，类型应该是 Test 的指针的指针 */ package main import \"fmt\" type Test struct { name string } func main() { var a int = 20 /* 声明实际变量 */ var ip *int /* 声明指针变量 */ ip = &a /* 指针变量的存储地址 */ fmt.Printf(\"a 变量的地址是: %x\\n\", &a) /* 指针变量的存储地址 */ fmt.Printf(\"ip 变量储存的指针地址: %x\\n\", ip) /* 使用指针访问值 */ fmt.Printf(\"*ip 变量的值: %d\\n\", *ip) main2() } func main2() { testa := Test{\"test\"} fmt.Println(testa) //结果{test} testb := &Test{\"test\"} fmt.Println(testb) //结果 &{test} testc := &Test{\"test\"} fmt.Println(*testc) //结果 {test} testd := &Test{\"test\"} fmt.Println(&testd) //结果 0xc000006030 var a int = 1 fmt.Println(a) //结果 1 fmt.Println(&a) //结果 0xc00000c0d8 } new函数 另一个创建变量的方法是调用用内建的new函数,new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为*T。 用new创建变量和普通变量声明语句方式创建变量没有什么区别，除了不需要声明一个临时变量的名字外，我们还可以在表达式中使用new(T)。换言之，new函数类似是一种语法糖，而不是一个新的基础概念。p := new(int) // p, *int 类型, 指向匿名的 int 变量 fmt.Println(*p) // \"0\" *p = 2 // 设置 int 匿名变量的值为 2 fmt.Println(*p) // \"2\" console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"fu-zhi.html":{"url":"fu-zhi.html","title":"赋值","keywords":"","body":"赋值多重赋值（元组赋值）可赋值性 赋值 将要被赋值的变量放在=的左边，新值的表达式放在=的右边。 x = 1 // 命名变量的赋值 *p = true // 通过指针间接赋值 person.name = \"bob\" // 结构体字段赋值 count[x] = count[x] * scale // 数组、slice或map的元素赋值 特定的二元算术运算符和赋值语句的复合操作可以重写为： count[x] *= scale 这样可以省去对变量表达式的重复计算。 数值变量也可以支持++递增和--递减语句 v := 1 v++ // 等价方式 v = v + 1；v 变成 2 v-- // 等价方式 v = v - 1；v 变成 1 多重赋值（元组赋值） 元组赋值是另一种形式的赋值语句，它允许同时更新多个变量的值。在赋值之前，赋值语句右边的所有表达式将会先进行求值，然后再统一更新左边对应变量的值。 x, y = y, x a[i], a[j] = a[j], a[i] 元组赋值也可以使一系列琐碎赋值更加紧凑（译注: 特别是在for循环的初始化部分）， i, j, k = 2, 3, 5 但如果表达式太复杂的话，应该尽量避免过度使用元组赋值；因为每个变量单独赋值语句的写法可读性会更好。 可赋值性 赋值语句是显式的赋值形式，但是程序中还有很多地方会发生隐式的赋值行为：函数调用会隐式地将调用参数的值赋值给函数的参数变量，一个返回语句会隐式地将返回操作的值赋值给结果变量，一个复合类型的字面量（§4.2）也会产生赋值行为。例如下面的语句： medals := []string{\"gold\", \"silver\", \"bronze\"} 隐式地对slice的每个元素进行赋值操作，类似这样写的行为： medals[0] = \"gold\" medals[1] = \"silver\" medals[2] = \"bronze\" map和chan的元素，虽然不是普通的变量，但是也有类似的隐式赋值行为。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"cheng-xu-jie-gou/shu-ju-lei-xing.html":{"url":"cheng-xu-jie-gou/shu-ju-lei-xing.html","title":"基本数据类型","keywords":"","body":"数据类型的基本介绍整数类型整数的各个类型int 的无符号的类型：int 的其它类型的说明:数据类型的基本介绍 整数类型 基本介绍 简单的说，就是用于存放整数值的，比如 0, -1, 2345 等等 整数的各个类型 int 的无符号的类型： int 的其它类型的说明: 整型的使用细节 1) Golang 各整数类型分：有符号和无符号，int uint 的大小和系统有关。 2) Golang 的整型默认声明为 int 型 3) 如何在程序查看某个变量的字节大小和数据类型 （使用较多） 4) Golang 程序中整型变量在使用时，遵守保小不保大的原则，即：在保证程序正确运行下，尽量 使用占用空间小的数据类型。【如：年龄】 5) bit: 计算机中的最小存储单位。byte:计算机中基本存储单元。[二进制再详细说] 1byte = 8 bit console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"ji-chu-yu-fa.html":{"url":"ji-chu-yu-fa.html","title":"基础语法","keywords":"","body":" console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"ji-chu-yu-fa/pan-duan-yu-ju.html":{"url":"ji-chu-yu-fa/pan-duan-yu-ju.html","title":"条件语句","keywords":"","body":"if语法if else语法if 语句嵌套语法switch语法select语法select demoif if 语句由布尔表达式后紧跟一个或多个语句组成。 语法 if 布尔表达式 { /* 在布尔表达式为 true 时执行 */ } If 在布尔表达式为 true 时，其后紧跟的语句块执行，如果为 false 则不执行。 if else if 语句 后可以使用可选的 else 语句, else 语句中的表达式在布尔表达式为 false 时执行。 语法 if 布尔表达式 { /* 在布尔表达式为 true 时执行 */ } else { /* 在布尔表达式为 false 时执行 */ } If 在布尔表达式为 true 时，其后紧跟的语句块执行，如果为 false 则执行 else 语句块。 if 语句嵌套 你可以在 if 或 else if 语句中嵌入一个或多个 if 或 else if 语句。 语法 if 布尔表达式 1 { /* 在布尔表达式 1 为 true 时执行 */ if 布尔表达式 2 { /* 在布尔表达式 2 为 true 时执行 */ } } 你可以以同样的方式在 if 语句中嵌套else if...else语句 switch switch 语句用于基于不同条件执行不同动作，每一个 case 分支都是唯一的，从上至下逐一测试，直到匹配为止。 switch 语句执行的过程从上至下，直到找到匹配项，匹配项后面也不需要再加 break。 switch 默认情况下 case 最后自带 break 语句，匹配成功后就不会执行其他 case，如果我们需要执行后面的 case，可以使用fallthrough。 语法 switch var1 { case val1: ... case val2: ... default: ... } 变量 var1 可以是任何类型，而 val1 和 val2 则可以是同类型的任意值。类型不被局限于常量或整数，但必须是相同的类型；或者最终结果为相同类型的表达式。 您可以同时测试多个可能符合条件的值，使用逗号分割它们，例如：case val1, val2, val3。 select select 是 Go 中的一个控制结构，类似于用于通信的 switch 语句。每个 case 必须是一个通信操作，要么是发送要么是接收。 select 随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。一个默认的子句应该总是可运行的。 语法 select { case communication clause : statement(s); case communication clause : statement(s); /* 你可以定义任意数量的 case */ default : /* 可选 */ statement(s); } 以下描述了 select 语句的语法： 每个 case 都必须是一个通信 所有 channel 表达式都会被求值 所有被发送的表达式都会被求值 如果任意某个通信可以进行，它就执行，其他被忽略。 如果有多个 case 都可以运行，Select 会随机公平地选出一个执行。其他不会执行。 否则： 如果有 default 子句，则执行该语句。 如果没有 default 子句，select 将阻塞，直到某个通信可以运行；Go 不会重新对 channel 或值进行求值。 select demo // switch 相当于 if elif func switchTest() { fmt.Println(\"\") fmt.Println(\"---------switch-----------\") for i := 1; i console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"ji-chu-yu-fa/xun-huan-yu-ju.html":{"url":"ji-chu-yu-fa/xun-huan-yu-ju.html","title":"循环语句","keywords":"","body":"for 循环语法练习for语法循环嵌套语法九九成法表break语法democontinue语法demogoto语法for 循环语法练习 for for 循环是一个循环控制结构，可以执行指定次数的循环。 语法 Go 语言的 For 循环有 3 种形式，只有其中的一种使用分号。 for init; condition; post {} for condition { } for{ } init： 一般为赋值表达式，给控制变量赋初值； condition： 关系表达式或逻辑表达式，循环控制条件； post： 一般为赋值表达式，给控制变量增量或减量。 for语句执行过程如下： 1、先对表达式 1 赋初值； 2、判别赋值表达式 init 是否满足给定条件，若其值为真，满足循环条件，则执行循环体内语句，然后执行 post，进入第二次循环，再判别 condition；否则判断 condition 的值为假，不满足条件，就终止for循环，执行循环体外语句。 for 循环的 range 格式可以对 slice、map、数组、字符串等进行迭代循环。格式如下： for key, value := range oldMap { newMap[key] = value } 循环嵌套 Go 语言允许用户在循环内使用循环。接下来我们将为大家介绍嵌套循环的使用。 语法 for [condition | ( init; condition; increment ) | Range] { for [condition | ( init; condition; increment ) | Range] { statement(s); } statement(s); } 九九成法表 package main import \"fmt\" func main() { for m := 1; m break Go 语言中 break 语句用于以下两方面： 用于循环语句中跳出循环，并开始执行循环之后的语句。 break 在 switch（开关语句）中在执行一条 case 后跳出语句的作用。 在多重循环中，可以用标号 label 标出想 break 的循环。 语法 break 语法格式如下： break; demo // break 跳出当前循环，可⽤于 for、switch、select。 func breakTest() { fmt.Println(\"\") fmt.Println(\"---------break-----------\") for i := 1; 1 continue Go 语言的 continue 语句 有点像 break 语句。但是 continue 不是跳出循环，而是跳过当前循环执行下一次循环语句。 for 循环中，执行 continue 语句会触发 for 增量语句的执行。 在多重循环中，可以用标号 label 标出想 continue 的循环。 语法 continue 语法格式如下： continue; demo // continue 跳过本次循环，只能用于 for。 func continueTest() { fmt.Println(\"\") fmt.Println(\"---------continue-----------\") for i := 1; i goto Go 语言的 goto 语句可以无条件地转移到过程中指定的行。 goto 语句通常与条件语句配合使用。可用来实现条件转移， 构成循环，跳出循环体等功能。 但是，在结构化程序设计中一般不主张使用 goto 语句， 以免造成程序流程的混乱，使理解和调试程序都产生困难。 语法 goto 语法格式如下： goto label; .. . label: statement; console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"yun-suan-fu.html":{"url":"yun-suan-fu.html","title":"比较、关系运算符","keywords":"","body":"算数运算符使用、i++关系运算符逻辑运算符赋值运算符.算数运算符 算数运算符使用、 package main import ( \"fmt\" ) func main() { fmt.Println(\"10+3=\", 10+3) //10+3= 13 fmt.Println(\"10-3=\", 10-3) //10-3= 7 fmt.Println(\"10*3=\", 10*3) //10*3= 30 //除法注意：如果运算的数都是整数，那么除后，去掉小数部分，保留整数部分 fmt.Println(\"10/3=\", 10/3) //10/3= 3 fmt.Println(\"10.0/3=\", 10.0/3) //3.3333333333333335 // 取余注意 余数=被除数-（被除数/除数）*除数 fmt.Println(\"10%3=\", 10%3) //10%3= 1 fmt.Println(\"-10%3=\", -10%3) // -10%3= -1 fmt.Println(\"10%-3=\", 10%-3) // 10%-3= 1 fmt.Println(\"-10%-3=\", -10%-3) // -10%-3= -1 } i++ package main import ( \"fmt\" ) func main() { var i int = 1 i++ fmt.Println(\"i=\", i) // i= 2 } 关系运算符 package main import ( \"fmt\" ) func main() { var n1 int = 9 var n2 int = 8 fmt.Println(n1 == n2) //false fmt.Println(n1 != n2) //true fmt.Println(n1 > n2) //true fmt.Println(n1 >= n2) //true fmt.Println(n1 n2 fmt.Println(\"flag=\", flag) //flag= true } 逻辑运算符 package main import ( \"fmt\" ) func main() { //演示逻辑运算符的使用 && var age int = 40 if age > 30 && age 30 && age 30 || age 30 || age 30 { fmt.Println(\"ok5\") } if !(age > 30) { fmt.Println(\"ok6\") } } 赋值运算符 package main import ( \"fmt\" ) func main() { d := 8 + 2*8 //赋值运算从右向左 fmt.Println(d) //24 x := 10 x += 5 //x=x+5 fmt.Println(\"x += 5 的值:\", x) //24 } console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"shu-ju-lei-xing.html":{"url":"shu-ju-lei-xing.html","title":"数据类型与常见操作","keywords":"","body":" console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"shu-ju-lei-xing/shu-zi-lei-xing.html":{"url":"shu-ju-lei-xing/shu-zi-lei-xing.html","title":"数字类型","keywords":"","body":"数字类型Golang数据类型介绍整型分为两大类unsafe.Sizeofint不同长度直接的转换浮点型reflect.TypeOf查看数据类型int常用转换int8转int16int16转float32math.Sqrt强转int与str转换str与int64转换 数字类型 Golang数据类型介绍 Go 语言中数据类型分为：基本数据类型和复合数据类型 基本数据类型有： 整型、浮点型、布尔型、字符串复合数据类型有： 数组、切片、结构体、函数、map、通道（channel）、接口 整型分为两大类 有符号整形按长度分为：int8、int16、int32、int64 对应的无符号整型：uint8、uint16、uint32、uint64 关于字节： 字节也叫 Byte，是计算机数据的基本存储单位。8bit(位)=1Byte(字节) 1024Byte(字节)=1KB 1024KB=1MB 1024MB=1GB 1024GB=1TB 。在电脑里一个中文字是占两个字节的。 unsafe.Sizeof unsafe.Sizeof(n1) 是 unsafe 包的一个函数，可以返回 n1 变量占用的字节数 package main import ( \"fmt\" \"unsafe\" ) // 查看占用内存 参数aa 为int类型 从地址取值 func sizeOf(aa *int) { fmt.Println(*aa) // 输出类型为 %T fmt.Printf(\"%T\\n\", *aa) // 查看占用内存 fmt.Println(unsafe.Sizeof(*aa)) } func main() { var a = 99 // 传入内存地址 sizeOf(&a) } int不同长度直接的转换 package main import ( \"fmt\" \"unsafe\" ) // 类型转换 参数aa 为int类型 从地址取值 func transitionInt32(aa *int) { fmt.Println(*aa) // 输出类型为 %T fmt.Printf(\"%T\\n\", *aa) // 查看占用内存 fmt.Println(unsafe.Sizeof(*aa)) // 类型转换 dd := int32(*aa) fmt.Println(dd) // 输出类型为 %T fmt.Printf(\"%T\\n\", dd) // 查看占用内存 fmt.Println(unsafe.Sizeof(dd)) } func main() { var a = 127 // 传入内存地址 transitionInt32(&a) } 浮点型 Go 语言支持两种浮点型数：float32 和 float64 package main import ( \"fmt\" \"math\" \"unsafe\" ) // 查看float类型 参数aa float64 从地址取值 func floatTest(aa *float64) { fmt.Println(*aa) // 输出类型为 %T fmt.Printf(\"%T\\n\", *aa) // 查看占用内存 fmt.Println(unsafe.Sizeof(*aa)) } func main() { a := math.Pi // 传入内存地址 floatTest(&a) } reflect.TypeOf查看数据类型 package main import ( \"fmt\" \"reflect\" ) // 查看数据类型 func showType() { a := 10 fmt.Println(reflect.TypeOf(a)) } func main() { showType() } int常用转换 package main import ( \"fmt\" \"strconv\" ) // int 常用转换 func intTransition() { aStr := \"123465\" // 转为int32 intV, _ := strconv.Atoi(aStr) fmt.Printf(\"intV:%v--type:%T\\n\", intV, intV) // 转为int64 base:10进制 bitSize:预期数值的bit大小，用于数值上限限制，最终返回的还是int64类型 int64V, _ := strconv.ParseInt(aStr, 10, 64) fmt.Printf(\"intV:%v--type:%T\\n\", int64V, int64V) // int转string aInt := 123 strS := strconv.Itoa(aInt) fmt.Printf(\"intV:%v--type:%T\\n\", strS, strS) // int64转string var aInt64 int64 aInt64 = 123 str64S := strconv.FormatInt(aInt64, 10) fmt.Printf(\"intV:%v--type:%T\\n\", str64S, str64S) } func main() { intTransition() } int8转int16 package main import \"fmt\" func main() { var a int8 = 20 var b int16 = 40 var c = int16(a) + b //要转换成相同类型才能运行 fmt.Printf(\"值：%v--类型%T\", c, c) //值：60--类型 int16 } int16转float32 package main import \"fmt\" func main() { var a float32 = 3.2 var b int16 = 6 var c = a + float32(b) fmt.Printf(\"值：%v--类型%T\", c, c) //值：9.2--类型 float32 } math.Sqrt强转 package main import ( \"fmt\" \"math\" ) func main() { var a, b = 3, 4 var c int // math.Sqrt()接收的参数是 float64 类型，需要强制转换 c = int(math.Sqrt(float64(a*a + b*b))) fmt.Println(c) // 5 } int与str转换 package main import ( \"fmt\" \"strconv\" ) func main() { //2.1 int64转str var num2 int64 = 123456 str2 := strconv.FormatInt(num2, 10) fmt.Printf(\"%v---%T \\n\",str2,str2) // 123456---string //2.2 str转int64 v1, _ := strconv.ParseFloat(str2, 64) fmt.Printf(\"%v---%T\\n\",v1,v1) // 123456---float64 } str与int64转换 package main import ( \"fmt\" \"strconv\" ) func main() { //1.1 int转sting num1 := 123456 str1 := strconv.Itoa(num1) fmt.Printf(\"%v---%T \\n\",str1,str1) // 123456---string // 1.2 sting转int _int, err := strconv.Atoi(str1) fmt.Println(_int,err) // 123456 fmt.Printf(\"%v---%T\\n\",_int,_int) // 123456---int //2.1 int64转str var num2 int64 = 123456 str2 := strconv.FormatInt(num2, 10) fmt.Printf(\"%v---%T \\n\",str2,str2) // 123456---string //2.2 str转int64 v1, _ := strconv.ParseFloat(str2, 64) fmt.Printf(\"%v---%T\\n\",v1,v1) // 123456---float64 } console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"shu-ju-lei-xing/zi-fu-chuan-lei-xing.html":{"url":"shu-ju-lei-xing/zi-fu-chuan-lei-xing.html","title":"字符串类型","keywords":"","body":"字符串字符串转义符多行字符串byte和rune字符串的常用操作len(str)+(拼接)strings.Split()strings.HasPrefix()strings.Index()strings.Join()单引号遍历字符串修改字符串sprintf转stringstrconvstring转intstring转floatstring转boolstring转字符字符串反转字符串 Go 语言里的字符串的内部实现使用 UTF-8 编码。字符串的值为双引号(\")中的内容，可以在 Go 语言的源码中直接添加非 ASCII 码字符s1 := \"hello\"s2 := \"你好\" 字符串转义符 Go 语言的字符串常见转义符包含回车、换行、单双引号、制表符等 package main import ( \"fmt\" ) func main() { // 创建字符串 fmt.Println(\"str := \\\"c:\\\\Code\\\\demo\\\\go.exe\\\"\") // str := \"c:\\Code\\demo\\go.exe\" str := \"c:\\\\Code\\\\demo\\\\go.exe\" fmt.Println(\"str := \", str) } 多行字符串 反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。 package main import ( \"fmt\" ) func main() { // 创建的多行字符串 sManyLine := `第一行 第二行 第三行` fmt.Println(sManyLine) } byte和rune Go 语言的字符有以下两种uint8类型，或者叫 byte 型：代表了ASCII码的一个字符。rune类型：代表一个 UTF-8字符字符串底层是一个byte数组，所以可以和[]byte类型相互转换。字符串是不能修改的 字符串是由byte字节组成，所以字符串的长度是byte字节的长度。rune类型用来表示utf8字符，一个rune字符由一个或多个byte组成。 package main import ( \"fmt\" ) // byte和rune func byteAndRune() { s := \"日本垃垃\" fmt.Println(s) sRune := []rune(s) fmt.Println(\"美国\" + string(sRune[2:])) } func main() { byteAndRune() } 字符串的常用操作 方法 介绍len(str) 求长度+或fmt.Sprintf 拼接字符串strings.Split 分割strings.Contains 判断是否包含strings.HasPrefix,strings.HasSuffix 前缀/后缀判断strings.Index(),strings.LastIndex() 子串出现的位置strings.Join(a[]string, sep string) join操作 len(str) package main import ( \"fmt\" ) // 获取字符串长度 func lenStr(a *string) { fmt.Println(len(*a)) } func main() { var a = \"string\" lenStr(&a) } +(拼接) package main import ( \"fmt\" ) // 拼接字符串 func strJoin(a, b *string) { fmt.Println(*a + *b) } func main() { var a = \"hi \" var b = \"lao 8\" strJoin(&a, &b) } strings.Split() package main import ( \"fmt\" \"strings\" ) // 切分字符串 func strSplit(a *string) { bArr := strings.Split(*a, \"/\") fmt.Println(bArr) fmt.Println(bArr[0]) } func main() { a := \"123/456/789\" strSplit(&a) } strings.HasPrefix() 首字符尾字母包含指定字符 package main import ( \"fmt\" \"strings\" ) func strHasPrefix(a *string) { // 是否以test开头 if strings.HasPrefix(*a, \"test\") { fmt.Println(\"是test开头\") } else if strings.HasSuffix(*a, \"end\") { //是否以en结尾 fmt.Println(\"是end结尾\") } } func main() { a := \"test_a\" strHasPrefix(&a) a = \"a_end\" strHasPrefix(&a) } strings.Index() 判断字符串出现的位置 package main import ( \"fmt\" \"strings\" ) // 判断字符串出现的位置 func indexStr(a *string) { index := strings.Index(*a, \"w\") fmt.Println(index) } func main() { // 判断字符串出现的位置 a := \"teswt\" indexStr(&a) } strings.Join() package main import ( \"fmt\" \"strings\" ) // 拼接字符串 func strJoin2(a *string) { aArr := strings.Split(*a, \" \") fmt.Println(aArr) aStr := strings.Join(aArr, \"-\") fmt.Println(aStr) } func main() { var b = \"lao 8\" strJoin2(&b) } 单引号 组成每个字符串的元素叫做“字符”，可以通过遍历字符串元素获得字符，字符用单引号（’）uint8 类型，或者叫 byte 型，代表了 ASCII 码的一个字符rune 类型，代表一个 UTF-8 字符 package main import ( \"fmt\" \"strings\" ) func strASCII() { a := 'a' name := \"张三\" // 当我们直接输出 byte（字符）的时候输出的是这个字符对应的码 fmt.Println(a) // 97 这里输出的是 a 字符串的 ASCII值 fmt.Println(name) // 如果我们要输出这个字符，需要格式化输出 fmt.Printf(\"%c\\n\", a) // 或者声明并强转为str var b = string('a') fmt.Println(b) } func main() { // 单引号 strASCII() } 遍历字符串 package main import \"fmt\" func main() { s := \"hello word\" // 通过下标去获取元素 for i := 0; i 修改字符串 要修改字符串，需要先将其转换成[]rune 或[]byte，完成后再转换为 string。无论哪种转换，都会重新分配内存，并复制字节数组。 package main import \"fmt\" func main() { // 修改字符串，需要先将其转换成[]rune 或[]byte，完成后再转换为 string s1 := \"big\" byteS1 := []byte(s1) byteS1[0] = 'B' fmt.Println(string(byteS1)) s2 := \"Big\" byteS2 := []rune(s2) byteS2[0] = 'b' fmt.Println(string(byteS2)) } package main import \"fmt\" func main() { // 修改字符串，需要先将其转换成[]rune 或[]byte，完成后再转换为 string s1 := \"big\" byteS1 := []byte(s1) byteS1[0] = 'B' fmt.Println(string(byteS1)) s2 := \"Big\" byteS2 := []rune(s2) byteS2[0] = 'b' fmt.Println(string(byteS2)) } sprintf转string 注意：sprintf 使用中需要注意转换的格式int 为%dfloat 为%fbool 为%tbyte 为%c package main import \"fmt\" func main() { var i int = 10 var f float64 = 2.00 var t bool = true var b byte = 'a' var str string str = fmt.Sprintf(\"%d\", i) fmt.Printf(\"类型: %T，值: %v \\n\", str, str) str = fmt.Sprintf(\"%f\", f) fmt.Printf(\"类型: %T，值: %v \\n\", str, str) str = fmt.Sprintf(\"%t\", t) fmt.Printf(\"类型: %T，值: %v \\n\", str, str) str = fmt.Sprintf(\"%c\", b) fmt.Printf(\"类型: %T，值: %v \\n\", str, str) } strconv package main import ( \"fmt\" \"strconv\" ) func main() { // int 转换为 string var i int fmt.Printf(\"转换前类型：%T，值：%v \\n\", i, i) s1 := strconv.Itoa(i) fmt.Printf(\"转换后类型：%T，值：%v \\n\", s1, s1) fmt.Println() // float 转 string var i2 float64 = 0.01 fmt.Printf(\"转换前类型：%T，值：%v \\n\", i2, i2) /* 参数 1：要转换的值 参数 2：格式化类型 参数 3: 保留的小数点 -1（不对小数点格式化） 参数 4：格式化的类型 */ s2 := strconv.FormatFloat(i2, 'f', 2, 64) fmt.Printf(\"转换后类型：%T，值：%v \\n\", s2, s2) fmt.Println() // bool 转 string b := false fmt.Printf(\"转换前类型：%T，值：%v \\n\", b, b) s3 := strconv.FormatBool(b) fmt.Printf(\"转换后类型：%T，值：%v \\n\", s3, s3) fmt.Println() // int64 转 string var i3 int64 = 998 fmt.Printf(\"转换前类型：%T，值：%v \\n\", i3, i3) var s4 = strconv.FormatInt(i3, 10) fmt.Printf(\"转换后类型：%T，值：%v \\n\", s4, s4) fmt.Println() } string转int package main import ( \"fmt\" \"strconv\" ) // string转int func str2int2() { var a string = \"1234\" i64, _ := strconv.ParseInt(a, 10, 64) fmt.Printf(\"转换前类型: %T 转换后类型: %T 值: %v \\n\", a, i64, i64) } func main() { str2int2() } string转float package main import ( \"fmt\" \"strconv\" ) // string转float func str2float() { var a string = \"3.14\" f32, _ := strconv.ParseFloat(a, 32) f64, _ := strconv.ParseFloat(a, 64) fmt.Printf(\"转换前类型: %T 转换后类型: %T 值: %v \\n\", a, f32, f32) fmt.Printf(\"转换前类型: %T 转换后类型: %T 值: %v \\n\", a, f64, f64) } func main() { str2float() } string转bool package main import ( \"fmt\" \"strconv\" ) // string转bool func str2bool() { var a string = \"true\" b, _ := strconv.ParseBool(a) fmt.Printf(\"转换前类型: %T 转换后类型: %T 值: %v \\n\", a, b, b) } func main() { str2bool() } string转字符 package main import ( \"fmt\" \"strconv\" ) // string转字符 func str2ASCII() { var a string = \"hello goland\" for _, i := range a { fmt.Printf(\"%v(%c) \", i, i) } } func main() { str2ASCII() } 字符串反转 package main import ( \"fmt\" \"strconv\" ) // 字符串反转 func strServer() { a := \"test\" r := []rune(a) for i, j := 0, len(r)-1; i console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"shu-ju-lei-xing/shu-zu.html":{"url":"shu-ju-lei-xing/shu-zu.html","title":"数组","keywords":"","body":"数组介绍Array介绍 #1.2 数组定义 #1.3 数组是值类型 #02.创建数组 #2.1 自定义数组长度 #2.2 让编译器识别 #2.3 指定索引值 #03.数组的遍历 #3.1 普通遍历数组 #3.2 k,v遍历数组 #04.多维数组 #4.1 定义多维数组 #4.2 遍历多维数组 #05.数组练习 #5.1 数组求和 #5.2 数组最大值 数组介绍 Array介绍 数组是指一系列 同一类型数据的集合。 数组中包含的每个数据被称为数组元素(element)，这种类型可以是任意的原始类型，比如 int、string 等 一个数组包含的元素个数被称为数组的长度。 在 Golang 中数组是一个长度固定的数据类型，数组的长度是类型的一部分，也就是说 [5]int 和 [10]int 是两个不同的类型。 Golang中数组的另一个特点是占用内存的连续性，也就是说数组中的元素是被分配到连续的内存地址中的，因而索引数组元素的速度非常快。 和数组对应的类型是 Slice（切片），Slice 是可以增长和收缩的动态序列，功能也更灵活 但是想要理解 slice 工作原理的话需要先理解数组，所以本节主要为大家讲解数组的使用。 #1.2 数组定义 var 数组变量名 [元素数量]T 比如：var a [5]int， 数组的长度必须是常量，并且长度是数组类型的一部分 一旦定义，长度不能变。 [5]int 和[4]int 是不同的类型。 #1.3 数组是值类型 数组是值类型，赋值和传参会复制整个数组。 因此改变副本的值，不会改变本身的值。 注意： 数组支持 “==“、”!=” 操作符，因为内存总是被初始化过的。 [n]*T 表示指针数组， *[n]T 表示数组指针 package main import \"fmt\" func main ( ) { a := [ 3 ] int { 10 , 20 , 30 } modifyArray ( a ) //在 modify 中修改的是 a 的副本 x fmt . Println ( a ) //[10 20 30] } func modifyArray ( x [ 3 ] int ) { x [ 0 ] = 100 } #02.创建数组 #2.1 自定义数组长度 package main import \"fmt\" func main ( ) { // 1) 数组会初始化为 int 类型的零值 var testArray [ 3 ] int fmt . Println ( testArray ) //[0 0 0] // 2) 使用指定的初始值完成初始化 var numArray = [ 3 ] int { 1 , 2 } fmt . Println ( numArray ) //[1 2 0] var cityArray = [ 3 ] string { \"北京\" , \"上海\" , \"深圳\" } fmt . Println ( cityArray ) //[北京 上海 深圳] } #2.2 让编译器识别 按照上面的方法每次都要确保提供的初始值和数组长度一致 一般情况下我们可以让编译器根据初始值的个数自行推断数组的长度 package main import \"fmt\" func main ( ) { var numArray = [ ... ] int { 1 , 2 } fmt . Println ( numArray ) //[1 2] fmt . Printf ( \"type of numArray:%T\\n\" , numArray ) //type of numArray:[2]int var cityArray = [ ... ] string { \"北京\" , \"上海\" , \"深圳\" } fmt . Println ( cityArray ) //[北京 上海 深圳] fmt . Printf ( \"type of cityArray:%T\\n\" , cityArray ) //type of cityArray:[3]string } #2.3 指定索引值 我们还可以使用指定索引值的方式来初始化数组 package main import \"fmt\" func main ( ) { // 初始化一个整数数组，在下标1号和3号位置写入： 1 5 a := [ ... ] int { 1 : 1 , 3 : 5 } fmt . Println ( a ) // [0 1 0 5] fmt . Printf ( \"type of a:%T\\n\" , a ) //type of a:[4]int } #03.数组的遍历 #3.1 普通遍历数组 package main import \"fmt\" func main ( ) { var a = [ ... ] string { \"北京\" , \"上海\" , \"深圳\" } for i := 0 ; i #3.2 k,v遍历数组 package main import \"fmt\" func main ( ) { var a = [ ... ] string { \"北京\" , \"上海\" , \"深圳\" } for index , value := range a { fmt . Println ( index , value ) } } /* 0 北京 1 上海 2 深圳 */ #04.多维数组 #4.1 定义多维数组 package main import \"fmt\" func main ( ) { a := [ 3 ] [ 2 ] string { { \"北京\" , \"上海\" } , { \"广州\" , \"深圳\" } , { \"成都\" , \"重庆\" } , } fmt . Println ( a ) //[[北京 上海] [广州 深圳] [成都 重庆]] fmt . Println ( a [ 2 ] [ 1 ] ) //支持索引取值:重庆 } #4.2 遍历多维数组 package main import \"fmt\" func main ( ) { a := [ 3 ] [ 2 ] string { { \"北京\" , \"上海\" } , { \"广州\" , \"深圳\" } , { \"成都\" , \"重庆\" } , } for _ , v1 := range a { // v1 = [北京 上海] for _ , v2 := range v1 { fmt . Println ( v2 ) } } } /* 北京 上海 广州 深圳 成都 重庆 */ #05.数组练习 #5.1 数组求和 package main import \"fmt\" func main ( ) { var intArr2 [ 5 ] int = [ ... ] int { 1 , - 1 , 9 , 90 , 12 } sum := 0 for _ , val := range intArr2 { //累计求和 sum += val } //如何让平均值保留到小数. fmt . Printf ( \"sum=%v 平均值=%v \\n\\n\" , sum , float64 ( sum ) / float64 ( len ( intArr2 ) ) ) // sum=111 平均值=22.2 } #5.2 数组最大值 1、声明一个数组 var intArr[5] = [...]int {1, -1, 12, 65, 11} 2、假定第一个元素就是最大值，下标就 0 3、然后从第二个元素开始循环比较，如果发现有更大，则交换 package main import \"fmt\" func main ( ) { var intArr = [ ... ] int { 1 , - 1 , 112 , 65 , 11 } maxValue := intArr [ 0 ] maxIndex := 0 for i := 0 ; i console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"shu-ju-lei-xing/bu-er-zhi.html":{"url":"shu-ju-lei-xing/bu-er-zhi.html","title":"布尔值","keywords":"","body":"布尔值布尔值 Go 语言中以 bool 类型进行声明布尔型数据，布尔型数据只有 true（真）和 false（假）两个值。 注意： 1.布尔类型变量的默认值为 false。2.Go 语言中不允许将整型强制转换为布尔型.3.布尔型无法参与数值运算，也无法与其他类型进行转换。 package main import ( \"fmt\" \"unsafe\" ) func main() { var b = true fmt.Println(b, \"占用字节：\", unsafe.Sizeof(b)) // true 占用字节： 1 } console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"}}