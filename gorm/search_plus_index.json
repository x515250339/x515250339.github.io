{"./":{"url":"./","title":"Introduction","keywords":"","body":"原文：https://learnku.com/docs/gorm/v2/about-mirror-image/9754 本文github地址(作者亲写): https://github.com/515250339/gin_exercise/tree/develop/src/GORMProject console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"qian-yan.html":{"url":"qian-yan.html","title":"前言","keywords":"","body":" console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"qian-yan/jing-xiang.html":{"url":"qian-yan/jing-xiang.html","title":"镜像","keywords":"","body":" 关于镜像 关于镜像 镜像由来 本文档是 GORM 官方文档 的完整镜像。 官方文档托管于 GitHub Page，偶尔会出现网络不稳定的情况，应社区用户要求，做了这份镜像。 除了访问速度，LearnKu 上关键知识点的标记功能，允许你在阅读时做笔记，方便通读整个文档时使用： console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"qian-yan/v1yu-v2.html":{"url":"qian-yan/v1yu-v2.html","title":"V1与V2","keywords":"","body":" V1 与 V2 V1 与 V2 GORM 于 2020 年 8 月 30 号发布了 V2 版本，Git Tag 为 v1.20.0。 新手学习 GORM 时容易掉入以下的坑： 不区分 V1 和 V2 —— V2 做了很多改进，很多用法与 V1 不兼容，需要重新学习一边文档（请见 更新日志《GORM 中文文档》 ）； 误以为 V2 版本的 Git Tag 是 2.x ，其实是 v1.20.0。 不知项目维护方为何以 v1.20.x 来为 V2 打标签，有知道的同学请提交改进。 作为使用者，推荐使用 V2 版本，维护更加活跃、Bug 也会更加快的被修复。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"qian-yan/gorm20fa-bu-shuo-ming.html":{"url":"qian-yan/gorm20fa-bu-shuo-ming.html","title":"GORM2.0发布说明","keywords":"","body":" GORM 2.0 发布说明v21. 如何升级1.1. 安装1.2. 快速开始2. 主要特性3. 破坏性变更 GORM 2.0 发布说明v2 GORM 2.0 完全从零开始，引入了一些不兼容的 API 变更和许多改进 摘要 性能改进 代码模块化 Context，批量插入，预编译模式，DryRun 模式，Join 预加载，Find To Map，Create From Map，FindInBatches 支持 支持嵌套事务，SavePoint，Rollback To SavePoint SQL 生成器，命名参数，分组条件，Upsert，锁， 支持 Optimizer/Index/Comment Hint，子查询改进，使用 SQL 表达式、Context Valuer 进行 CRUD 支持完整的自引用，改进 Join Table，批量数据的关联模式 允许多个字段用于追踪 create、update 时间 ，支持 UNIX （毫 / 纳）秒 支持字段权限：只读、只写、只创建、只更新、忽略 新的插件系统，为多个数据库提供了官方插件，读写分离，prometheus 集成… 全新的 Hook API：带插件的统一接口 全新的 Migrator：允许为关系创建数据库外键，更智能的 AutoMigrate，支持约束、检查器，增强索引支持 全新的 Logger：支持 context、改进可扩展性 统一命名策略：表名、字段名、连接表名、外键、检查器、索引名称规则 更好的自定义类型支持（例如： JSON） 1. 如何升级 GORM 的开发已经迁移至 github.com/go-gorm，import 路径也修改为 gorm.io/gorm ，对于以前的项目，您可以继续使用 github.com/jinzhu/gorm 和 GORM V1 文档 数据库驱动被拆分为独立的项目，例如：github.com/go-gorm/sqlite，且它的 import 路径也变更为 gorm.io/driver/sqlite 1.1. 安装 go get gorm.io/gorm // **注意** GORM `v2.0.0` 发布的 git tag 是 `v1.20.0` 1.2. 快速开始 import ( \"gorm.io/gorm\" \"gorm.io/driver/sqlite\" ) func init() { db, err := gorm.Open(sqlite.Open(\"gorm.db\"), &gorm.Config{}) // 大部分 CRUD API 都是兼容的 db.AutoMigrate(&Product{}) db.Create(&user) db.First(&user, 1) db.Model(&user).Update(\"Age\", 18) db.Model(&user).Omit(\"Role\").Updates(map[string]interface{}{\"Name\": \"jinzhu\", \"Role\": \"admin\"}) db.Delete(&user) } 2. 主要特性 此发布说明仅涵盖了 GORM V2 中的重大更改，作为快速参考 Context 支持 通过 WithContext 方法提供 context.Context 支持 Logger 也支持用于追踪的 context db.WithContext(ctx).Find(&users) 批量插入 要有效地插入大量记录，可以将一个 slice 传递给 Create 方法。 将切片数据传递给 Create 方法，GORM 将生成一个单一的 SQL 语句来插入所有数据，并回填主键的值，钩子方法也会被调用。 var users = []User{ {Name: \"jinzhu1\"}, {Name: \"jinzhu2\"}, {Name: \"jinzhu3\"}, } db.Create(&users) for _, user := range users { user.ID // 1,2,3 } 使用 CreateInBatches 创建时，你还可以指定创建的数量，例如： var 用户 = []User{name: \"jinzhu_1\"}, ...., {Name: \"jinzhu_10000\"}} // 数量为 100 db.CreateInBatches(用户, 100) 预编译模式 预编译模式会预编译 Sql 执行语句，以加速后续执行速度 // 全局模式，所有的操作都会创建并缓存预编译语句，以加速后续执行速度 db, err := gorm.Open(sqlite.Open(\"gorm.db\"), &gorm.Config{PrepareStmt: true}) // 会话模式，当前会话中的操作会创建并缓存预编译语句 tx := db.Session(&Session{PrepareStmt: true}) tx.First(&user, 1) tx.Find(&users) tx.Model(&user).Update(\"Age\", 18) DryRun 模式 DarRun 模式会生成但不执行 SQL，可以用于检查、测试生成的 SQL stmt := db.Session(&Session{DryRun: true}).Find(&user, 1).Statement stmt.SQL.String() //=> SELECT * FROM `users` WHERE `id` = $1 // PostgreSQL stmt.SQL.String() //=> SELECT * FROM `users` WHERE `id` = ? // MySQL stmt.Vars //=> []interface{}{1} Joins 预加载 使用 INNER JOIN 预加载关联，并处理 null 数据避免 scan 失败 db.Joins(\"Company\").Joins(\"Manager\").Joins(\"Account\").Find(&users, \"users.id IN ?\", []int{1,2}) Find To Map Scan 结果到 map[string]interface{} 或 []map[string]interface{} var result map[string]interface{} db.Model(&User{}).First(&result, \"id = ?\", 1) Create From Map 根据 map[string]interface{} 或 []map[string]interface{} Create db.Model(&User{}).Create(map[string]interface{}{\"Name\": \"jinzhu\", \"Age\": 18}) datas := []map[string]interface{}{ {\"Name\": \"jinzhu_1\", \"Age\": 19}, {\"name\": \"jinzhu_2\", \"Age\": 20}, } db.Model(&User{}).Create(datas) FindInBatches 用于批量查询并处理记录 result := db.Where(\"age>?\", 13).FindInBatches(&results, 100, func(tx *gorm.DB, batch int) error { // 批量处理 return nil }) 嵌套事务 db.Transaction(func(tx *gorm.DB) error { tx.Create(&user1) tx.Transaction(func(tx2 *gorm.DB) error { tx.Create(&user2) return errors.New(\"rollback user2\") // rollback user2 }) tx.Transaction(func(tx2 *gorm.DB) error { tx.Create(&user3) return nil }) return nil // commit user1 and user3 }) SavePoint，RollbackTo tx := db.Begin() tx.Create(&user1) tx.SavePoint(\"sp1\") tx.Create(&user2) tx.RollbackTo(\"sp1\") // rollback user2 tx.Commit() // commit user1 命名参数 GORM 支持使用 sql.NamedArg，map[string]interface{} 作为命名参数 db.Where(\"name1 = @name OR name2 = @name\", sql.Named(\"name\", \"jinzhu\")).Find(&user) // SELECT * FROM `users` WHERE name1 = \"jinzhu\" OR name2 = \"jinzhu\" db.Where(\"name1 = @name OR name2 = @name\", map[string]interface{}{\"name\": \"jinzhu2\"}).First(&result3) // SELECT * FROM `users` WHERE name1 = \"jinzhu2\" OR name2 = \"jinzhu2\" ORDER BY `users`.`id` LIMIT 1 db.Raw( \"SELECT * FROM users WHERE name1 = @name OR name2 = @name2 OR name3 = @name\", sql.Named(\"name\", \"jinzhu1\"), sql.Named(\"name2\", \"jinzhu2\"), ).Find(&user) // SELECT * FROM users WHERE name1 = \"jinzhu1\" OR name2 = \"jinzhu2\" OR name3 = \"jinzhu1\" db.Exec( \"UPDATE users SET name1 = @name, name2 = @name2, name3 = @name\", map[string]interface{}{\"name\": \"jinzhu\", \"name2\": \"jinzhu2\"}, ) // UPDATE users SET name1 = \"jinzhu\", name2 = \"jinzhu2\", name3 = \"jinzhu\" 分组条件 db.Where( db.Where(\"pizza = ?\", \"pepperoni\").Where(db.Where(\"size = ?\", \"small\").Or(\"size = ?\", \"medium\")), ).Or( db.Where(\"pizza = ?\", \"hawaiian\").Where(\"size = ?\", \"xlarge\"), ).Find(&pizzas) // SELECT * FROM pizzas WHERE (pizza = 'pepperoni' AND (size = 'small' OR size = 'medium')) OR (pizza = 'hawaiian' AND size = 'xlarge') 子查询 // Where 子查询 db.Where(\"amount > (?)\", db.Table(\"orders\").Select(\"AVG(amount)\")).Find(&orders) // From 子查询 db.Table(\"(?) as u\", db.Model(&User{}).Select(\"name\", \"age\")).Where(\"age = ?\", 18}).Find(&User{}) // SELECT * FROM (SELECT `name`,`age` FROM `users`) as u WHERE age = 18 // Update 子查询 db.Model(&user).Update( \"price\", db.Model(&Company{}).Select(\"name\").Where(\"companies.id = users.company_id\"), ) Upsert clause.OnConflict 为不同的数据库（SQLite，MySQL，PostgreSQL，SQL Server）提供了兼容的 Upsert 支持 import \"gorm.io/gorm/clause\" db.Clauses(clause.OnConflict{DoNothing: true}).Create(&users) db.Clauses(clause.OnConflict{ Columns: []clause.Column{ {Name: \"id\"}, }, DoUpdates: clause.Assignments(map[string]interface{}{\"name\": \"jinzhu\", \"age\": 18}), }).Create(&users) // MERGE INTO \"users\" USING *** WHEN NOT MATCHED THEN INSERT *** WHEN MATCHED THEN UPDATE SET ***; SQL Server // INSERT INTO `users` *** ON DUPLICATE KEY UPDATE name=\"jinzhu\", age=18; MySQL db.Clauses(clause.OnConflict{ Columns: []clause.Column{ {Name: \"id\"}, }, DoUpdates: clause.AssignmentColumns([]string{\"name\", \"age\"}), }).Create(&users) // MERGE INTO \"users\" USING *** WHEN NOT MATCHED THEN INSERT *** WHEN MATCHED THEN UPDATE SET \"name\"=\"excluded\".\"name\"; SQL Server // INSERT INTO \"users\" *** ON CONFLICT (\"id\") DO UPDATE SET \"name\"=\"excluded\".\"name\", \"age\"=\"excluded\".\"age\"; PostgreSQL // INSERT INTO `users` *** ON DUPLICATE KEY UPDATE `name`=VALUES(name),`age=VALUES(age); MySQL Copy Locking db.Clauses(clause.Locking{Strength: \"UPDATE\"}).Find(&users) // SELECT * FROM `users` FOR UPDATE db.Clauses(clause.Locking{ Strength: \"SHARE\", Table: clause.Table{Name: clause.CurrentTable}, }).Find(&users) // SELECT * FROM `users` FOR SHARE OF `users` Optimizer/Index/Comment Hint import \"gorm.io/hints\" // Optimizer Hints db.Clauses(hints.New(\"hint\")).Find(&User{}) // SELECT * /*+ hint */ FROM `users` // Index Hints db.Clauses(hints.UseIndex(\"idx_user_name\")).Find(&User{}) // SELECT * FROM `users` USE INDEX (`idx_user_name`) // Comment Hints db.Clauses(hints.Comment(\"select\", \"master\")).Find(&User{}) // SELECT /*master*/ * FROM `users`; 查看 Hint 获取详情 使用 SQL 表达式、Context Valuer 进行 CRUD type Location struct { X, Y int } func (loc Location) GormDataType() string { return \"geometry\" } func (loc Location) GormValue(ctx context.Context, db *gorm.DB) clause.Expr { return clause.Expr{ SQL: \"ST_PointFromText(?)\", Vars: []interface{}{fmt.Sprintf(\"POINT(%d %d)\", loc.X, loc.Y)}, } } db.Create(&User{ Name: \"jinzhu\", Location: Location{X: 100, Y: 100}, }) // INSERT INTO `users` (`name`,`point`) VALUES (\"jinzhu\",ST_PointFromText(\"POINT(100 100)\")) db.Model(&User{ID: 1}).Updates(User{ Name: \"jinzhu\", Point: Point{X: 100, Y: 100}, }) // UPDATE `user_with_points` SET `name`=\"jinzhu\",`point`=ST_PointFromText(\"POINT(100 100)\") WHERE `id` = 1 查看 自定义数据类型 获取详情 字段权限 支持字段权限，权限级别有：只读、只写、只创建、只更新、忽略 type User struct { Name string `gorm:\":false;\"` // 只读 Name string `gorm:\"-\"` // 忽略 } 支持多个字段追踪 create/update 时间（ time、unix (毫 / 纳) 秒） type User struct { CreatedAt time.Time // 在创建时，如果该字段值为零值，则使用当前时间填充 UpdatedAt int // 在创建时该字段值为零值或者在更新时，使用当前时间戳的秒数填充 Updated int64 `gorm:\"autoUpdateTime:nano\"` // 使用时间戳的纳秒数填充更新时间 Updated2 int64 `gorm:\"autoUpdateTime:milli\"` // 使用时间戳的毫秒数填充更新时间 Created int64 `gorm:\"autoCreateTime\"` // 使用时间戳的秒数填充创建时间 } 多数据库，读写分离 GORM 通过 DB Resolver 插件提供了多数据库，读写分离支持。该插件还支持基于当前 struct 和表自动切换数据库和表，自定义负载均衡逻辑的多 source、replica 查看 Database Resolver 获取详情 Prometheus GORM 提供了 Prometheus 插件来收集 DBStats 和用户自定义指标 查看 Prometheus 获取详情 命名策略 GORM 允许用户通过覆盖默认的命名策略更改默认的命名约定，命名策略被用于构建： TableName、ColumnName、JoinTableName、RelationshipFKName、CheckerName、IndexName。查看 GORM 配置 获取详情 db, err := gorm.Open(sqlite.Open(\"gorm.db\"), &gorm.Config{ NamingStrategy: schema.NamingStrategy{TablePrefix: \"t_\", SingularTable: true}, }) Logger Context 支持 自定义或关闭日志的颜色 慢 SQL 日志，慢 SQL 默认阈值是 100ms 优化了 SQL 日志格式，可以更方便的复制到数据库控制台中执行 事务模式 默认情况下，GORM 所有的写操作都会在事务中运行，以确保数据的一致性。 如果不需要，您可以在初始化时禁用它来加速写入操作 db, err := gorm.Open(sqlite.Open(\"gorm.db\"), &gorm.Config{ SkipDefaultTransaction: true, }) 数据类型（以 JSON 为例） GORM 优化了对自定义类型的支持，现在您可以定义一个 struct 来支持所有类型的数据库 下面以 JSON 为例（支持 SQLite、MySQL、Postgres。参考自：https://github.com/go-gorm/datamypes/blob/master/json.go） import \"gorm.io/datatypes\" type User struct { gorm.Model Name string Attributes datatypes.JSON } db.Create(&User{ Name: \"jinzhu\", Attributes: datatypes.JSON([]byte(`{\"name\": \"jinzhu\", \"age\": 18, \"tags\": [\"tag1\", \"tag2\"], \"orgs\": {\"orga\": \"orga\"}}`)), } // 查询 attributes 中有 role 字段的 user db.First(&user, datatypes.JSONQuery(\"attributes\").HasKey(\"role\")) // 查询 attributes 中有 orgs->orga 字段的 user db.First(&user, datatypes.JSONQuery(\"attributes\").HasKey(\"orgs\", \"orga\")) Smart Select GORM 可以通过 Select 选择指定的字段，而在 V2 中，通过一个较小的 struct，可以使用 GORM 提供的 smart select 模式 type User struct { ID uint Name string Age int Gender string // 假设后面还有几百个字段... } type APIUser struct { ID uint Name string } // 查询时会自动选择 `id`, `name` 字段 db.Model(&User{}).Limit(10).Find(&APIUser{}) // SELECT `id`, `name` FROM `users` LIMIT 10 批量关联模式 关联模式也支持批量处理，例如： // 查询所有用户的所有角色 db.Model(&users).Association(\"Role\").Find(&roles) // 将 userA 从所有的 Team 中移除 db.Model(&users).Association(\"Team\").Delete(&userA) // 获取所有 Team 成员的不重复计数 db.Model(&users).Association(\"Team\").Count() // 对于 `Append`、`Replace` 的批量处理，参数与数据的长度必须相等，否则会返回错误 var users = []User{user1, user2, user3} // 例如：我们有 3 个 user，将 userA 添加到 user1 的 Team，将 userB 添加到 user2 的 Team，将 userA、userB、userC 添加到 user3 的 Team db.Model(&users).Association(\"Team\").Append(&userA, &userB, &[]User{userA, userB, userC}) // 将 user1 的 Team 重置为 userA，将 user2的 team 重置为 userB，将 user3 的 team 重置为 userA、userB 和 userC db.Model(&users).Association(\"Team\").Replace(&userA, &userB, &[]User{userA, userB, userC}) 删除关联记录 你可以在删除记录时通过 Select 来删除具有 has one、has many、many2many 关系的记录，例如： // 删除 user 时，也删除 user 的 account db.Select(\"Account\").Delete(&user) // 删除 user 时，也删除 user 的 Orders、CreditCards 记录 db.Select(\"Orders\", \"CreditCards\").Delete(&user) // 删除 user 时，也删除用户所有 has one/many、many2many 记录 db.Select(clause.Associations).Delete(&user) // 删除 users 时，也删除 user 们的 account db.Select(\"Account\").Delete(&users) 3. 破坏性变更 我们尽可能的列出破坏性、无法被编译器捕获的变更。如果您发现了任何遗漏的内容，欢迎在 这里 创建 issue 或 pr Tag GORM V2 使用 camelCase 风格的 tag 名。snake_case 风格的 tag 已经失效，例如： auto_increment、unique_index、polymorphic_value、embeded_prefix，查看 Model Tag 获取详情 用于指定外键的 tag 已变更为 foreignKey，references，查看 Association Tag 获取详情 Table Name TableName 不再 允许动态表名， 因为 TableName 的返回值会被缓存下来 func (User) TableName() string { return \"t_user\" } 动态表名请使用 Scopes，例如： func UserTable(u *User) func(*gorm.DB) *gorm.DB { return func(db *gorm.DB) *gorm.DB { return db.Table(\"user_\" + u.Role) } } db.Scopes(UserTable(&user)).Create(&user) 方法链和协程安全 为了减少 GC 分配，在使用链式调用时，GORM V2 会共享 Statement，且只在初始化 *gorm.DB 或调用 New Session Method 后创建新的 Statement。想要复用 *gorm.DB，您需要确保该它刚调用过 New Session Method，例如： db, err := gorm.Open(sqlite.Open(\"test.db\"), &gorm.Config{}) // 对于刚初始化的 *gorm.DB 是安全的 for i := 0; i 查看 方法链 获取详情 默认值 创建记录后，GORM V2 不会自动加载由数据库生成的默认值，查看 默认值 获取详情 软删除 在 GORM V1 中，如果 model 中有一个名为 DeletedAt 的字段则自动开启软删除。在 V2，您需要在想启用软删除的 model 中使用 gorm.DeletedAt，例如： type User struct { ID uint DeletedAt gorm.DeletedAt } type User struct { ID uint // 字段名无要求 Deleted gorm.DeletedAt } 注意： gorm.Model 使用了 gorm.DeletedAt，如果你已经嵌入了它，则不需要做什么修改 BlockGlobalUpdate GORM V2 默认启用了 BlockGlobalUpdate 模式。想要触发全局 update/delete，你必须使用一些条件、原生 SQL 或者启用 AllowGlobalUpdate 模式，例如： db.Where(\"1 = 1\").Delete(&User{}) db.Raw(\"delete from users\") db.Session(&gorm.Session{AllowGlobalUpdate: true}).Delete(&User{}) ErrRecordNotFound GORM V2 只有在你使用 First、Last、Take 这些预期会返回结果的方法查询记录时，才会返回 ErrRecordNotFound，我们还移除了 RecordNotFound 方法，请使用 errors.Is 来检查错误，例如： err := db.First(&user).Error errors.Is(err, gorm.ErrRecordNotFound) Hook 方法 在 V2 中，Before/After Create/Update/Save/Find/Delete 必须定义为 func(tx *gorm.DB) error 类型的方法，这是类似于插件 callback 的统一接口。如果定义为其它类型，它不会生效，并且会打印一个警告日志，查看 Hook 获取详情 func (user *User) BeforeCreate(tx *gorm.DB) error { // 通过 tx.Statement 修改当前操作，例如： tx.Statement.Select(\"Name\", \"Age\") tx.Statement.AddClause(clause.OnConflict{DoNothing: true}) // 除了当前子句，基于 tx 的操作会运行在同一个事务中 var role Role err := tx.First(&role, \"name = ?\", user.Role).Error // SELECT * FROM roles WHERE name = \"admin\" return err } Update Hook 支持 Changed 当使用 Update，Updates 更新时，您可以在 BeforeUpdate, BeforeSave Hook 中使用 Changed 方法来检查字段是否有更改 func (user *User) BeforeUpdate(tx *gorm.DB) error { if tx.Statement.Changed(\"Name\", \"Admin\") { // if Name or Admin changed tx.Statement.SetColumn(\"Age\", 18) } if tx.Statement.Changed() { // 如果任何字段有变动 tx.Statement.SetColumn(\"Age\", 18) } return nil } db.Model(&user).Update(\"Name\", \"Jinzhu\") // update field `Name` to `Jinzhu` db.Model(&user).Updates(map[string]interface{}{\"name\": \"Jinzhu\", \"admin\": false}) // update field `Name` to `Jinzhu`, `Admin` to false db.Model(&user).Updates(User{Name: \"Jinzhu\", Admin: false}) // Update none zero fields when using struct as argument, will only update `Name` to `Jinzhu` db.Model(&user).Select(\"Name\", \"Admin\").Updates(User{Name: \"Jinzhu\"}) // update selected fields `Name`, `Admin`，`Admin` will be updated to zero value (false) db.Model(&user).Select(\"Name\", \"Admin\").Updates(map[string]interface{}{\"Name\": \"Jinzhu\"}) // update selected fields exists in the map, will only update field `Name` to `Jinzhu` // Attention: `Changed` will only check the field value of `Update` / `Updates` equals `Model`'s field value, it returns true if not equal and the field will be saved db.Model(&User{ID: 1, Name: \"jinzhu\"}).Updates(map[string]interface{\"name\": \"jinzhu2\"}) // Changed(\"Name\") => true db.Model(&User{ID: 1, Name: \"jinzhu\"}).Updates(map[string]interface{\"name\": \"jinzhu\"}) // Changed(\"Name\") => false, `Name` not changed db.Model(&User{ID: 1, Name: \"jinzhu\"}).Select(\"Admin\").Updates(map[string]interface{\"name\": \"jinzhu2\", \"admin\": false}) // Changed(\"Name\") => false, `Name` not selected to update db.Model(&User{ID: 1, Name: \"jinzhu\"}).Updates(User{Name: \"jinzhu2\"}) // Changed(\"Name\") => true db.Model(&User{ID: 1, Name: \"jinzhu\"}).Updates(User{Name: \"jinzhu\"}) // Changed(\"Name\") => false, `Name` not changed db.Model(&User{ID: 1, Name: \"jinzhu\"}).Select(\"Admin\").Updates(User{Name: \"jinzhu2\"}) // Changed(\"Name\") => false, `Name` not selected to update 插件 插件 callback 也需要被定义为 func(tx *gorm.DB) error 类型的方法，查看 Write Plugins 获取详情 使用 struct 更新 使用 struct 更新时，GORM V2 允许使用 Select 来选择要更新的零值字段，例如： db.Model(&user).Select(\"Role\", \"Age\").Update(User{Name: \"jinzhu\", Role: \"\", Age: 0}) 关联 GORM V1 允许使用一些设置来跳过 create/update 关联。在 V2 中，您可以使用 Select 来完成这项工作，例如： db.Omit(clause.Associations).Create(&user) db.Omit(clause.Associations).Save(&user) db.Select(\"Company\").Save(&user) 此外，GORM V2 不再允许通过 Set(\"gorm:auto_preload\", true) 进行预加载，你可以将 Preload 和 clause.Associations 配合使用，例如： // 预加载所有关联 db.Preload(clause.Associations).Find(&users) 此外，还可以查看字段权限，它可以用来全局跳过 creating/updating 关联 在创建、更新记录时，GORM V2 将使用 upsert 来保存关联记录。不会再保存完整的关联数据，避免受未完成数据的影响，以保护您的数据，例如： user := User{ Name: \"jinzhu\", BillingAddress: Address{Address1: \"Billing Address - Address 1\"}, ShippingAddress: Address{Address1: \"Shipping Address - Address 1\"}, Emails: []Email{ {Email: \"jinzhu@example.com\"}, {Email: \"jinzhu-2@example.com\"}, }, Languages: []Language{ {Name: \"ZH\"}, {Name: \"EN\"}, }, } db.Create(&user) // BEGIN TRANSACTION; // INSERT INTO \"addresses\" (address1) VALUES (\"Billing Address - Address 1\"), (\"Shipping Address - Address 1\") ON DUPLICATE KEY DO NOTHING; // INSERT INTO \"users\" (name,billing_address_id,shipping_address_id) VALUES (\"jinzhu\", 1, 2); // INSERT INTO \"emails\" (user_id,email) VALUES (111, \"jinzhu@example.com\"), (111, \"jinzhu-2@example.com\") ON DUPLICATE KEY DO NOTHING; // INSERT INTO \"languages\" (\"name\") VALUES ('ZH'), ('EN') ON DUPLICATE KEY DO NOTHING; // INSERT INTO \"user_languages\" (\"user_id\",\"language_id\") VALUES (111, 1), (111, 2) ON DUPLICATE KEY DO NOTHING; // COMMIT; Join Table 在 GORM V2 中，JoinTable 可以是一个带有 软删除、Hook 且定义了其它字段的全功能 model，例如： type Person struct { ID int Name string Addresses []Address `gorm:\"many2many:person_addresses;\"` } type Address struct { ID uint Name string } type PersonAddress struct { PersonID int AddressID int CreatedAt time.Time DeletedAt gorm.DeletedAt } func (PersonAddress) BeforeCreate(db *gorm.DB) error { // ... } // PersonAddress 必须定义好所需的外键，否则会报错 err := db.SetupJoinTable(&Person{}, \"Addresses\", &PersonAddress{}) 然后，您可以使用标准的 GORM 方法来操作连接表的数据，例如： var results []PersonAddress db.Where(\"person_id = ?\", person.ID).Find(&results) db.Where(\"address_id = ?\", address.ID).Delete(&PersonAddress{}) db.Create(&PersonAddress{PersonID: person.ID, AddressID: address.ID}) Count Count 仅支持 *int64 作为参数 事务 移除了 RollbackUnlessCommitted 之类的事务方法，建议使用 Transaction 方法包裹事务 db.Transaction(func(tx *gorm.DB) error { // 在事务中执行一些 db 操作（从这里开始，您应该使用 'tx' 而不是 'db'） if err := tx.Create(&Animal{Name: \"Giraffe\"}).Error; err != nil { // 返回任何错误都会回滚事务 return err } if err := tx.Create(&Animal{Name: \"Lion\"}).Error; err != nil { return err } // 返回 nil 提交事务 return nil }) 查看 事务 获取详情 Migrator Migrator 默认会创建数据库外键 Migrator 更加独立，重命名了很多 API，以便使用统一 API 接口为每个数据库提供更好的支持 如果大小、精度、是否为空可以更改，则 AutoMigrate 会改变列的类型 通过 check 标签支持检查器 增强 index 标签的设置 查看 Migration 获取详情 type UserIndex struct { Name string `gorm:\"check:named_checker,(name <> 'jinzhu')\"` Name2 string `gorm:\"check:(age > 13)\"` Name4 string `gorm:\"index\"` Name5 string `gorm:\"index:idx_name,unique\"` Name6 string `gorm:\"index:,sort:desc,collate:utf8,type:btree,length:10,where:name3 != 'jinzhu'\"` } console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"ru-men-zhi-nan.html":{"url":"ru-men-zhi-nan.html","title":"入门指南","keywords":"","body":" console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"ru-men-zhi-nan/gorm-zhi-nan.html":{"url":"ru-men-zhi-nan/gorm-zhi-nan.html","title":"GORM 指南","keywords":"","body":" GORM 指南v21. 特性2. 安装3. 快速入门 GORM 指南v2 一个神奇的，对开发人员友好的 Golang ORM 库 1. 特性 全功能 ORM 关联 (Has One，Has Many，Belongs To，Many To Many，多态，单表继承) Create，Save，Update，Delete，Find 中钩子方法 支持 Preload、Joins 的预加载 事务，嵌套事务，Save Point，Rollback To Saved Point Context，预编译模式，DryRun 模式 批量插入，FindInBatches，Find/Create with Map，使用 SQL 表达式、Context Valuer 进行 CRUD SQL 构建器，Upsert，数据库锁，Optimizer/Index/Comment Hint，命名参数，子查询 复合主键，索引，约束 Auto Migration 自定义 Logger 灵活的可扩展插件 API：Database Resolver（多数据库，读写分离）、Prometheus… 每个特性都经过了测试的重重考验 开发者友好 2. 安装 go get -u gorm.io/gorm go get -u gorm.io/driver/sqlite 3. 快速入门 package main import ( \"gorm.io/gorm\" \"gorm.io/driver/sqlite\" ) type Product struct { gorm.Model Code string Price uint } func main() { db, err := gorm.Open(sqlite.Open(\"test.db\"), &gorm.Config{}) if err != nil { panic(\"failed to connect database\") } // 迁移 schema db.AutoMigrate(&Product{}) // Create db.Create(&Product{Code: \"D42\", Price: 100}) // Read var product Product db.First(&product, 1) // 根据整形主键查找 db.First(&product, \"code = ?\", \"D42\") // 查找 code 字段值为 D42 的记录 // Update - 将 product 的 price 更新为 200 db.Model(&product).Update(\"Price\", 200) // Update - 更新多个字段 db.Model(&product).Updates(Product{Price: 200, Code: \"F42\"}) // 仅更新非零值字段 db.Model(&product).Updates(map[string]interface{}{\"Price\": 200, \"Code\": \"F42\"}) // Delete - 删除 product db.Delete(&product, 1) } console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"ru-men-zhi-nan/mo-xing-ding-yi.html":{"url":"ru-men-zhi-nan/mo-xing-ding-yi.html","title":"模型定义","keywords":"","body":" 模型定义v21. 模型定义2. 约定3. gorm.Model4. 高级选项4.1. 字段级权限控制4.2. 创建 / 更新时间追踪（纳秒、毫秒、秒、Time）4.3. 嵌入结构体4.4. 字段标签4.5. 关联标签 模型定义v2 1. 模型定义 模型是标准的 struct，由 Go 的基本数据类型、实现了 Scanner 和 Valuer 接口的自定义类型及其指针或别名组成 例如： type User struct { ID uint Name string Email *string Age uint8 Birthday *time.Time MemberNumber sql.NullString ActivedAt sql.NullTime CreatedAt time.Time UpdatedAt time.Time } 2. 约定 GORM 倾向于约定，而不是配置。默认情况下，GORM 使用 ID 作为主键，使用结构体名的 蛇形复数 作为表名，字段名的 蛇形 作为列名，并使用 CreatedAt、UpdatedAt 字段追踪创建、更新时间 遵循 GORM 已有的约定，可以减少您的配置和代码量。如果约定不符合您的需求，GORM 允许您自定义配置它们 3. gorm.Model GORM 定义一个 gorm.Model 结构体，其包括字段 ID、CreatedAt、UpdatedAt、DeletedAt // gorm.Model 的定义 type Model struct { ID uint `gorm:\"primaryKey\"` CreatedAt time.Time UpdatedAt time.Time DeletedAt gorm.DeletedAt `gorm:\"index\"` } 您可以将它嵌入到您的结构体中，以包含这几个字段，详情请参考 嵌入结构体 4. 高级选项 4.1. 字段级权限控制 可导出的字段在使用 GORM 进行 CRUD 时拥有全部的权限，此外，GORM 允许您用标签控制字段级别的权限。这样您就可以让一个字段的权限是只读、只写、只创建、只更新或者被忽略 注意： 使用 GORM Migrator 创建表时，不会创建被忽略的字段 type User struct { Name string `gorm:\"\"` // 只读（除非有自定义配置，否则禁止写） Name string `gorm:\"->;:false; 4.2. 创建 / 更新时间追踪（纳秒、毫秒、秒、Time） GORM 约定使用 CreatedAt、UpdatedAt 追踪创建 / 更新时间。如果您定义了这种字段，GORM 在创建、更新时会自动填充 当前时间 要使用不同名称的字段，您可以配置 autoCreateTim、autoUpdateTim 标签 如果您想要保存 UNIX（毫 / 纳）秒时间戳，而不是 time，您只需简单地将 time.Time 修改为 int 即可 type User struct { CreatedAt time.Time // 在创建时，如果该字段值为零值，则使用当前时间填充 UpdatedAt int // 在创建时该字段值为零值或者在更新时，使用当前时间戳秒数填充 Updated int64 `gorm:\"autoUpdateTime:nano\"` // 使用时间戳填纳秒数充更新时间 Updated int64 `gorm:\"autoUpdateTime:milli\"` // 使用时间戳毫秒数填充更新时间 Created int64 `gorm:\"autoCreateTime\"` // 使用时间戳秒数填充创建时间 } 4.3. 嵌入结构体 对于匿名字段，GORM 会将其字段包含在父结构体中，例如： type User struct { gorm.Model Name string } // 等效于 type User struct { ID uint `gorm:\"primaryKey\"` CreatedAt time.Time UpdatedAt time.Time DeletedAt gorm.DeletedAt `gorm:\"index\"` Name string } 对于正常的结构体字段，你也可以通过标签 embedded 将其嵌入，例如： type Author struct { Name string Email string } type Blog struct { ID int Author Author `gorm:\"embedded\"` Upvotes int32 } // 等效于 type Blog struct { ID int64 Name string Email string Upvotes int32 } 并且，您可以使用标签 embeddedPrefix 来为 db 中的字段名添加前缀，例如： type Blog struct { ID int Author Author `gorm:\"embedded;embeddedPrefix:author_\"` Upvotes int32 } // 等效于 type Blog struct { ID int64 AuthorName string AuthorEmail string Upvotes int32 } 4.4. 字段标签 声明 model 时，tag 是可选的，GORM 支持以下 tag： tag 名大小写不敏感，但建议使用 camelCase 风格 标签名 说明 column 指定 db 列名 type 列数据类型，推荐使用兼容性好的通用类型，例如：所有数据库都支持 bool、int、uint、float、string、time、bytes 并且可以和其他标签一起使用，例如：not null、size, autoIncrement… 像 varbinary(8) 这样指定数据库数据类型也是支持的。在使用指定数据库数据类型时，它需要是完整的数据库数据类型，如：MEDIUMINT UNSIGNED not NULL AUTO_INSTREMENT size 指定列大小，例如：size:256 primaryKey 指定列为主键 unique 指定列为唯一 default 指定列的默认值 precision 指定列的精度 scale 指定列大小 not null 指定列为 NOT NULL autoIncrement 指定列为自动增长 embedded 嵌套字段 embeddedPrefix 嵌入字段的列名前缀 autoCreateTime 创建时追踪当前时间，对于 int 字段，它会追踪时间戳秒数，您可以使用 nano/milli 来追踪纳秒、毫秒时间戳，例如：autoCreateTime:nano autoUpdateTime 创建 / 更新时追踪当前时间，对于 int 字段，它会追踪时间戳秒数，您可以使用 nano/milli 来追踪纳秒、毫秒时间戳，例如：autoUpdateTime:milli index 根据参数创建索引，多个字段使用相同的名称则创建复合索引，查看 索引 获取详情 uniqueIndex 与 index 相同，但创建的是唯一索引 check 创建检查约束，例如 check:age > 13，查看 约束 获取详情 设置字段写入的权限， 只创建、 只更新、 无写入权限、 创建和更新权限 -> 设置字段读的权限，->:false 无读权限 - 忽略该字段，- 无读写权限 4.5. 关联标签 GORM 允许通过标签为关联配置外键、约束、many2many 表，详情请参考 关联部分 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"ru-men-zhi-nan/mo-xing-ding-yi/wai-jian-gui-fan.html":{"url":"ru-men-zhi-nan/mo-xing-ding-yi/wai-jian-gui-fan.html","title":"外键规范","keywords":"","body":"gorm外键的规范性写法示例: type DtProject struct { gorm.Model Name string `json:\"name\" form:\"name\" gorm:\"column:name;comment:;type:varchar(191);\"` } type DtProjectWorkerRel struct { gorm.Model ProjectId uint `json:\"projectId\" gorm:\"comment:项目id;unique_index:project_company_idcard_idx\"` Project DtProject `gorm:\"foreignKey:ID;references:ProjectId;\"` } gorm:\"foreignKey:关联表的结构体字段;references:当前表的结构体字段; 报错处理: define a valid foreign key for relations or implement the Valuer/Scanner interface type UpLoadFile struct { gorm.Model FileName string `json:\"file_name\" gorm:\"comment:文件名\"` FileChunk []FileChunk `json:\"file_chunk\" gorm:\"-\"` } type FileChunk struct { gorm.Model FileId uint FileChunkNumber int FileChunkPath string } console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"ru-men-zhi-nan/lian-jie-shu-ju-ku.html":{"url":"ru-men-zhi-nan/lian-jie-shu-ju-ku.html","title":"连接数据库","keywords":"","body":" 连接数据库v21. MySQL1.1. 自定义驱动1.2. 现有的数据库连接2. PostgreSQL2.1. 自定义驱动2.2. 现有的数据库连接3. SQLite4. SQL Server5. 连接池6. 不支持的数据库 连接数据库v2 GORM 官方支持的数据库类型有： MySQL, PostgreSQL, SQlite, SQL Server 1. MySQL import ( \"gorm.io/driver/mysql\" \"gorm.io/gorm\" ) func main() { // 参考 https://github.com/go-sql-driver/mysql#dsn-data-source-name 获取详情 dsn := \"user:pass@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4&parseTime=True&loc=Local\" db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{}) } 注意：想要正确的处理 time.Time ，您需要带上 parseTime 参数， (更多参数) 要支持完整的 UTF-8 编码，您需要将 charset=utf8 更改为 charset=utf8mb4 查看 此文章 获取详情 MySQl 驱动程序提供了 一些高级配置 可以在初始化过程中使用，例如： db, err := gorm.Open(mysql.New(mysql.Config{ DSN: \"gorm:gorm@tcp(127.0.0.1:3306)/gorm?charset=utf8&parseTime=True&loc=Local\", // DSN data source name DefaultStringSize: 256, // string 类型字段的默认长度 DisableDatetimePrecision: true, // 禁用 datetime 精度，MySQL 5.6 之前的数据库不支持 DontSupportRenameIndex: true, // 重命名索引时采用删除并新建的方式，MySQL 5.7 之前的数据库和 MariaDB 不支持重命名索引 DontSupportRenameColumn: true, // 用 `change` 重命名列，MySQL 8 之前的数据库和 MariaDB 不支持重命名列 SkipInitializeWithVersion: false, // 根据当前 MySQL 版本自动配置 }), &gorm.Config{}) 1.1. 自定义驱动 GORM 允许通过 DriverName 选项自定义 MySQL 驱动，例如： import ( _ \"example.com/my_mysql_driver\" \"gorm.io/gorm\" ) db, err := gorm.Open(mysql.New(mysql.Config{ DriverName: \"my_mysql_driver\", DSN: \"gorm:gorm@tcp(localhost:9910)/gorm?charset=utf8&parseTime=True&loc=Local\", // Data Source Name，参考 https://github.com/go-sql-driver/mysql#dsn-data-source-name }), &gorm.Config{}) 1.2. 现有的数据库连接 GORM 允许通过一个现有的数据库连接来初始化 *gorm.DB import ( \"database/sql\" \"gorm.io/gorm\" ) sqlDB, err := sql.Open(\"mysql\", \"mydb_dsn\") gormDB, err := gorm.Open(mysql.New(mysql.Config{ Conn: sqlDB, }), &gorm.Config{}) 2. PostgreSQL import ( \"gorm.io/driver/postgres\" \"gorm.io/gorm\" ) dsn := \"user=gorm password=gorm dbname=gorm port=9920 sslmode=disable TimeZone=Asia/Shanghai\" db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{}) 我们使用 pgx 作为 postgres 的 database/sql 驱动，默认情况下，它会启用 prepared statement 缓存，你可以这样禁用它： // https://github.com/go-gorm/postgres db, err := gorm.Open(postgres.New(postgres.Config{ DSN: \"user=gorm password=gorm dbname=gorm port=9920 sslmode=disable TimeZone=Asia/Shanghai\", PreferSimpleProtocol: true, // disables implicit prepared statement usage }), &gorm.Config{}) 2.1. 自定义驱动 GORM 允许通过 DriverName 选项自定义 PostgreSQL 驱动，例如： import ( _ \"github.com/GoogleCloudPlatform/cloudsql-proxy/proxy/dialers/postgres\" \"gorm.io/gorm\" ) db, err := gorm.Open(postgres.New(postgres.Config{ DriverName: \"cloudsqlpostgres\", DSN: \"host=project:region:instance user=postgres dbname=postgres password=password sslmode=disable\", }) 2.2. 现有的数据库连接 GORM 允许通过一个现有的数据库连接来初始化 *gorm.DB import ( \"database/sql\" \"gorm.io/gorm\" ) sqlDB, err := sql.Open(\"postgres\", \"mydb_dsn\") gormDB, err := gorm.Open(postgres.New(postgres.Config{ Conn: sqlDB, }), &gorm.Config{}) 3. SQLite import ( \"gorm.io/driver/sqlite\" \"gorm.io/gorm\" ) // github.com/mattn/go-sqlite3 db, err := gorm.Open(sqlite.Open(\"gorm.db\"), &gorm.Config{}) 注意： 您也可以使用 file:![:memory:](https://cdn.learnku.com/assets/images/emoji/memory.png)?cache=shared 替代文件路径。 这会告诉 SQLite 在系统内存中使用一个临时数据库。 (查看 SQLite 文档 获取详情) 4. SQL Server import ( \"gorm.io/driver/sqlserver\" \"gorm.io/gorm\" ) // github.com/denisenkom/go-mssqldb dsn := \"sqlserver://gorm:LoremIpsum86@localhost:9930?database=gorm\" db, err := gorm.Open(sqlserver.Open(dsn), &gorm.Config{}) 5. 连接池 GORM 使用 database/sql 维护连接池 sqlDB, err := db.DB() // SetMaxIdleConns 设置空闲连接池中连接的最大数量 sqlDB.SetMaxIdleConns(10) // SetMaxOpenConns 设置打开数据库连接的最大数量。 sqlDB.SetMaxOpenConns(100) // SetConnMaxLifetime 设置了连接可复用的最大时间。 sqlDB.SetConnMaxLifetime(time.Hour) 查看 通用接口 获取详情。 6. 不支持的数据库 有些数据库可能兼容 mysql、postgres 的方言，在这种情况下，你可以直接使用这些数据库的方言。 对于其它不支持的数据，我们鼓励且欢迎大家伙开发更多数据库类型的驱动！ console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"crudjie-kou.html":{"url":"crudjie-kou.html","title":"CRUD接口","keywords":"","body":" console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"crudjie-kou/chuang-jian.html":{"url":"crudjie-kou/chuang-jian.html","title":"创建","keywords":"","body":" 创建v21. 建立连接，并创建表结构2. 创建记录3. 用指定的字段创建记录4. 批量插入5. 创建钩子6. 根据 Map 创建7. 使用 SQL 表达式、Context Valuer 创建记录8. 高级选项8.1. 关联创建8.2. 默认值8.3. Upsert 及冲突 创建v2 1. 建立连接，并创建表结构 通过 入门指南/模型定义 创建表结构 package config import ( \"fmt\" \"gorm.io/driver/mysql\" \"gorm.io/gorm\" ) func Core() *gorm.DB { dsn := \"root:root@tcp(127.0.0.1:3306)/gorm?charset=utf8mb4&parseTime=True&loc=Local\" db, err := gorm.Open(mysql.Open(dsn)) if err != nil { fmt.Println(err) } // 创建表 err = db.AutoMigrate(&User{}) if err != nil { return nil } // 根据User结构体建表 fmt.Println(\"建立连接成功\") return db } 2. 创建记录 // CreateUser1 普通创建 func CreateUser1(db *gorm.DB) { user := User{Name: \"zs\", Age: 18, Birthday: time.Now()} result := db.Create(&user) // 通过数据的指针来创建 fmt.Println(result.Error) // 返回 error fmt.Println(result.RowsAffected) // 返回插入记录的数量 } 3. 用指定的字段创建记录 // CreateUser2 指定字段创建 func CreateUser2(db *gorm.DB) { user := User{Name: \"ls\", Age: 22, CreatedAt: time.Now()} } 创建记录并更新给出的字段。 db.Select(\"Name\", \"Age\", \"CreatedAt\").Create(&user) // INSERT INTO `user` (`name`,`age`,`created_at`) VALUES (\"jinzhu\", 18, \"2020-07-04 11:05:21.775\") 创建记录并更新未给出的字段。 db.Omit(\"Name\", \"Age\", \"CreatedAt\").Create(&user) // INSERT INTO `user` (`birthday`,`updated_at`) VALUES (\"2020-01-01 00:00:00.000\", \"2020-07-04 11:05:21.775\") 4. 批量插入 要有效地插入大量记录，请将一个 slice 传递给 Create 方法。 将切片数据传递给 Create 方法，GORM 将生成一个单一的 SQL 语句来插入所有数据，并回填主键的值，钩子方法也会被调用。 func CreateUser3(db *gorm.DB) { users := []User{ {Name: \"qq\"}, {Name: \"ee\"}, } db.Create(&users) for _, user := range users { fmt.Println(user.ID) } } 使用 CreateInBatches 创建时，你还可以指定创建的数量，例如： // CreateUser4 批量创建，指定批量大小 func CreateUser4(db *gorm.DB) { users := []User{ {Name: \"qq3\"}, {Name: \"ee3\"}, } db.CreateInBatches(users, 1) for _, user := range users { fmt.Println(user.ID) } } Upsert 和 Create With Associations 也支持批量插入 5. 创建钩子 GORM 允许用户定义的钩子有 BeforeSave, BeforeCreate, AfterSave, AfterCreate 创建记录时将调用这些钩子方法，请参考 Hooks 中关于生命周期的详细信息 func (u *User) BeforeCreate(tx *gorm.DB) (err error) { if u.Name != \"zs\" { return errors.New(\"no zs\") } return } // CreateUser1 普通创建 func CreateUser1(db *gorm.DB) { user := User{Name: \"z2s\", Age: 18, Birthday: time.Now()} result := db.Create(&user) // 通过数据的指针来创建 fmt.Println(result.Error) // 返回 error } 如果您想跳过 钩子 方法，您可以使用 SkipHooks 会话模式，例如： DB.Session(&gorm.Session{SkipHooks: true}).Create(&user) DB.Session(&gorm.Session{SkipHooks: true}).Create(&users) DB.Session(&gorm.Session{SkipHooks: true}).CreateInBatches(users, 100) // CreateUser1 普通创建 func CreateUser1(db *gorm.DB) { user := User{Name: \"z2s\", Age: 18, Birthday: time.Now()} result := db.Session(&gorm.Session{SkipHooks: true}).Create(&user) // 跳过 `钩子` 方法 } 6. 根据 Map 创建 GORM 支持根据 map[string]interface{} 和 []map[string]interface{}{} 创建记录，例如： func CreateUser5(db *gorm.DB) { db.Model(&User{}).Create(map[string]interface{}{ \"Name\": \"aa\", \"Age\": 19, }) // batch insert from `[]map[string]interface{}{}` db.Model(&User{}).Create([]map[string]interface{}{ {\"Name\": \"aa2\", \"Age\": 20}, {\"Name\": \"aa3\", \"Age\": 21}, }) } 注意： 根据 map 创建记录时，association 不会被调用，且主键也不会自动填充 7. 使用 SQL 表达式、Context Valuer 创建记录 GORM 允许使用 SQL 表达式插入数据，有两种方法实现这个目标。根据 map[string]interface{} 或 自定义数据类型 创建，例如： // 通过 map 创建记录 db.Model(User{}).Create(map[string]interface{}{ \"Name\": \"jinzhu\", \"Location\": clause.Expr{SQL: \"ST_PointFromText(?)\", Vars: []interface{}{\"POINT(100 100)\"}}, }) // INSERT INTO `users` (`name`,`point`) VALUES (\"jinzhu\",ST_PointFromText(\"POINT(100 100)\")); // 通过自定义类型创建记录 type Location struct { X, Y int } // Scan 方法实现了 sql.Scanner 接口 func (loc *Location) Scan(v interface{}) error { // Scan a value into struct from database driver } func (loc Location) GormDataType() string { return \"geometry\" } func (loc Location) GormValue(ctx context.Context, db *gorm.DB) clause.Expr { return clause.Expr{ SQL: \"ST_PointFromText(?)\", Vars: []interface{}{fmt.Sprintf(\"POINT(%d %d)\", loc.X, loc.Y)}, } } type User struct { Name string Location Location } db.Create(&User{ Name: \"jinzhu\", Location: Location{X: 100, Y: 100}, }) // INSERT INTO `users` (`name`,`point`) VALUES (\"jinzhu\",ST_PointFromText(\"POINT(100 100)\")) 8. 高级选项 8.1. 关联创建 创建关联数据时，如果关联值是非零值，这些关联会被 upsert，且它们的 Hook 方法也会被调用 type CreditCard struct { gorm.Model Number string UserID uint } type UserInfo struct { gorm.Model Name string CreditCardId uint CreditCard CreditCard `gorm:\"foreignKey:UserID;references:CreditCardId;\"` } // CreateUser8 关联创建 func CreateUser8(db *gorm.DB) { db.Create(&UserInfo{ Name: \"zs\", CreditCard: CreditCard{Number: \"111111111111\"}, }) } 您也可以通过 Select、 Omit 跳过关联保存，例如： db.Omit(\"CreditCard\").Create(&user) // 跳过所有关联 db.Omit(clause.Associations).Create(&user) 发现 CreditCard 表并无新增数据 clause.Associations 同理，只不过跳过所有外键关联 8.2. 默认值 您可以通过标签 default 为字段定义默认值，如： type DefaultTest1 struct { ID int64 Name string `gorm:\"default:gorm\"` Age int64 `gorm:\"default:18\"` } db.Create(&DefaultTest1{ ID: 1, }) 插入记录到数据库时，默认值 会被用于 填充值为 零值 的字段 注意 像 0、''、false 等零值，不会将这些字段定义的默认值保存到数据库。您需要使用指针类型或 Scanner/Valuer 来避免这个问题，例如： type DefaultTest2 struct { gorm.Model Name string Age *int `gorm:\"default:18\"` Active sql.NullBool `gorm:\"default:true\"` } db.Create(&DefaultTest2{ Name: \"zs\", }) 注意 若要数据库有默认、虚拟 / 生成的值，你必须为字段设置 default 标签。若要在迁移时跳过默认值定义，你可以使用 default:(-)，例如： type User struct { ID string `gorm:\"default:uuid_generate_v3()\"` // 数据库函数 FirstName string LastName string Age uint8 FullName string `gorm:\"->;type:GENERATED ALWAYS AS (concat(firstname,' ',lastname));default:(-);` } 使用虚拟 / 生成的值时，你可能需要禁用它的创建、更新权限，查看 字段级权限 获取详情 8.3. Upsert 及冲突 GORM 为不同数据库提供了兼容的 Upsert 支持 func UpsertFunc(db *gorm.DB) { //db.Create(&DefaultTest1{ // ID: 1, //}) //上面会抛出异常 Error 1062: Duplicate entry '1' for key 'default_test1.PRIMARY' // 有冲突时什么都不做 //db.Clauses(clause.OnConflict{DoNothing: true}).Create(&DefaultTest1{ // ID: 1, //}) // 当有冲突时，更新指定列为默认值 //db.Clauses(clause.OnConflict{ // Columns: []clause.Column{ // {Name: \"id\"}, // }, // DoUpdates: clause.Assignments(map[string]interface{}{\"id\": 5}), //}).Create(&DefaultTest1{ // ID: 1, //}) // 当有冲突时，更新指定列为新值 db.Clauses(clause.OnConflict{ Columns: []clause.Column{ {Name: \"id\"}, }, DoUpdates: clause.AssignmentColumns([]string{\"id\", \"age\"}), }).Create(&DefaultTest1{ ID: 1, Age: 20, Name: \"zs\", }) db.Clauses(clause.OnConflict{ UpdateAll: true, }).Create(&DefaultTest1{ ID: 1, Age: 21, }) } 更新指定列为默认值 更新指定列为新值 也可以查看 高级查询 中的 FirstOrInit, FirstOrCreate 查看 原生 SQL 及构造器 获取详情 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"crudjie-kou/cha-xun.html":{"url":"crudjie-kou/cha-xun.html","title":"查询","keywords":"","body":" 查询v21. 检索单个对象1.1. 根据主键检索2. 检索全部对象3. 条件3.1. String 条件3.2. Struct & Map 条件3.3. 内联条件3.4. Not 条件3.5. Or 条件4. 选择特定字段5. Order6. Limit & Offset7. Group & Having8. Distinct9. Joins9.1. Joins 预加载10. Scan 查询v2 1. 检索单个对象 GORM 提供了 First、Take、Last 方法，以便从数据库中检索单个对象。当查询数据库时它添加了 LIMIT 1 条件，且没有找到记录时，它会返回 ErrRecordNotFound 错误 func QueryTest1(db *gorm.DB) { // 获取第一条记录（主键升序） user1 := User{} db.First(&user1) fmt.Println(user1) // 获取一条记录，没有指定排序字段 user2 := User{} db.Take(&user2) fmt.Println(user2) // 获取最后一条记录（主键降序） user3 := User{} db.Last(&user3) fmt.Println(user3) result := db.First(&user1) fmt.Println(result.RowsAffected) // 返回找到的记录数 fmt.Println(result.Error) // returns error // 检查 ErrRecordNotFound 错误 errors.Is(result.Error, gorm.ErrRecordNotFound) } First、Last 方法会根据主键查找到第一个、最后一个记录， 它仅在通过 struct 或提供 model 值进行查询时才起作用。 如果 model 类型没有定义主键，则按第一个字段排序，例如： func QueryTest2(db *gorm.DB) { // 可以 var user User db.First(&user) fmt.Println(user) fmt.Println() // 可以 result := map[string]interface{}{} db.Model(&User{}).First(result) fmt.Println(result) fmt.Println() // 不行 result2 := map[string]interface{}{} db.Table(\"user\").First(result2) fmt.Println(result2) fmt.Println() // 但可以配合 Take 使用 result3 := map[string]interface{}{} db.Table(\"user\").Take(result3) fmt.Println(result3) fmt.Println() // 根据第一个字段排序 result4 := db.First(&User{}) fmt.Println(result4.RowsAffected) } 1.1. 根据主键检索 您可以使用 内联条件 来检索对象。 传入字符串参数时注意避免 SQL 注入问题，查看 安全 获取详情 func QueryTest3(db *gorm.DB) { user := User{} db.First(&user, 10) fmt.Println(user) fmt.Println() user2 := User{} db.First(&user2, \"10\") fmt.Println(user2) fmt.Println() users := []User{ {}, } db.Find(&users, []int{1, 2, 3}) for _, user := range users { fmt.Println(user) } fmt.Println() } 2. 检索全部对象 // QueryALlTest ## 检索全部对象 func QueryALlTest(db *gorm.DB) { users := []User{ {}, } result := db.Find(&users) for _, user := range users { fmt.Println(user) } fmt.Println(result.RowsAffected) fmt.Println(result.Error) } 3. 条件 3.1. String 条件 func FilterTest(db *gorm.DB) { // 获取第一条匹配的记录 var user User db.Where(\"name = ?\", \"ee\").First(&user) fmt.Println(user) // 获取全部匹配的记录 users := []User{ {}, } result := db.Where(\"name = ?\", \"zs\").Find(&users) fmt.Println(result.RowsAffected) // IN users = []User{ {}, } result2 := db.Where(\"name IN ?\", []string{\"zs\", \"aa\"}).Find(&users) fmt.Println(result2.RowsAffected) // LIKE users = []User{ {}, } result3 := db.Where(\"name like ?\", \"%z%\").Find(&users) fmt.Println(result3.RowsAffected) // AND users = []User{ {}, } result4 := db.Where(\"name = ? AND age >= ?\", \"zs\", 18).Find(&users) fmt.Println(result4.RowsAffected) // Time users = []User{ {}, } result5 := db.Where(\"updated_at > ?\", \"2022-06-21 00:00:00\").Find(&users) fmt.Println(result5.RowsAffected) // BETWEEN users = []User{ {}, } result6 := db.Where(\"created_at BETWEEN ? AND ?\", \"2022-06-20 00:00:00\", \"2022-06-21 00:00:00\").Find(&users) fmt.Println(result6.RowsAffected) } 3.2. Struct & Map 条件 func FilterMapAndStruct(db *gorm.DB) { //Struct var user User db.Where(&User{Name: \"zs\", Age: 18}).First(&user) fmt.Println(user) // Map users := []User{ {}, } db.Where(map[string]interface{}{\"name\": \"ls\", \"age\": 22}).Find(&users) fmt.Println(users) // 主键切片条件 users = []User{ {}, } db.Where([]int{1, 3, 5}).Find(&users) fmt.Println(\"主键切片条件\", users) } 注意 当使用结构作为条件查询时，GORM 只会查询非零值字段。这意味着如果您的字段值为 0、''、false 或其他 零值，该字段不会被用于构建查询条件，例如： db.Where(&User{Name: \"jinzhu\", Age: 0}).Find(&users) // SELECT * FROM users WHERE name = \"jinzhu\"; 您可以使用 map 来构建查询条件，例如： db.Where(map[string]interface{}{\"Name\": \"jinzhu\", \"Age\": 0}).Find(&users) // SELECT * FROM users WHERE name = \"jinzhu\" AND age = 0; 3.3. 内联条件 用法与 Where 类似 func FilterTest2(db *gorm.DB) { // 根据主键获取记录，如果是非整型主键 var user User db.First(&user, \"id = ?\", \"5\") fmt.Println(1, user) // Plain SQL user = User{} db.Find(&user, \"name = ?\", \"zs\") fmt.Println(2, user) users := []User{ {}, } db.Find(&users, \"name <> ? AND age > ?\", \"zs\", 20) fmt.Println(3, users) // Struct users = []User{ {}, } db.Find(&users, User{Age: 22}) fmt.Println(4, users) // Map users = []User{ {}, } db.Find(&users, map[string]interface{}{\"age\": 20}) fmt.Println(5, users) } 3.4. Not 条件 构建 NOT 条件，用法与 Where 类似 func FilterNot(db *gorm.DB) { var user User db.Not(\"name = ?\", \"zs\").First(&user) fmt.Println(1, user) // Not In users := []User{ {}, } db.Not(map[string]interface{}{\"name\": []string{\"zs\", \"ls\"}}).Find(&users) fmt.Println(2, users) // Struct user = User{} db.Not(User{Name: \"zs\", Age: 18}).First(&user) fmt.Println(3, user) // 不在主键切片中的记录 user = User{} db.Not([]int{1, 2, 3}).First(&user) fmt.Println(4, user) } 3.5. Or 条件 func FilterOr(db *gorm.DB) { users := []User{ {}, } db.Where(\"name = ?\", \"zs\").Or(\"name = ?\", \"ls\").Find(&users) fmt.Println(1, users) // Struct users = []User{ {}, } db.Where(\"name = 'zs'\").Or(User{Name: \"ls\", Age: 22}).Find(&users) fmt.Println(2, users) // Map users = []User{ {}, } db.Where(\"name = ?\", \"zs\").Or(map[string]interface{}{\"name\": \"ls\", \"age\": 22}).Find(&users) fmt.Println(3, users) } 您还可以查看高级查询中的 分组条件，它被用于编写复杂 SQL 4. 选择特定字段 选择您想从数据库中检索的字段，默认情况下会选择全部字段 func SelectField(db *gorm.DB) { users := []User{ {}, } db.Select(\"name\", \"age\").Find(&users) users = []User{ {}, } db.Select([]string{\"name\", \"age\"}).Find(&users) users = []User{ {}, } db.Table(\"user\").Select(\"COALESCE(age,?)\", 21).Rows() } 还可以看一看 智能选择字段 5. Order 指定从数据库检索记录时的排序方式 func OrderData(db *gorm.DB) { users := []User{ {}, } db.Order(\"age desc, name\").Find(&users) // 多个 order users = []User{ {}, } db.Order(\"age desc\").Order(\"name\").Find(&users) users = []User{ {}, } db.Clauses(clause.OrderBy{ Expression: clause.Expr{SQL: \"FIELD(id,?)\", Vars: []interface{}{[]int{1, 2, 3}}, WithoutParentheses: true}, }).Find(&users) } 6. Limit & Offset Limit 指定获取记录的最大数量 Offset 指定在开始返回记录之前要跳过的记录数量 func LimitAndOffset(db *gorm.DB) { users := []User{ {}, } db.Limit(3).Find(&users) fmt.Println(1, users) users = []User{ {}, } users2 := []User{ {}, } db.Limit(1).Find(&users).Limit(-1).Find(&users2) fmt.Println(2, users) fmt.Println(3, users2) users = []User{ {}, } db.Limit(5).Offset(3).Find(&users) fmt.Println(4, users) // 作者测试 Offset 必须配合 Limit 否则报错 //users = []User{ // {}, //} //db.Offset(10).Find(&users).Offset(-1).Find(&user) } 查看 Pagination 学习如何写一个分页器 7. Group & Having func GroupAndHaving(db *gorm.DB) { users := []User{ {}, } db.Model(&User{}).Select(\"name, sum(age) as total\").Where( \"name LIKE ?\", \"%z%\").Group(\"name\").Find(&users) fmt.Println(users) users = []User{ {}, } db.Model(&User{}).Select(\"name, sum(age) as total\").Group( \"name\").Having(\"name = ?\", \"zs\").First(&users) fmt.Println(users) /* rows, err := db.Table(\"orders\").Select(\"date(created_at) as date, sum(amount) as total\").Group(\"date(created_at)\").Rows() for rows.Next() { ... } rows, err := db.Table(\"orders\").Select(\"date(created_at) as date, sum(amount) as total\").Group(\"date(created_at)\").Having(\"sum(amount) > ?\", 100).Rows() for rows.Next() { ... } type Result struct { Date time.Time Total int64 } db.Table(\"orders\").Select(\"date(created_at) as date, sum(amount) as total\").Group(\"date(created_at)\").Having(\"sum(amount) > ?\", 100).Scan(&results) */ } 8. Distinct 从模型中选择不相同的值 func DistinctData(db *gorm.DB) { users := []User{ {}, } db.Distinct(\"name\", \"age\").Order(\"name, age desc\").Find(&users) } Distinct 也可以配合 Pluck, Count 使用 9. Joins 指定 Joins 条件 func JoinsModel(db *gorm.DB) { type Result struct { Name string Name2 string } result := Result{} db.Model(&User{}).Select(\"user.name, user_infos.name\").Joins( \"left join user_infos on user_infos.name = user.name\").Scan(&result) fmt.Println(result) /* rows, err := db.Table(\"users\").Select(\"users.name, emails.email\").Joins(\"left join emails on emails.user_id = users.id\").Rows() for rows.Next() { ... } db.Table(\"users\").Select(\"users.name, emails.email\").Joins(\"left join emails on emails.user_id = users.id\").Scan(&results) // 带参数的多表连接 db.Joins(\"JOIN emails ON emails.user_id = users.id AND emails.email = ?\", \"jinzhu@example.org\").Joins(\"JOIN credit_cards ON credit_cards.user_id = users.id\").Where(\"credit_cards.number = ?\", \"411111111111\").Find(&user) */ } 9.1. Joins 预加载 您可以使用 Joins 实现单条 SQL 预加载关联记录，例如： func JoinsData(db *gorm.DB) { userInfos := []UserInfo{ {}, } db.Joins(\"CreditCard\").Find(&userInfos) } 参考 预加载 了解详情 10. Scan Scan 结果至 struct，用法与 Find 类似 func ScanData(db *gorm.DB) { type Result struct { Name string Age int } result := Result{} db.Table(\"user\").Select(\"name\", \"age\").Scan(&result) fmt.Println(result) db.Raw(\"select name, age from user where name = ?\", \"ls\").Scan(&result) fmt.Println(result) } console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"crudjie-kou/geng-xin.html":{"url":"crudjie-kou/geng-xin.html","title":"更新","keywords":"","body":" 更新v21. 保存所有字段2. 更新单个列3. 更新多列4. 更新选定字段5. 更新 Hook6. 批量更新6.1. 阻止全局更新6.2. 更新的记录数7. 高级选项7.1. 使用 SQL 表达式更新7.2. 根据子查询进行更新7.3. 不使用 Hook 和时间追踪7.4. 检查字段是否有变更？7.5. 在更新时修改值 更新v2 1. 保存所有字段 Save 会保存所有的字段，即使字段是零值 func UpdateData1(db *gorm.DB) { var user User db.First(&user) user.Name = \"zs2\" user.Age = 98 db.Save(&user) } 2. 更新单个列 当使用 Update 更新单个列时，你需要指定条件，否则会返回 ErrMissingWhereClause 错误，查看 Block Global Updates 获取详情。当使用了 Model 方法，且该对象主键有值，该值会被用于构建条件，例如： // UpdateData2 更新单个列 func UpdateData2(db *gorm.DB) { // 条件更新 db.Model(&User{}).Where(\"age = ?\", 98).Update(\"age\", \"89\") var user User // User 的 ID 是 1 user.ID = 1 db.Model(&user).Update(\"name\", \"hello\") // 根据条件和model的值进行更新 user = User{} db.Model(&user).Where(\"ID = ?\", 1).Update(\"name\", \"hello2\") } 3. 更新多列 Updates 方法支持 struct 和 map[string]interface{} 参数。当使用 struct 更新时，默认情况下，GORM 只会更新非零值的字段 func UpdateData3(db *gorm.DB) { // 根据 `struct` 更新属性，只会更新非零值的字段 var user User user.ID = 2 db.Model(&user).Updates(User{ Name: \"hello2\", Age: 89, }) // 根据 `map` 更新属性 user = User{} user.ID = 1 db.Model(&user).Updates(map[string]interface{}{ \"name\": \"zs\", \"age\": 18, }) } 注意 当通过 struct 更新时，GORM 只会更新非零字段。 如果您想确保指定字段被更新，你应该使用 Select 更新选定字段，或使用 map 来完成更新操作 4. 更新选定字段 如果您想要在更新时选定、忽略某些字段，您可以使用 Select、Omit func UpdateData4(db *gorm.DB) { user := User{ ID: 1, } db.Model(&user).Select(\"name\").Updates(map[string]interface{}{\"name\": \"hello\", \"age\": 28}) user = User{ ID: 2, } db.Model(&user).Omit(\"name\").Updates(map[string]interface{}{ \"name\": \"ls\", \"age\": 23, }) // Select 和 Struct （可以选中更新零值字段） user = User{ ID: 3, } db.Model(&user).Select(\"Name\", \"Age\").Updates(User{ Name: \"word\", Age: 0, }) } 5. 更新 Hook 对于更新操作，GORM 支持 BeforeSave、BeforeUpdate、AfterSave、AfterUpdate 钩子，这些方法将在更新记录时被调用，详情请参阅 钩子 func (u *User) BeforeUpdate(tx *gorm.DB) (err error) { if u.Role == \"admin\" { return errors.New(\"admin user not allowed to update\") } return } 6. 批量更新 如果您尚未通过 Model 指定记录的主键，则 GORM 会执行批量更新 func UpdateData5(db *gorm.DB) { // 根据 struct 更新 db.Model(&User{}).Where(\"id in (?)\", []int{10, 11, 12}).Updates(User{ Name: \"test123\", Age: 99, }) // 根据 map 更新 db.Table(\"user\").Where(\"id in ?\", []int{1, 2, 3}).Updates(map[string]interface{}{ \"name\": \"test234\", \"age\": 88, }) } 6.1. 阻止全局更新 如果在没有任何条件的情况下执行批量更新，默认情况下，GORM 不会执行该操作，并返回 ErrMissingWhereClause 错误 对此，你必须加一些条件，或者使用原生 SQL，或者启用 AllowGlobalUpdate 模式，例如： func UpdateData6(db *gorm.DB) { db.Model(&User{}).Update(\"name\", \"zs\") db.Model(&User{}).Where(\"1 = 1\").Update(\"name\", \"zs\") db.Exec(\"UPDATE user set name = ?\", \"ls\") db.Session(&gorm.Session{AllowGlobalUpdate: true}).Model(&User{}).Update(\"age\", 20) } 6.2. 更新的记录数 获取受更新影响的行数 func UpdateData7(db *gorm.DB) { // 通过 `RowsAffected` 得到更新的记录数 result := db.Model(&User{}).Where(\"id in ?\", []int{10, 11, 12, 13}).Updates(User{Name: \"zs\"}) fmt.Println(result.RowsAffected) fmt.Println(result.Error) } 7. 高级选项 7.1. 使用 SQL 表达式更新 GORM 允许使用 SQL 表达式更新列，例如： func UpdateData9(db *gorm.DB) { user := User{ ID: 3, } db.Model(&user).Update(\"age\", gorm.Expr(\"age * ? + ?\", 2, 100)) user = User{ ID: 2, } db.Model(&user).Updates(map[string]interface{}{\"age\": gorm.Expr(\"age * ? + ?\", 2, 10)}) user = User{ID: 1} db.Model(&user).UpdateColumn(\"age\", gorm.Expr(\"age - ?\", 100)) user = User{} db.Model(&user).Where(\"age > 100\").UpdateColumn(\"age\", gorm.Expr(\"age - ?\", 1)) } 并且 GORM 也允许使用 SQL 表达式、自定义数据类型的 Context Valuer 来更新，例如： // 根据自定义数据类型创建 type Location struct { X, Y int } func (loc Location) GormValue(ctx context.Context, db *gorm.DB) clause.Expr { return clause.Expr{ SQL: \"ST_PointFromText(?)\", Vars: []interface{}{fmt.Sprintf(\"POINT(%d %d)\", loc.X, loc.Y)}, } } db.Model(&User{ID: 1}).Updates(User{ Name: \"jinzhu\", Point: Point{X: 100, Y: 100}, }) // UPDATE `user_with_points` SET `name`=\"jinzhu\",`point`=ST_PointFromText(\"POINT(100 100)\") WHERE `id` = 1 7.2. 根据子查询进行更新 使用子查询更新表 // UpdateData11 根据子查询进行更新 func UpdateData11(db *gorm.DB) { db.Model(&User{ID: 1}).Update(\"name\", db.Model(&UserInfo{}).Select(\"name\").Where(\"user.id = user_infos.id\")) db.Table(\"user as u\").Where(\"name = ?\", \"test\").Update(\"name\", db.Table(\"user_infos as uf\").Select(\"name\").Where(\"u.id = uf.id\")) db.Table(\"user as u\").Where(\"name = ?\", \"test222\").Updates(map[string]interface{}{\"name\": db.Table(\"user_infos as uf\").Select(\"name\").Where(\"u.id = uf.id\")}) } 7.3. 不使用 Hook 和时间追踪 如果您想在更新时跳过 Hook 方法且不追踪更新时间，可以使用 UpdateColumn、UpdateColumns，其用法类似于 Update、Updates func UpdateData10(db *gorm.DB) { db.Model(&User{ID: 1}).UpdateColumn(\"name\", \"test111\") db.Model(&User{ID: 2}).UpdateColumns(User{Name: \"test222\", Age: 99}) db.Model(&User{ID: 3}).Select(\"name\", \"age\").UpdateColumns(User{ Name: \"test34333\", Age: 88, }) } 7.4. 检查字段是否有变更？ GORM 提供了 Changed 方法，它可以被用在 Before Update Hook 里，它会返回字段是否有变更的布尔值 Changed 方法只能与 Update、Updates 方法一起使用，并且它只是检查 Model 对象字段的值与 Update、Updates 的值是否相等，如果值有变更，且字段没有被忽略，则返回 true func (u *User) BeforeUpdate(db *gorm.DB) (err error) { if db.Statement.Changed(\"MemberNumber\") { return errors.New(\"MemberNumber not allowed to change\") } if db.Statement.Changed(\"Name\", \"Age\") { db.Statement.SetColumn(\"Age\", 98) } if db.Statement.Changed() { db.Statement.SetColumn(\"email\", \"515@qq.com\") } return nil } func UpdateData12(db *gorm.DB) { db.Model(&User{ID: 1}).Updates(map[string]interface{}{\"name\": \"zs\"}) // Changed(\"Name\") => true db.Model(&User{ID: 1, Name: \"zs\"}).Updates(map[string]interface{}{\"name\": \"zs\"}) // Changed(\"Name\") => false, 因为 `Name` 没有变更 db.Model(&User{ID: 1, Name: \"zs\"}).Select(\"Age\").Updates(map[string]interface{}{\"name\": \"zs2\", \"age\": 66}) // Changed(\"Name\") => false, 因为 `Name` 没有被 Select 选中并更新 //测试失败 //db.Model(&User{ID: 1, Name: \"jinzhu\"}).Updates(User{Name: \"jinzhu2\"}) //// Changed(\"Name\") => true //db.Model(&User{ID: 1, Name: \"jinzhu\"}).Updates(User{Name: \"jinzhu\"}) //// Changed(\"Name\") => false, 因为 `Name` 没有变更 //db.Model(&User{ID: 1, Name: \"jinzhu\"}).Select(\"Admin\").Updates(User{Name: \"jinzhu2\"}) //// Changed(\"Name\") => false, 因为 `Name` 没有被 Select 选中并更新 } 7.5. 在更新时修改值 若要在 Before 钩子中改变要更新的值，如果它是一个完整的更新，可以使用 Save；否则，应该使用 SetColumn ，例如： func (user *User) BeforeSave(db *gorm.DB) (err error) { if db.Statement.Changed(\"name\") { user.Age += 20 db.Statement.SetColumn(\"Age\", user.Age) } return nil } // UpdateData13 在更新时修改值？ func UpdateData13(db *gorm.DB) { db.Model(&User{ID: 1}).Updates(map[string]interface{}{\"name\": \"zs\"}) // Changed(\"Name\") => true } console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"crudjie-kou/shan-chu.html":{"url":"crudjie-kou/shan-chu.html","title":"删除","keywords":"","body":"1. 删除一条记录2. 根据主键删除3. Delete Hook4. 批量删除4.1. 阻止全局删除5. 软删除5.1. 查找被软删除的记录5.2. 永久删除1. 删除一条记录 删除一条记录时，删除对象需要指定主键，否则会触发 批量 Delete，例如： func DeleteData1(db *gorm.DB) { // 删除ID = 16 db.Delete(&User{ID: 16}) // 带额外条件的删除 db.Where(\"name = ?\", \"zs\").Delete(&User{}) } 2. 根据主键删除 GORM 允许通过内联条件指定主键来检索对象，但只支持整型数值，因为 string 可能导致 SQL 注入。查看 内联条件、安全 获取详情 func DeleteData2(db *gorm.DB) { db.Delete(&User{}, 15) db.Delete(&User{}, \"14\") db.Delete(&User{}, []int{2, 3}) } 3. Delete Hook 对于删除操作，GORM 支持 BeforeDelete、AfterDelete Hook，在删除记录时会调用这些方法，查看 Hook 获取详情 func (u *User) BeforeDelete(tx *gorm.DB) (err error) { if u.Role == \"admin\" { return errors.New(\"admin user not allowed to delete\") } return } 4. 批量删除 如果指定的值不包括主属性，那么 GORM 会执行批量删除，它将删除所有匹配的记录 func DeleteData3(db *gorm.DB) { db.Where(\"name like ?\", \"%l%\").Delete(&User{}) db.Delete(&User{}, \"name is null\") } 4.1. 阻止全局删除 如果在没有任何条件的情况下执行批量删除，GORM 不会执行该操作，并返回 ErrMissingWhereClause 错误 对此，你必须加一些条件，或者使用原生 SQL，或者启用 AllowGlobalUpdate 模式，例如： func DeleteData4(db *gorm.DB) { err := db.Delete(&User{}).Error fmt.Println(err) db.Where(\"1 = 1\").Delete(&User{}) db.Exec(\"DELETE FROM user\") db.Session(&gorm.Session{AllowGlobalUpdate: true}).Delete(&User{}) } 5. 软删除 如果您的模型包含了一个 gorm.deletedat 字段（gorm.Model 已经包含了该字段)，它将自动获得软删除的能力！ 拥有软删除能力的模型调用 Delete 时，记录不会被从数据库中真正删除。但 GORM 会将 DeletedAt 置为当前时间， 并且你不能再通过正常的查询方法找到该记录。 func DeleteData5(db *gorm.DB) { db.Delete(&UserInfo{ Model: gorm.Model{ID: 1}, }) // 批量删除 db.Where(\"id in (?)\", []int{2, 3, 4}).Delete(&UserInfo{}) // 在查询时会忽略被软删除的记录 var userInfo []UserInfo db.Where(\"name = ?\", \"test\").Find(&userInfo) fmt.Println(userInfo) } 如果您不想引入 gorm.Model，您也可以这样启用软删除特性： type TestModel struct { ID int Deleted gorm.DeletedAt Name string } func DeleteData6(db *gorm.DB) { db.Where(\"id in (?)\", []int{1, 2, 3, 4}).Delete(&TestModel{}) } 5.1. 查找被软删除的记录 您可以使用 Unscoped 找到被软删除的记录 func GetDeleteData1(db *gorm.DB) { var userInfo []UserInfo db.Unscoped().Where(\"id > ?\", 1).Find(&userInfo) fmt.Println(userInfo) } 5.2. 永久删除 您也可以使用 Unscoped 永久删除匹配的记录 func DeleteDataUnscoped(db *gorm.DB) { db.Unscoped().Delete(&UserInfo{Model: gorm.Model{ID: 1}}) } console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"crudjie-kou/yuan-sheng-sql.html":{"url":"crudjie-kou/yuan-sheng-sql.html","title":"原生SQL","keywords":"","body":"1. 原生查询 SQL 和 Scan2. 命名参数3. DryRun 模式4. Row & Rows5. 将 sql.Rows 扫描至 model6. 高级6.1. 子句（Clause）6.2. 子句构造器6.3. 子句选项6.4. StatementModifier1. 原生查询 SQL 和 Scan func QueryData1(db *gorm.DB) { var result Result db.Raw(\"select id, name, age from user where id = ?\", 1).Scan(&result) fmt.Println(result) var age int db.Raw(\"select sum(age) from user where id in (?)\", []int{1, 2}).Scan(&age) fmt.Println(age) } Exec 原生 SQL db.Exec(\"DROP TABLE users\") db.Exec(\"UPDATE orders SET shipped_at=? WHERE id IN ?\", time.Now(), []int64{1,2,3}) // Exec SQL 表达式 db.Exec(\"update users set money=? where name = ?\", gorm.Expr(\"money * ? + ?\", 10000, 1), \"jinzhu\") 注意 GORM 允许缓存预编译 SQL 语句来提高性能，查看 性能 获取详情 2. 命名参数 GORM 支持 sql.NamedArg、map[string]interface{}{} 或 struct 形式的命名参数，例如： func QueryData3(db *gorm.DB) { var user []User db.Where(\"name = @name or name = @name\", sql.Named(\"name\", \"aa_test\")).Find(&user) db.Where(\"name = @name or name = @name\", map[string]interface{}{ \"name\": \"ls\", }).First(&User{}) // 原生 SQL 及命名参数 db.Raw(\"select * from user where name = @name or name = @name2\", sql.Named(\"name\", \"zs\"), sql.Named(\"name2\", \"aa_test\")).Find(&[]UserInfo{}) db.Exec(\"update user set name = @name, age = @age where id = 1\", sql.Named(\"name\", \"zs\"), sql.Named(\"age\", 25)) db.Raw(\"select * from user where (name = @name and age = @age)\", map[string]interface{}{ \"name\": \"zs\", \"age\": 66, }) type UserTest struct { Name string Age int } db.Raw(\"select * from user where (name = @Name AND age = @age)\", UserTest{Name: \"zs\", Age: 55}) } 3. DryRun 模式 在不执行的情况下生成 SQL ，可以用于准备或测试生成的 SQL，详情请参考 Session stmt := db.Session(&Session{DryRun: true}).First(&user, 1).Statement stmt.SQL.String() //=> SELECT * FROM `users` WHERE `id` = $1 ORDER BY `id` stmt.Vars //=> []interface{}{1} 4. Row & Rows 获取 *sql.Row 结果 // 使用 GORM API 构建 SQL row := db.Table(\"users\").Where(\"name = ?\", \"jinzhu\").Select(\"name\", \"age\").Row() row.Scan(&name, &age) // 使用原生 SQL row := db.Raw(\"select name, age, email from users where name = ?\", \"jinzhu\").Row() row.Scan(&name, &age, &email) 获取 *sql.Rows 结果 // 使用 GORM API 构建 SQL rows, err := db.Model(&User{}).Where(\"name = ?\", \"jinzhu\").Select(\"name, age, email\").Rows() defer rows.Close() for rows.Next() { rows.Scan(&name, &age, &email) // 业务逻辑... } // 原生 SQL rows, err := db.Raw(\"select name, age, email from users where name = ?\", \"jinzhu\").Rows() defer rows.Close() for rows.Next() { rows.Scan(&name, &age, &email) // 业务逻辑... } 转到 FindInBatches 获取如何在批量中查询和处理记录的信息， 转到 Group 条件 获取如何构建复杂 SQL 查询的信息 5. 将 sql.Rows 扫描至 model 使用 ScanRows 将一行记录扫描至 struct，例如： rows, err := db.Model(&User{}).Where(\"name = ?\", \"jinzhu\").Select(\"name, age, email\").Rows() // (*sql.Rows, error) defer rows.Close() var user User for rows.Next() { // ScanRows 将一行扫描至 user db.ScanRows(rows, &user) // 业务逻辑... } 6. 高级 6.1. 子句（Clause） GORM 内部使用 SQL builder 生成 SQL。对于每个操作，GORM 都会创建一个 *gorm.Statement 对象，所有的 GORM API 都是在为 statement 添加 / 修改 Clause，最后，GORM 会根据这些 Clause 生成 SQL 例如，当通过 First 进行查询时，它会在 Statement 中添加以下 Clause clause.Select{Columns: \"*\"} clause.From{Tables: clause.CurrentTable} clause.Limit{Limit: 1} clause.OrderByColumn{ Column: clause.Column{Table: clause.CurrentTable, Name: clause.PrimaryKey}, } 然后 GORM 在 Query callback 中构建最终的查询 SQL，像这样： Statement.Build(\"SELECT\", \"FROM\", \"WHERE\", \"GROUP BY\", \"ORDER BY\", \"LIMIT\", \"FOR\") 生成 SQL： SELECT * FROM `users` ORDER BY `users`.`id` LIMIT 1 您可以自定义 Clause 并与 GORM 一起使用，这需要实现 Interface 接口 可以参考 示例 6.2. 子句构造器 不同的数据库，Clause 可能会生成不同的 SQL，例如： db.Offset(10).Limit(5).Find(&users) // SQL Server 会生成 // SELECT * FROM \"users\" OFFSET 10 ROW FETCH NEXT 5 ROWS ONLY // MySQL 会生成 // SELECT * FROM `users` LIMIT 5 OFFSET 10 之所以支持 Clause，是因为 GORM 允许数据库驱动程序通过注册 Clause Builder 来取代默认值，这儿有一个 Limit 的示例 6.3. 子句选项 GORM 定义了很多 Clause，其中一些 Clause 提供了你可能会用到的选项 尽管很少会用到它们，但如果你发现 GORM API 与你的预期不符合。这可能可以很好地检查它们，例如： db.Clauses(clause.Insert{Modifier: \"IGNORE\"}).Create(&user) // INSERT IGNORE INTO users (name,age...) VALUES (\"jinzhu\",18...); 6.4. StatementModifier GORM 提供了 StatementModifier 接口，允许您修改语句，使其符合您的要求，这儿有一个 Hint 示例 import \"gorm.io/hints\" db.Clauses(hints.New(\"hint\")).Find(&User{}) // SELECT * /*+ hint */ FROM `users` console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"}}