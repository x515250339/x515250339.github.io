{"./":{"url":"./","title":"algorithm前言","keywords":"","body":"algorithm前言algorithm前言 github: https://github.com/x515250339/algorithm_code 阶段一：基础准备 目标： 熟悉LeetCode平台，了解基本的数据结构和算法。 第1周：数据结构基础 学习数组、链表、栈和队列等基本数据结构。 刷一些简单难度的数组和链表题目。 第2周：算法基础 学习常见的排序算法和搜索算法。 刷一些简单难度的排序和搜索题目。 阶段二：深入学习 目标： 掌握常见的算法思想和数据结构。 第3-4周：递归与分治 学习递归和分治思想。 刷一些递归和分治相关的题目。 第5-6周：动态规划 学习动态规划的基本原理和常见解题思路。 刷一些简单和中等难度的动态规划题目。 第7-8周：树和图 学习二叉树、二叉搜索树、图等数据结构。 刷一些树和图相关的题目。 阶段三：强化练习 目标： 提高解题速度和优化能力。 第9-12周：专题练习 选择特定主题，如字符串、回溯、贪心算法等。 集中刷题，深入理解各种解法。 第13-16周：模拟面试 设定时间，模拟面试环境。 针对中等和困难难度的题目进行实战演练。 阶段四：复习和强化 目标： 巩固知识，准备面试。 第17-20周：复习和强化 复习之前做过的题目，特别是容易遗忘的部分。 注重整体知识点的强化。 第21-24周：模拟面试和反馈 继续模拟面试，寻求反馈。 针对反馈进行针对性的学习和提高。 其他建议 每天刷题时间： 每天至少1-2小时，保持稳定的学习进度。 使用LeetCode资源： 利用LeetCode的标签、讨论区和解题报告，加深对题目的理解。 查阅其他学习资源： 书籍、教程、博客等资源可以帮助你更全面地理解算法和数据结构。 保持健康： 不要忽视身体健康，适量运动和休息有助于提高学习效率。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"suan-fa-ji-chu.html":{"url":"suan-fa-ji-chu.html","title":"算法基础","keywords":"","body":"算法基础算法基础 时间复杂度 适用于大多数场景 一个 for 循环 O(n) 两个 for 循环 O(n²) 三个 for 循环 O(n³) 每次减少一半 O(log n) 空间复杂度 适用于大多数场景 创建常数项变量 O(1) 创建一个list O(n) 递归 1、定义 在函数内部，可以调用其他函数。 如果一个函数在内部调用自身本身，这个函数就是递归函数。 2、递归特性 必须有一个明确的结束条件 每次进入更深一层递归时，问题规模相比上次递归都应有所减少 递归效率不高，递归层次过多会导致栈溢出（在计算机中，函数调用是通过栈（stack）这种数据结构实现的 每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。 由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出） 查找 线性查找（linear_search） 二分查找（折半查找）（binary_search） 排序 low b 三人组 冒泡排序（bubble_sort） 插入排序（insert_sort） 选择排序（select_sort） &#x1F402;b 三人组 堆排序（heap_sort） 归并排序（merge_sort） 快速排序（quick_sort） 希尔排序 桶排序 数据结构 列表 栈 队列 链表 单链表 双链表 哈希表 树 二叉树 AVL树 动态规划 设计模式 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"shi-jian-fu-za-du.html":{"url":"shi-jian-fu-za-du.html","title":"时间复杂度","keywords":"","body":"时间复杂度时间复杂度 适用于大多数场景 一个 for 循环 O(n) 两个 for 循环 O(n²) 三个 for 循环 O(n³) 每次减少一半 O(log n) console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"kong-jian-fu-za-du.html":{"url":"kong-jian-fu-za-du.html","title":"空间复杂度","keywords":"","body":"空间复杂度空间复杂度 适用于大多数场景 创建常数项变量 O(1) 创建一个list O(n) console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"di-gui-de-han-yi.html":{"url":"di-gui-de-han-yi.html","title":"递归的含义","keywords":"","body":"递归递归 1、定义 在函数内部，可以调用其他函数。 如果一个函数在内部调用自身本身，这个函数就是递归函数。 2、递归特性 必须有一个明确的结束条件 每次进入更深一层递归时，问题规模相比上次递归都应有所减少 递归效率不高，递归层次过多会导致栈溢出（在计算机中，函数调用是通过栈（stack）这种数据结构实现的 每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。 由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出） console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chang-jian-suan-fa-shi-jian-fu-za-du.html":{"url":"chang-jian-suan-fa-shi-jian-fu-za-du.html","title":"常见算法时间复杂度","keywords":"","body":" console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"cha-zhao.html":{"url":"cha-zhao.html","title":"查找","keywords":"","body":" console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"xian-xing-cha-zhao.html":{"url":"xian-xing-cha-zhao.html","title":"线性查找","keywords":"","body":"线性查找：最简单的查找，使用循环遍历，查找当前值是否存在 时间复杂度 O(n) 空间复杂度 O(1) def linear_search(data_list, val): \"\"\" 线性查找 时间复杂度 O(n) :param data_list: 输入列表 :param val: 返回查询到的索引 :return: \"\"\" for i, j in enumerate(data_list): if val == j: return i li = [1, 2, 3, 4, 5, 6, 7, 8, 9] print(linear_search(li, 2)) console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"er-fen-cha-zhao.html":{"url":"er-fen-cha-zhao.html","title":"二分查找","keywords":"","body":"二分查找: 二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。 时间复杂度 O(log2n)表示（n 为查找表中的元素数量，底数 2 可以省略） 空间复杂度 O(1) 推荐代码，在刷题的过程中可以避免很多边缘条件（edge conditions） import random from typing import List def binary_search_bytedance(data_list: List[int], val: int) -> bool: if not data_list: return False start, end = 0, len(data_list) - 1 while start + 1 import random from typing import List def binary_search(li: [int], val: int) -> int: \"\"\" 二分查找 时间复杂度 O(log n) :param li: 输入列表 :param val: 返回查询到的索引 :return: \"\"\" left = 0 right = len(li) - 1 while left val: right = mid - 1 else: left = mid + 1 return -1 li = [1, 2, 3, 4, 5, 6, 7, 8, 9] print(binary_search(li, 0)) def binary_search(data: List[int], tar: int) -> bool: start, end = 0, len(data) - 1 while start console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"pai-xu.html":{"url":"pai-xu.html","title":"排序","keywords":"","body":" console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"low-b-san-ren-zu.html":{"url":"low-b-san-ren-zu.html","title":"low b 三人组","keywords":"","body":" console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"mao-pao-pai-xu-ff08-bubble-sort.html":{"url":"mao-pao-pai-xu-ff08-bubble-sort.html","title":"冒泡排序（bubble_sort）","keywords":"","body":"冒泡排序: 冒泡排序（Bubble Sort），它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果顺序（如从大到小、首字母从Z到A）错误就把他们交换过来。走访元素的工作是重复地进行，直到没有相邻元素需要交换，也就是说该元素列已经排序完成。 时间复杂度 O(n²) 空间复杂度 O(1) 最坏 O(n) 推荐 def bubble_sort(li): \"\"\" 冒泡排序 时间复杂度O(n²) :param li: :return: \"\"\" # 循环 n 遍 for i in range(len(li) - 1): # 检测是否下一次循环有变更 无变更说明有序 exchange = False # 排过去之后就固定了 固定0 1 2 3 4 ... 所以 - i 算法就是为了优化 for j in range(len(li) - i - 1): # 当现在 比 下一位大，则交换位置 if li[j] > li[j + 1]: li[j], li[j + 1] = li[j + 1], li[j] exchange = True if not exchange: break li = [random.randint(0, 100) for i in range(10)] print(li) bubble_sort(li) print(li) 常见写法 import random \"\"\" 1. 比较相邻两个数据如果。第一个比第二个大，就交换两个数 2. 对每一个相邻的数做同样1的工作，这样从开始一队到结尾一队在最后的数就是最大的数。 3. 针对所有元素上面的操作，除了最后一个。 4. 重复1~3步骤，直到顺序完成。 \"\"\" def bubble_sort(li): \"\"\" 冒泡排序 时间复杂度O(n²) 空间复杂度O(1) :param li: :return: \"\"\" for i in range(len(li) - 1): for j in range(len(li) - i - 1): if li[j] > li[j + 1]: li[j], li[j + 1] = li[j + 1], li[j] li = [random.randint(0, 100) for i in range(10)] print(li) bubble_sort(li) print(li) console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"cha-ru-pai-xu-ff08-insert-sort.html":{"url":"cha-ru-pai-xu-ff08-insert-sort.html","title":"插入排序（insert_sort）","keywords":"","body":"插入排序：插入排序，一般也被称为直接插入排序。对于少量元素的排序，它是一个有效的算法 [1] 。插入排序是一种最简单的排序方法，它的基本思想是将一个记录插入到已经排好序的有序表中，从而一个新的、记录数增1的有序表。在其实现过程使用双层循环，外层循环对除了第一个元素之外的所有元素，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动 时间复杂度 O(n²) 空间复杂度 O(1) import random \"\"\" 1. 从第一个元素开始，该元素可以认为已经被排序； 2. 取出下一个元素，在已经排序的元素序列中从后向前扫描； 3. 如果该元素（已排序）大于新元素，将该元素移到下一位置； 4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； 5. 将新元素插入到该位置后； 6. 重复步骤2~5。 \"\"\" def insert_sort(li): \"\"\" 插入排序 时间复杂度 O(n²) 空间复杂度O(1) :param li: :return: \"\"\" # 循环开始 for i in range(1, len(li)): # 获取第二个值 tmp = li[i] # 第一个索引下标 j = i - 1 # 当满足循环条件，j 没有超出索引边界，然后开始比较第一个值（前一个值）和下一个值，以此类推 while j >= 0 and li[j] > tmp: # 交换位置 li[j + 1] = li[j] # 索引-1继续比较 j = j - 1 # 交换位置，小的往前 li[j + 1] = tmp li = [random.randint(0, 100) for i in range(10)] print(li) insert_sort(li) print(li) console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"xuan-zepai-xu-ff08-select-sort.html":{"url":"xuan-zepai-xu-ff08-select-sort.html","title":"选择排序（select_sort）","keywords":"","body":"选择排序：第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。选择排序是不稳定的排序方法。 时间复杂度 O(n²) 空间复杂度 O(1) def select_sort(li): \"\"\" 插入排序 时间复杂度 O(n²) 空间复杂度O(1) :param li: :return: \"\"\" for i in range(len(li) - 1): min_loc = i for j in range(i + 1, len(li)): if li[j] console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"d83d-dc02-b-san-ren-zu.html":{"url":"d83d-dc02-b-san-ren-zu.html","title":"🐂b 三人组","keywords":"","body":" console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"d83d-dc02-b-san-ren-zu/dui-pai-xu-ff08-heap-sort.html":{"url":"d83d-dc02-b-san-ren-zu/dui-pai-xu-ff08-heap-sort.html","title":"堆排序（heap_sort）","keywords":"","body":"堆排序：利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 算法描述 - 将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区； - 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1] 大根堆：根最大 小根堆：根最小 时间复杂度 O(n log n) 空间复杂度 O(1) import random def sift(data_list, low, high): \"\"\" :param data_list: 列表 :param low: 堆的根节点 :param high: 堆的最后一个元素的位置 :return: \"\"\" i = low # 指向根结点 j = 2 * i + 1 # 左孩子 tmp = data_list[low] # 存放堆顶 while j data_list[j]: # 如果右孩子有数并且比较大 j += 1 # 指向右孩子 if data_list[j] > tmp: data_list[i] = data_list[j] i = j # 往下一层 j = 2 * i + 1 else: # tmp 更大，把tmp放到i的位置上 data_list[i] = tmp # 把 tmp 放到某一级领导上 break data_list[i] = tmp # 把 tmp 放到叶子节点上 def heap_sort(data_list): n = len(data_list) for i in range((n - 2) // 2, -1, -1): # i 表示建堆的时候调整的部分的根的下标 sift(data_list, i, n - 1) # 堆建立完成 for i in range(n - 1, -1, -1): # i 指向当前堆的最后一个元素 data_list[0], data_list[i] = data_list[i], data_list[0] sift(data_list, 0, i - 1) # i - 1是新的high data = [random.randint(1, 100) for i in range(10)] print(data) heap_sort(data) print(data) console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"d83d-dc02-b-san-ren-zu/gui-bing-pai-xu-ff08-merge-sort.html":{"url":"d83d-dc02-b-san-ren-zu/gui-bing-pai-xu-ff08-merge-sort.html","title":"归并排序（merge_sort）","keywords":"","body":"归并排序：归并排序是建立在归并操作上的一种有效，稳定的排序算法，该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。 作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法： 1.自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）； 2.自下而上的迭代； 时间复杂度 O(n log n) 空间复杂度 O(n) def merge(data, low, mid, high): i = low j = mid + 1 tmp = [] while i console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"d83d-dc02-b-san-ren-zu/kuai-supai-xu-ff08-quick-sort.html":{"url":"d83d-dc02-b-san-ren-zu/kuai-supai-xu-ff08-quick-sort.html","title":"快速排序（quick_sort）","keywords":"","body":"选择排序: 通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 算法描述 快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下： 从数列中挑出一个元素，称为 “基准”（pivot）； 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 时间复杂度 O(n log n) 空间复杂度 O(1) import random def partition(li, left, right): tmp = li[left] while left = tmp: # 往前走一步 right -= 1 # 把右边的值写道左边的空位上 li[left] = li[right] while left console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"xi-er-pai-xu-ff08-shell-sort.html":{"url":"xi-er-pai-xu-ff08-shell-sort.html","title":"希尔排序（shell_sort）","keywords":"","body":"希尔排序: （Shell Sort）是插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因DL．Shell于1959年提出而得名。 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止 时间复杂度 O(n²) 空间复杂度 O(1) def insert_sort_gap(li, gap): \"\"\" 希尔排序 最坏情况 O(n²) 平均情况小于 O(n²) :param li: :param gap: :return: \"\"\" for i in range(gap, len(li)): tmp = li[i] j = i - gap while j >= 0 and li[j] > tmp: li[j + gap] = li[j] j -= gap li[j + gap] = tmp def shell_sort(li): d = len(li) // 2 while d >= 1: insert_sort_gap(li, d) d //= 2 import random li = [random.randint(1, 1000) for _ in range(100)] print(li) shell_sort(li) print(li) console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"ji-shu-pai-xu.html":{"url":"ji-shu-pai-xu.html","title":"计数排序","keywords":"","body":"计数排序： 计数排序是一种非比较排序，其核心是将序列中的元素作为键存储在额外的数组空间中，而该元素的个数作为值存储在数组空间中，通过遍历该数组排序。 时间复杂度 O(n) 空间复杂度 O(n) def count_sort(data_list, max_count=100): count = [0 for _ in range(max_count + 1)] for val in data_list: count[val] += 1 data_list.clear() for i, v in enumerate(count): for j in range(v): data_list.append(i) import random li = [random.randint(1, 100) for i in range(100)] random.shuffle(li) print(li) count_sort(li) print(li) console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"tong-pai-xu-ff08-bucket-sort.html":{"url":"tong-pai-xu-ff08-bucket-sort.html","title":"桶排序（bucket_sort）","keywords":"","body":"桶排序：（Bucket sort）或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶里。每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），最后依次把各个桶中的记录列出来记得到有序序列。桶排序是鸽巢排序的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间（Θ(n)）。但桶排序并不是比较排序，他不受到O(n log n)下限的影响。 def bucket_sort(li, n=100, max_num=1000): \"\"\" 桶排序 时间复杂度 O(n+k) 最坏情况 O(n²+k) 空间复杂度 O(nk) :param li: :param n: :param max_num: :return: \"\"\" buckets = [[] for _ in range(n)] # 创建桶 for v in li: i = min(v // (max_num // n), n - 1) # i 表示 v 放到几号桶 buckets[i].append(v) # 把 v 加到桶里 # 保持桶内的顺序 for j in range(len(buckets[i]) - 1, 0, -1): if buckets[i][j] console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"ji-6570-pai-xu.html":{"url":"ji-6570-pai-xu.html","title":"基数-排序","keywords":"","body":"基数排序: 数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。 时间复杂度 O(n*k) 空间复杂度 O(n+m) def radix_sort(data_list): max_num = max(data_list) # 最大值 9->1,99->2,888->3 print(max_num) it = 0 while 10 ** it console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"leetcode.html":{"url":"leetcode.html","title":"leetcode","keywords":"","body":" console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"easy.html":{"url":"easy.html","title":"easy","keywords":"","body":" console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"1liang-shu-zhi-he.html":{"url":"1liang-shu-zhi-he.html","title":"1.两数之和","keywords":"","body":"1. 两数之和 题意：排序，记录索引和值，遍历一次，中间使用二分查找第二个值(target - x)。 时间复杂度: O(n log(n)) 空间复杂度: O(1) # 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 # # 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 # # 你可以按任意顺序返回答案。 # # # # 示例 1： # # # 输入：nums = [2,7,11,15], target = 9 # 输出：[0,1] # 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 # # # 示例 2： # # # 输入：nums = [3,2,4], target = 6 # 输出：[1,2] # # # 示例 3： # # # 输入：nums = [3,3], target = 6 # 输出：[0,1] # # # # # 提示： # # # 2 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"leetcode/easy/20.-you-xiao-de-kuo-hao.html":{"url":"leetcode/easy/20.-you-xiao-de-kuo-hao.html","title":"20.有效的括号","keywords":"","body":"20.有效的括号20.有效的括号 题意：左右括号是否闭合，我们利用栈进行匹配，入栈(判断下一个是否为) 时间复杂度: O(n) 空间复杂度: O(n) # 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。 # # 有效字符串需满足： # # # 左括号必须用相同类型的右括号闭合。 # 左括号必须以正确的顺序闭合。 # 每个右括号都有一个对应的相同类型的左括号。 # # # # # 示例 1： # # # 输入：s = \"()\" # 输出：true # # # 示例 2： # # # 输入：s = \"()[]{}\" # 输出：true # # # 示例 3： # # # 输入：s = \"(]\" # 输出：false # # # # # 提示： # # # 1 bool: mapping = {\"{\": \"}\", \"(\": \")\", \"[\": \"]\", \"?\": \"?\"} stack = [\"?\"] for i in s: if i in mapping: stack.append(i) elif mapping[stack.pop()] != i: return False return len(stack) == 1 print(Solution().isValid(\")\")) print(Solution().isValid(\"()\")) print(Solution().isValid(\"()[]{}\")) print(Solution().isValid(\"(]\")) print(Solution().isValid(\"([)]\")) console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"242you-xiao-de-zi-mu-yi-wei-ci.html":{"url":"242you-xiao-de-zi-mu-yi-wei-ci.html","title":"242.有效的字母异位词","keywords":"","body":"242. 有效的字母异位词 题意：利用字典将值出现的次数记录, 然后检查字典是否相同即可判断 时间复杂度: O(n) 空间复杂度: O(n) # 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。 # # 注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。 # # # # 示例 1: # # # 输入: s = \"anagram\", t = \"nagaram\" # 输出: true # # # 示例 2: # # # 输入: s = \"rat\", t = \"car\" # 输出: false # # # # 提示: # # # 1 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"medium.html":{"url":"medium.html","title":"medium","keywords":"","body":" console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"medium/74sou-suo-er-wei-ju-zhen.html":{"url":"medium/74sou-suo-er-wei-ju-zhen.html","title":"74.搜索二维矩阵","keywords":"","body":"74. 搜索二维矩阵 题意：二维数组，有序，遍历外层数据，在使用二分查找。 时间复杂度: O(log(M*N)) 空间复杂度: O(1) # 编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性： # # # 每行中的整数从左到右按升序排列。 # 每行的第一个整数大于前一行的最后一个整数。 # # # # # 示例 1： # # # 输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3 # 输出：true # # # 示例 2： # # # 输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13 # 输出：false # # # # # 提示： # # # m == matrix.length # n == matrix[i].length # 1 i[end]: continue while start + 1 i[mid]: start = mid else: end = mid if target == i[start] or target == i[end]: return True return False class Solution(object): def searchMatrix(self, matrix, target): \"\"\" 优雅解法 时间复杂度O(log(M*N)) 空间复杂度O(1) :type matrix: List[List[int]] :type target: int :rtype: bool \"\"\" if not matrix: return False h, w = len(matrix), len(matrix[0]) start, end = 0, w * h - 1 while start console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"medium/167liang-shu-zhi-he-ii-shu-ru-you-xu-shu-zu.html":{"url":"medium/167liang-shu-zhi-he-ii-shu-ru-you-xu-shu-zu.html","title":"167.两数之和 II - 输入有序数组","keywords":"","body":"167. 两数之和 II - 输入有序数组 题意：有序查找直接二分，遍历一次，中间使用二分查找第二个值(target - x)。 时间复杂度: O(n log(n)) 空间复杂度: O(1) # 给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列 ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这 # 两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"leetcode/medium/lcr-103.-ling-qian-dui-huan.html":{"url":"leetcode/medium/lcr-103.-ling-qian-dui-huan.html","title":"LCR 103. 零钱兑换","keywords":"","body":"LCR 103. 零钱兑换LCR 103. 零钱兑换 # 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 # -1。 # # 你可以认为每种硬币的数量是无限的。 # # # # 示例 1： # # # 输入：coins = [1, 2, 5], amount = 11 # 输出：3 # 解释：11 = 5 + 5 + 1 # # 示例 2： # # # 输入：coins = [2], amount = 3 # 输出：-1 # # 示例 3： # # # 输入：coins = [1], amount = 0 # 输出：0 # # # 示例 4： # # # 输入：coins = [1], amount = 1 # 输出：1 # # # 示例 5： # # # 输入：coins = [1], amount = 2 # 输出：2 # # # # # 提示： # # # 1 int: dp = [float('inf')] * (amount + 1) dp[0] = 0 for c in coins: for x in range(c, amount + 1): dp[x] = min(dp[x], dp[x - c] + 1) return dp[amount] if dp[amount] != float('inf') else -1 # leetcode submit region end(Prohibit modification and deletion) print(Solution().coinChange([1, 2, 5], 11)) console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"leetcode/hard.html":{"url":"leetcode/hard.html","title":"hard","keywords":"","body":"hardhard console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"shu-ju-jie-gou/":{"url":"shu-ju-jie-gou/","title":"数据结构","keywords":"","body":"数据结构数据结构与数据类型数据结构是什么数据结构与数据类型数据结构 数据结构与数据类型 数据结构是什么 1、简单来说，数据结构就是设计数据以何种方式存储在计算机中 2、比如：列表，集合，与字典 等都是一种数据结构 3、程序=数据结构+算法 数据结构与数据类型 1）数据类型： 说明：数据类型是==一个值的集合和定义在此集合上一组操作==（通常是增删改查或者操作读写的方法）的总称 数据类型：==int、str、boolean、byte== 2）数据结构： 说明：==数据以什么方式构成，如何进行存储==（数据结构是数据类型中的一种：结构类型） 数据结构：数组、栈、队列、链表、树、图、堆、散列表等 python数据结构：列表、集合、字典、元祖 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"shu-ju-jie-gou/shu-zu-array.html":{"url":"shu-ju-jie-gou/shu-zu-array.html","title":"数组(Array)","keywords":"","body":"数组(Array)数组(Array) 定义：数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。 python列表定义：支持存储多种数据类型，内存地址不是连续的。 数组：因为数据类型相同，存储的是连续的内存空间 查找：O(1) 插入：O(n) 删除：O(n) 插入演示 删除演示 python列表：因为数据类型相同，存储的是连续的内存空间 查找：O(n) 插入：O(n) 删除：O(1) python 实现 Array import array # 创建一个存储整型的array arr1 = array.array('i', [1, 2, 3, 4, 5, 6]) arr2 = array.array('f', [1, 2, 3, 4, 5, 6]) arr3 = array.array('u', [u'a', u'b', u'c']) print(arr1) print(arr2) print(arr3) console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"shu-ju-jie-gou/zhan-stack/":{"url":"shu-ju-jie-gou/zhan-stack/","title":"栈(Stack)","keywords":"","body":"栈(Stack)定义python实现添加一些功能进阶写法 数字转二进制栈(Stack) 定义 栈是一个数据集合，可以理解为只能在一端进行插入或删除操作的列表。 特点：后进先出 （last-in, first-out） 概念：栈顶、栈底 栈的基本操作： 进栈 push O(1) 出栈 pop O(1) 取栈顶 gettop O(1) 进栈 出栈 python实现 class Stack(object): def __init__(self): self.stack = [] def push(self, item): \"\"\" 入栈 :param item: :return: \"\"\" self.stack.append(item) def get_top(self): \"\"\" 获取栈顶元素 :return: \"\"\" return self.stack[-1] def pop(self): \"\"\" 出栈 :return: \"\"\" return self.stack.pop() if __name__ == '__main__': s = Stack() s.push(1) s.push(2) print(s.stack) print(s.get_top()) print(s.pop()) print(s.get_top()) 添加一些功能 \"\"\" Stack() 创建一个新的空栈 push(item) 添加一个新的元素item到栈顶 pop() 弹出栈顶元素 peek() 返回栈顶元素 is_empty() 判断栈是否为空 size() 返回栈的元素个数 \"\"\" class Stack(): \"\"\"创建一个新的空栈类\"\"\" def __init__(self): \"\"\"创建一个新的空栈\"\"\" self.alist = [] def push(self, item): \"\"\"添加一个新的元素item到栈顶\"\"\" self.alist.append(item) def pop(self): \"\"\"弹出栈顶元素\"\"\" if self.alist == []: return None else: return self.alist.pop() def peek(self): \"\"\"返回栈顶元素\"\"\" if self.alist == []: return None else: return self.alist[-1] def is_empty(self): \"\"\"判断栈是否为空\"\"\" return self.alist == [] def size(self): \"\"\"返回栈的元素个数\"\"\" return len(self.alist) if __name__ == '__main__': s = Stack() print(s.is_empty()) print(s.size()) s.push(1) s.push(2) s.push(3) s.push(4) s.push(5) print(s.size()) print(s.pop()) print(s.size()) print(s.is_empty()) print(s.peek()) 进阶写法 数字转二进制 class MyStack: def __init__(self): self.s = [] def push(self, x: int) -> None: self.s.append(x) def pop(self) -> int: return self.s.pop() def size(self) -> int: return len(self.s) def empty(self) -> bool: return not bool(self.s) stack = MyStack() def trans_from(num: int) -> str: while num != 0: re_main = num % 2 print(\"re_main\", re_main) num = int(num / 2) print(\"num\", num) stack.push(re_main) s = \"\" while not stack.empty(): s += str(stack.pop()) return s if __name__ == '__main__': print(trans_from(12)) console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"shu-ju-jie-gou/zhan-stack/mi-gong-wen-ti.html":{"url":"shu-ju-jie-gou/zhan-stack/mi-gong-wen-ti.html","title":"迷宫问题","keywords":"","body":"迷宫问题迷宫问题 maze = [ [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 0, 1], [1, 0, 0, 1, 0, 0, 0, 1, 0, 1], [1, 0, 0, 0, 0, 1, 1, 0, 0, 1], [1, 0, 1, 1, 1, 0, 0, 0, 0, 1], [1, 0, 0, 0, 1, 0, 0, 0, 0, 1], [1, 0, 1, 0, 0, 0, 1, 0, 0, 1], [1, 0, 1, 1, 1, 0, 1, 1, 0, 1], [1, 1, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], ] dirs = [ lambda x, y: (x + 1, y), lambda x, y: (x - 1, y), lambda x, y: (x, y + 1), lambda x, y: (x, y - 1), ] def maze_path(x1: int, y1: int, x2: int, y2: int): \"\"\" 走出迷宫，采用dfs深度优先搜索，也叫回溯法，如果当前位置不可继续前进，那么则回退到上一个位置，重复如此。 时间复杂度: O(n) 空间复杂度: O(n) :param x1: 入口x :param y1: 入口y :param x2: 出口x :param y2: 出口y :return: [] 踪迹 \"\"\" stack = [(x1, y1)] while stack: cur_node = stack[-1] for d in dirs: next_node = d(cur_node[0], cur_node[1]) if next_node[0] == x2 and next_node[1] == y2: return stack if maze[next_node[0]][next_node[1]] == 0: stack.append(next_node) maze[next_node[0]][next_node[1]] = 2 break else: maze[next_node[0]][next_node[1]] = 2 stack.pop() return False if __name__ == '__main__': print(maze_path(1, 1, 8, 8)) console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"shu-ju-jie-gou/dui-lie-queue/":{"url":"shu-ju-jie-gou/dui-lie-queue/","title":"队列(Queue)","keywords":"","body":"队列(Queue)定义利用python包-队列使用方法手写队列队列应用场景队列(Queue) 定义 队列是一个数据集合，仅允许在列表的一端进行插入，另一端进行删除 插入的一端称为队尾（rear），插入动作叫进队或入队 O(1) 进行删除的一端称为对头（front），删除动作称为出队 O(1) 队列性质：先进先出（First-in, First-out） 双向队列：队列的两端都允许进行进队和出队操作 利用python包-队列使用方法 from queue import Queue #1. 基本FIFO队列 先进先出 FIFO即First in First Out,先进先出 #2. maxsize设置队列中，数据上限，小于或等于0则不限制，容器中大于这个数则阻塞，直到队列中的数据被消掉 q = Queue(maxsize=0) #3. 写入队列数据 q.put(0) q.put(1) q.put(2) #4. 输出当前队列所有数据 print(q.queue) #5. 删除队列数据，并返回该数据 q.get() #6. 输也所有队列数据 print(q.queue) 手写队列 class Queue: def __init__(self): self.q = [] def push(self, x: int) -> None: self.q.append(x) def pop(self) -> int: return self.q.pop(0) def is_empty(self) -> bool: return not bool(self.q) def size(self) -> int: return len(self.q) if __name__ == \"__main__\": q = Queue() q.push(1) q.push(2) q.push(3) print(q.pop()) print(q.pop()) print(q.is_empty()) print(q.size()) 队列应用场景 1.队列主要的功能是在多个进程间共享数据，实现业务解耦，提高效率 2.生产者线程只需要把任务放入队列中，消费者线程只需要到队列中取数据进行处理 注：队列与列表区别 列表中数据虽然是排列的，但数据被取走后还会保留，而队列中这个容器的数据被取后将不会保留 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"shu-ju-jie-gou/dui-lie-queue/shuang-xiang-dui-lie.html":{"url":"shu-ju-jie-gou/dui-lie-queue/shuang-xiang-dui-lie.html","title":"双向队列","keywords":"","body":"双向队列双向队列 python 内置模块，超出大小，顶出第一个，容量为3， 【0,1,2】，append(3)，【1,2,3】 from collections import deque q = deque() q.append(1) print(q.popleft()) q.appendleft(2) print(q.pop()) console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"shu-ju-jie-gou/dui-lie-queue/mi-gong-wen-ti.html":{"url":"shu-ju-jie-gou/dui-lie-queue/mi-gong-wen-ti.html","title":"迷宫问题","keywords":"","body":"迷宫问题迷宫问题 maze = [ [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 0, 1], [1, 0, 0, 1, 0, 0, 0, 1, 0, 1], [1, 0, 0, 0, 0, 1, 1, 0, 0, 1], [1, 0, 1, 1, 1, 0, 0, 0, 0, 1], [1, 0, 0, 0, 1, 0, 0, 0, 0, 1], [1, 0, 1, 0, 0, 0, 1, 0, 0, 1], [1, 0, 1, 1, 1, 0, 1, 1, 0, 1], [1, 1, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], ] dirs = [ lambda x, y: (x + 1, y), lambda x, y: (x - 1, y), lambda x, y: (x, y + 1), lambda x, y: (x, y - 1), ] def maze_path_queue(x1: int, y1: int, x2: int, y2: int): \"\"\" 走出迷宫，采用bfs广度优先搜索。 时间复杂度: O(n) 空间复杂度: O(n) :param x1: 入口x :param y1: 入口y :param x2: 出口x :param y2: 出口y :return: [] 踪迹 \"\"\" def print_r(path_): \"\"\" 打印路径 :param path_: 走过的路径 :return: \"\"\" # 最后一个节点 cur_node_ = path_[-1] # real_path = [] # 到起点结束 while cur_node_[2] != -1: # 记录路径 real_path.append(cur_node_[0:2]) # 走过了哪些 cur_node_ = path_[cur_node_[2]] # 记录起点 real_path.append(cur_node_[0:2]) # 反转 real_path.reverse() for node in real_path: # 打印路径 print(node) # 创建队列 queue = collections.deque() # 添加初始值，也就是起点 queue.append((x1, y1, -1)) # 记录走过的路径 path = [] while queue: # 获取当前走到的点位 cur_node = queue.popleft() # 记录走过的点位 path.append(cur_node) # 如果到达出口则结束 if cur_node[0] == x2 and cur_node[1] == y2: print_r(path) return True # 上下左右四个方向行走 for dir in dirs: # 下一步 next_node = dir(cur_node[0], cur_node[1]) # 是否可以走 if maze[next_node[0]][next_node[1]] == 0: # 可以走则记录，继续走 queue.append((next_node[0], next_node[1], len(path) - 1)) # 标记已经走过的 maze[next_node[0]][next_node[1]] = 3 print(\"没有路\") return False if __name__ == \"__main__\": maze_path_queue(1, 1, 8, 8) console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"shu-ju-jie-gou/lian-biao-linked-list/":{"url":"shu-ju-jie-gou/lian-biao-linked-list/","title":"链表(Linked List)","keywords":"","body":"链表(Linked List)单链表定义python模拟单链表单向链表反转链表时间复杂度链表(Linked List) 单链表定义 链表是由一系列节点组成的元素集合。每个 节点包含两部分,数据域item和指向下一个 节点的指针next。通过节点之间的相互连接, 最终串联成一个链表。 注：链表中每个元素都是一个对象，每个对象称为一个节点 每个节点包含两部分： 数据域： 存放当前节点数据 指针域： 指向下一个节点的内存地址 (1) (1).png>) 插入演示 删除演示 python模拟单链表 class Linked: def __init__(self, item: int, next=None): self.item = item self.next = next l = Linked(1, Linked(2, Linked(3, Linked(4)))) print(l) print(l.item) print(l.next.item) print(l.next.next.item) 单向链表反转 class Linked: def __init__(self, item: int, next: int = None): self.item = item self.next = next def list_reverse(head=None): if head is None: return None L, R, cur = None, None, head # 左指针 右指针 游标 while cur.next is not None: L = R # 左侧指针指向以前右侧指针位置 R = cur # 右侧指针前进一位指向当前游标位置 cur = cur.next # 游标每次向前进一位 R.next = L # 右侧指针指向左侧实现反转 cur.next = R # 当跳出 while 循环时 cur(原链表最后一个元素) R(原链表倒数第二个元素) return cur ''' 原始链表：1 -> 2 -> 3 -> 4 反转链表：4 -> 3 -> 2 -> 1 ''' L = Linked(1) L.next = Linked(2) L.next.next = Linked(3) L.next.next.next = Linked(4) print(L.item) print(L.next.item) print(L.next.next.item) l = list_reverse(L) print(l.item) print(l.next.item) print(l.next.next.item) 链表时间复杂度 从链表中取出一个元素，时间复杂度： O(n) n代表列表长度 遍历链表： O(N) 删除一个链表中的元素：O(1) console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"shu-ju-jie-gou/lian-biao-linked-list/tou-cha-fa-wei-cha-fa.html":{"url":"shu-ju-jie-gou/lian-biao-linked-list/tou-cha-fa-wei-cha-fa.html","title":"头插法&尾插法","keywords":"","body":"头插法&尾插法头插法尾插法头插法&尾插法 class Linked: def __init__(self, item: int, next: int = None): self.item = item self.next = next 头插法 def head_create_linked(li: list) -> Linked: \"\"\" 头插法 :param li: 输入列表 :return: type(Linked) \"\"\" head = Linked(li[0]) for cur in li[1:]: node = Linked(cur) node.next = head head = node return head def print_linked(linked): if linked: print(linked.item, end=\",\") print_linked(linked.next) node = head_create_linked([1, 2, 3]) print_linked(node) 尾插法 def tail_create_linked(li: list) -> Linked: \"\"\" 尾插法 :param li: 输入列表 :return: type(Linked) \"\"\" head = Linked(li[0]) tail = head for cur in li[1:]: node = Linked(cur) tail.next = node tail = node return head node = tail_create_linked([1, 2, 3]) print_linked(node) console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"shu-ju-jie-gou/shuang-lian-biao-doubly-linked-list.html":{"url":"shu-ju-jie-gou/shuang-lian-biao-doubly-linked-list.html","title":"双链表(Doubly Linked List)","keywords":"","body":"双链表(Doubly Linked List)创建插入删除双链表(Doubly Linked List) 创建 插入 删除 class DoubleLinked: def __init__(self, item: int = None, next: int = None, prior: int = None): self.next = next self.item = item self.prior = prior class DoubleLinkedFunc: def __init__(self): self.lt = [1, 2, 3, 4] def create_linked(self): \"\"\" 插入 :return: \"\"\" node = DoubleLinked(self.lt[0]) tail = node for cur in self.lt[1:]: cur_node = DoubleLinked(cur) tail.next = cur_node cur_node.prior = node.item tail = cur_node return node def delete_linked(self): \"\"\" 删除 :return: \"\"\" node = self.create_linked() p = node.next node.next = p.next p.next.prior = node del p return node def print_linked(self, linked): if linked: print(linked.item, end=\",\") self.print_linked(linked.next) f = DoubleLinkedFunc() linked = f.create_linked() f.print_linked(linked) linked = f.delete_linked() print() f.print_linked(linked) console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"shu-ju-jie-gou/ha-xi-biao-or-san-lie-biao-hash-table/":{"url":"shu-ju-jie-gou/ha-xi-biao-or-san-lie-biao-hash-table/","title":"哈希表 or 散列表(Hash Table)","keywords":"","body":"哈希表 or 散列表(Hash Table)直接寻址表哈希表字典如何存储的呢?hash table的应用解决hash冲突python字典操作时间复杂度哈希表 or 散列表(Hash Table) 直接寻址表 直接寻址表缺点 哈希表 直接寻址表 + hash = 哈希表 注：字典类型是Python中最常用的数据类型之一，它是一个键值对的集合，字典通过键来索引，关联到相对的值，理论上它的查询复杂度是 O(1) 哈希表一个通过哈希函数来计算数据存储位置的数据结构,通常支持如下操作: insert(key,value):插入键值对(key,value) get(key):如果存在键为key的键值对则返回其value,否则返回空值 delete(key):删除键为key的键值对 哈希表 (hash tables) 1.哈希表（也叫散列表），根据关键值对(Key-value)而直接进行访问的数据结构。 2.它通过把key和value映射到表中一个位置来访问记录，这种查询速度非常快，更新也快。 3.而这个映射函数叫做哈希函数，存放值的数组叫做哈希表。 4.通过把每个对象的关键字k作为自变量，通过一个哈希函数h(k)，将k映射到下标h(k)处，并将此对象存储在这个位置。 具体操作过程 1.数据添加： 把key通过哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余 取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。 2.数据查询：再次使用哈希函数将key转换为对应的数组下标，并定位到数组的位置获取value。 除法哈希法: h(k) = k % m 乘法哈希法: h(k) = floor(m*(Akey%1)) _全域哈希法: ha,b(k) = ((a_key + b) mod p) mod m a,b=1,2,...p-1 字典如何存储的呢? 1.比如字典{“name”:”zhangsan”,”age”:26}，那么他们的字典key为name、age，假如哈希函数h(“name”)=1、h(“age”)=3, 2.那么对应字典的key就会存储在列表对应下标的位置，[None,“zhangsan”,None,26] hash table的应用 字典与集合都是通过哈希表来实现的。 a = {'name': 'Alex', 'age': 18, 'gender': 'Man'} 使用哈希表存储字典,通过哈希函数将字典的键映射为下标。 假设h('name')= 3,h('age') = 1, h(gender')=4,则哈希表存储为[None, 18, Norhe, 'Alex', 'Man'] 如果发生哈希冲突,则通过拉链法或开发寻址法解决 MD5(Message-Digest Algorithm5)曾经是密码学中常用的哈希函数,可以把任意长度的数据映射为 128位的哈希值,其曾经包含如下特征: 1. 同样的消息,其MD5值必定相同; 2. 可以快速计算出任意给定消息的MD5值; 3. 除非暴力的枚举所有可能的消息,否则不可能从哈希值反推出消息本身; 4. 两条消息之间即使只有微小的差别,其对应的MD5值也应该是完全不同、完全不相关的; 5. 不能在有意义的时间内人工的构造两个不同的消息 使其具有相同的MD5值。 历史上MD5和SHA-1曾经是使用最为广泛的cryptographic hashfunction,但是随着密码 学的发展,这两个哈希函数的安全性相继受到了各种挑战。（比特币） 因此现在安全性较重要的场合推荐使用SHA-2等新的更安全的哈希函数。 SHA-2包含了一系列的哈希函数:SHA-224,SHA-256,SH/A-384, SHA-512, SHA-512/224,SHA-512/256,其对应的哈希值长度分别为224,256,384 or 512位。 SHA-2具有和MD5类似的性质(参见MD5算法的特征)。 解决hash冲突 拉链法 哈希表每个位置都连接一个 链表,当冲突发生时,冲突的元素将 被加到该位置链表的最后。 开放寻址法 线性探查:如果位置i被占用,则探查i+1, i+2,...... 二次探查:如果位置i被占用,则探查i+12,i-12,i+22,i-22,....... 二度哈希:有n个哈希函数,当使用第1个哈希函数h1发生冲突时,则尝试使 用h2,h3,...... python字典操作时间复杂度 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"shu-ju-jie-gou/ha-xi-biao-or-san-lie-biao-hash-table/python-dai-ma-shi-xian-hash-table.html":{"url":"shu-ju-jie-gou/ha-xi-biao-or-san-lie-biao-hash-table/python-dai-ma-shi-xian-hash-table.html","title":"python代码实现hash table","summary":"hash","keywords":"","body":"python代码实现hash tablepython代码实现hash table class LinkedList: class Node: \"\"\" 链表 \"\"\" def __init__(self, item): self.item = item self.next = None class LinkListIterator: \"\"\" 链表迭代器 \"\"\" def __init__(self, node): self.node = node def __next__(self): \"\"\" 返回下一节点 \"\"\" if self.node: cur_node = self.node self.node = cur_node.next return cur_node.item else: raise StopIteration def __iter__(self): \"\"\" 返回本身 \"\"\" return self def __init__(self, iterable=None): self.head = None self.tail = None if iterable: self.extend(iterable) def append(self, obj): \"\"\" 添加元素 \"\"\" s = LinkedList.Node(obj) if not self.head: self.head = s self.tail = s else: self.tail.next = s self.tail = s def extend(self, iterable): \"\"\" 追加元素 \"\"\" for obj in iterable: self.append(obj) def find(self, obj): \"\"\" 查找元素 \"\"\" for n in self: if n == obj: return True else: return False def __iter__(self): \"\"\"迭代\"\"\" return self.LinkListIterator(self.head) def __repr__(self): \"\"\"输出值\"\"\" return \">\" class HashTable: def __init__(self, size: int = 101): \"\"\"构建大小\"\"\" self.size = size self.T = [LinkedList() for i in range(self.size)] def h(self, k): \"\"\"hash函数\"\"\" return k % self.size def insert(self, k): \"\"\"插入\"\"\" i = self.h(k) if self.find(k): print(\"Duplicated hash table\") else: self.T[i].append(k) def find(self, k): \"\"\"查找\"\"\" i = self.h(k) return self.T[i].find(k) hash_table = HashTable() hash_table.insert(0) hash_table.insert(1) hash_table.insert(3) hash_table.insert(102) hash_table.insert(508) print(\",\".join(map(str, hash_table.T))) console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"shu-ju-jie-gou/shu/":{"url":"shu-ju-jie-gou/shu/","title":"树","keywords":"","body":"树树的概念树的特性二叉树满二叉树完全二叉树树的特点树的特性模拟文件夹操作树 树的概念 树的特性 1）一棵树中的任意两个结点有且仅有唯一的一条路径连通； 2）一棵树如果有n个结点，则它一定有n−1条边； 3）在一棵树中加一条边将会构成一个回路。 二叉树 1）二叉树是一种特殊的树，二叉树的特点是每个结点最多有两个儿子。 2）二叉树使用范围最广，一颗多叉树也可以转化为二叉树。 满二叉树 1）二叉树中每个内部节点都有两个儿子，满二叉树所有的叶节点都有相同的深度。 2）满二叉树是一棵深度为h且有2h−1个结点的二叉树。 完全二叉树 1）若设二叉树的高度为h，除了第h层外，其他层的结点数都达到最大个数，第h层从右向左连续 缺若干个结点，则为完全二叉树。 树的特点 1、如果一棵完全二叉树的父节点编号为K,则其左儿子的编号是2K,右儿子的结点编号为2K+1 2、已知完全二叉树的总节点数为n求叶子节点个数： 当n为奇数时：（n+1）/2 当n为偶数时 : （n）/2 3、已知完全二叉树的总节点数为n求父节点个数：为：n/2 4、已知完全二叉树的总节点数为n求叶子节点为2的父节点个数： 当n为奇数时：n/2 当n为偶数时 : n/2-1 5、如果一棵完全二叉树有N个结点，那么这棵二叉树的深度为【log2（N+1）log2（N+1）】（向上取整） 树的特性模拟文件夹操作 \"\"\" 树模拟文件夹 \"\"\" class Node: def __init__(self, name, ty=\"dir\"): \"\"\" :param name: 目录名称 :param ty: 类型 \"\"\" self.name = name self.type = ty self.parent = None self.children = [] def __repr__(self): \"\"\"返回展示名称而非内存地址\"\"\" return self.name class FileTree: def __init__(self): self.root = Node(\"/\") self.now = self.root def mkdir(self, name): \"\"\" 创建目录 :param name: 新目录名称 :return: \"\"\" if name[-1] != \"/\": name += \"/\" # 创建该节点 node = Node(name) # 为根目录添加当前节点 self.now.children.append(node) def ls(self): \"\"\" 返回当前目录下的所有节点 :return: \"\"\" return self.now.children def cd(self, name): \"\"\" 进入指定目录 :param name: 目录名称 :return: \"\"\" if name[-1] != \"/\": name += \"/\" # 判断是否为返回上一级 if name == \"../\": self.now = self.now.parent return # 寻找到指定的目录 for child in self.now.children: if child.name == name: self.now = child return # 没有查找的目录抛出异常 raise ValueError(\"invalid dir\") tree = FileTree() tree.mkdir(\"bin\") tree.mkdir(\"etc\") print(\"---\", tree.ls()) tree.cd(\"etc\") print(\"---\", tree.ls()) console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"shu-ju-jie-gou/shu/er-cha-shu-binary-tree.html":{"url":"shu-ju-jie-gou/shu/er-cha-shu-binary-tree.html","title":"二叉树(binary tree)","keywords":"","body":"二叉树(binary tree)定义二叉树基本操作前序遍历中序遍历后序遍历分层打印二叉树二叉树(binary tree) 定义 二叉树的链式存储:将二叉树的节点定义为一个对象,节点之间通过类似链表的链接方式来连接。 二叉树是一种特殊的树数据结构，其中每个节点最多有两个子节点，通常被称为左子节点和右子节点。 下面是二叉树数据结构的一种通用定义 class Tree: def __init__(self, value=None, left=None, right=None): self.value = value self.left = left # 左子树 self.right = right # 右子树 在这个定义中，TreeNode 表示二叉树的一个节点。每个节点有三个属性： val: 存储节点的值。 left: 指向左子节点的指针。 right: 指向右子节点的指针。 当 left 和 right 都为 None 时，这个节点被称为叶子节点。.png>) 二叉树基本操作 数遍历说明 1. 前序遍历： DBACEGF（根节点排最先，然后同级先左后右） 2. 中序遍历： ABCDEFG (先左后根最后右） 3. 后序遍历： ACBFGED （先左后右最后根） 生成树结构 class Tree: def __init__(self, value=None, left=None, right=None): self.value = value self.left = left # 左子树 self.right = right # 右子树 # 生成树 T = Tree(\"D\", Tree(\"B\", Tree(\"A\"), Tree(\"C\")), Tree(\"E\", right=Tree(\"G\", Tree(\"F\")))) \"\"\" D /\\ B E /\\ \\ A C G / F \"\"\" 前序遍历 def pre_traverse(tree): \"\"\" 前序遍历 根 左 右（根节点排最先，然后同级先左后右） :param tree: 二叉树 :return: \"\"\" if tree is None: return print(tree.value) pre_traverse(tree.left) pre_traverse(tree.right) print(\"前序遍历\") pre_traverse(T) 前序遍历步骤推演 前序排列原理： #####此时执行preTraverse(root.left) 函数 ''' 1、第一步 root=Node(D) print D，D入栈[D] 2、第二步 root=Node(D).left=Node(B) print B, B入栈[D,B] 3、第三步 root=Node(B).left=Node(A) print A, A入栈[D,B,A] 4、第四步 root=Node(A).left=None,没有进入递归，顺序执行preTraverse(root.right) 5、第五步 Node(A).right==None，也没有进入递归，此时preTraverse(A) 函数才会正真返回，A出栈[D,B] 6、第六步 A的上级调用函数为：preTraverse(B.left),所以接着会顺序执行preTraverse(B.right),B的左右节点访问后B出栈[D] 7、第七步 Node(B).right==Node(C) print C,C入栈[D,C] 8、第八步 Node(C).left==None, Node(C).right==None,访问完C的左右节点后函数返回C出栈，返回上级调用[D] 9、第九步 此时返回上级调用执行preTraverse(D.right)=Node(E) print E,D出栈，E入栈[E] ''' '''此时输出结果：DBACE''' 中序遍历 def mid_traverse(tree): \"\"\" 中序遍历 左根右（先左 后根 最后右） :param tree: :return: \"\"\" if tree is None: return mid_traverse(tree.left) print(tree.value) mid_traverse(tree.right) print(\"中序遍历\") mid_traverse(T) 后序遍历 def after_traverse(tree): \"\"\" 后序遍历 左右根（先左 后右 最后根） :param tree: :return: \"\"\" if tree is None: return after_traverse(tree.left) after_traverse(tree.right) print(tree.value) print(\"后序遍历\") after_traverse(T) 分层打印二叉树 def layered_print(tree): \"\"\" 分层打印二叉树 :param tree: :return: \"\"\" if not tree: return cur_layer = [tree] while cur_layer: layer_value = [] next_layer = [] for t in cur_layer: layer_value.append(t.value) if t.left: next_layer.append(t.left) if t.right: next_layer.append(t.right) print(layer_value) cur_layer = next_layer print(\"分层打印\") layered_print(T) console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"shu-ju-jie-gou/shu/er-cha-sou-suo-shu-binary-search-treebst.html":{"url":"shu-ju-jie-gou/shu/er-cha-sou-suo-shu-binary-search-treebst.html","title":"二叉搜索树(Binary Search Tree，BST)","keywords":"","body":"二叉搜索树(Binary Search Tree，BST)定义二叉搜索树操作二叉搜索树(Binary Search Tree，BST) 定义 二叉搜索树是一颗二叉树且满足性质:设x 是二叉树的一个节点。如果y是x左子树的 一个节点,那么y.key \\ 二叉搜索树（）是一种特殊的二叉树数据结构，它具有以下特点： 每个节点最多有两个子节点，分别称为左子节点和右子节点。 对于任意节点，其左子树中的所有节点的值都小于该节点的值，而其右子树中的所有节点的值都大于该节点的值。 对于任意节点的左子树和右子树，它们也分别是二叉搜索树。 由于这些特性，二叉搜索树可以高效地支持以下操作： 插入（Insertion）：将一个新节点插入到树中的适当位置，保持二叉搜索树的性质。 查找（Search）：在树中搜索一个特定的值，根据节点的值与目标值的大小关系，递归地在左子树或右子树中进行搜索。 删除（Deletion）：从树中删除一个节点，需要考虑多种情况并保持二叉搜索树的性质。 二叉搜索树在很多应用中都有广泛的应用，例如在数据检索、排序和存储等领域。它提供了一种高效的数据结构，可以快速地进行插入、查找和删除操作。 二叉搜索树操作 class BinarySearchTree: def __init__(self, val, parent=None): self.val = val self.l_children = None self.r_children = None self.parent = parent class BST: def __init__(self, li): self.root = None if li: for i in li: # self.root = self.insert_recursion(self.root, i) self.insert(i) def insert_recursion(self, node, val): \"\"\" :param node: 当前节点 :param val:当前值 :return: \"\"\" if not node: node = BinarySearchTree(val) # 左子树 elif val node.val: node.r_children = self.insert_recursion(node.r_children, val) node.r_children.parent = node return node def insert(self, val): \"\"\" :param val: 当前值 :return: \"\"\" # 生成节点 p = self.root if not p: self.root = BinarySearchTree(val) return while 1: # 左节点 if val p.val: if p.r_children: p = p.r_children else: p.r_children = BinarySearchTree(val) p.r_children.parent = p return else: return def query(self, node, val): if not node: return if val > node.val: return self.query(node.r_children, val) elif val val: p = p.l_children else: return p return def __remove_node_1(self, node): if not node.parent: self.root = None if node == node.parent.l_children: node.parent.l_children = None else: node.parent.r_children = None def __remove_node_21(self, node): if not node.parent: self.root = node.l_chirdren node.l_chirdren.parent = None elif node == node.parent.l_children: node.parent.l_children = node.l_children node.l_children.parent = node.parent else: node.parent.r_children = node.l_children node.l_children.parent = node.parent def __remove_node_22(self, node): if not node.parent: self.root = node.r_chirdren elif node == node.parent.l_children: node.parent.l_children = node.r_children node.r_children.parent = node.parent else: node.parent.r_children = node.r_children node.r_children.parent = node.parent def delete_node(self, val): if self.root: node = self.query_no_rec(val) if not node: return False if not node.l_children and not node.r_children: self.__remove_node_1(node) elif not node.r_children: self.__remove_node_21(node) elif not node.l_children: self.__remove_node_22(node) else: min_node = node.r_children while min_node.l_children: min_node = min_node.l_children node.val = min_node.val if min_node.r_children: self.__remove_node_22(min_node) else: self.__remove_node_1(min_node) tree = BST([4, 6, 7, 9, 2, 1, 3]) print(tree.query(tree.root, 3).val) print(tree.query_no_rec(3).val) print(tree.delete_node(3)) print(tree.delete_node(9)) print(tree.delete_node(1)) def pre_traverse(tree): \"\"\" 前序遍历 根 左 右（根节点排最先，然后同级先左后右） :param tree: 二叉树 :return: \"\"\" if tree is None: return print(tree.val, end=\",\") pre_traverse(tree.l_children) pre_traverse(tree.r_children) pre_traverse(tree.root) print(\"前序遍历\") def mid_traverse(tree): \"\"\" 中序遍历 左根右（先左 后根 最后右） :param tree: :return: \"\"\" if tree is None: return mid_traverse(tree.l_children) print(tree.val, end=\",\") mid_traverse(tree.r_children) mid_traverse(tree.root) print(\"中序遍历\") def after_traverse(tree): \"\"\" 后序遍历 左右根（先左 后右 最后根） :param tree: :return: \"\"\" if tree is None: return after_traverse(tree.l_children) after_traverse(tree.r_children) print(tree.val, end=\",\") after_traverse(tree.root) print(\"后序遍历\") console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"shu-ju-jie-gou/shu/b-tree-b+tree.html":{"url":"shu-ju-jie-gou/shu/b-tree-b+tree.html","title":"B-tree/B+tree","keywords":"","body":"B-tree/B+treeB-tree/B+treeB-tree/B+tree B-tree/B+tree B-Tree 每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。 两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。 以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。 模拟查找关键字29的过程 '''模拟查找关键字29的过程：''' # 根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】 # 比较关键字29在区间（17,35），找到磁盘块1的指针P2。 # 根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】 # 比较关键字29在区间（26,30），找到磁盘块3的指针P2。 # 根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】 # 在磁盘块8中的关键字列表中找到关键字29。 B+tree B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。 B-Tree结构图中可以看到每个节点中不仅包含数据的key值，还有data值 而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小 当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。 在B+Tree中，所有根节点只存储 键和指针，只有叶子节点才存放数据 MySQL底层索引存储 1.InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节 2.也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值（这里的K取值为〖10〗^3）。 3.也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿 条记录。 说明： 实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2~4层。 mysql的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"shu-ju-jie-gou/shu/hash-shu.html":{"url":"shu-ju-jie-gou/shu/hash-shu.html","title":"Hash 树","keywords":"","body":"Hash 树hash树hash树介绍hash树操作hash树特点Hash 树 hash树 hash树介绍 hash树描述（就是散列树） 1.散列树选择从2开始的连续质数来建立一个十层的哈希树。 2.第一层结点为根结点，根结点下有2个结点； 3.第二层的每个结点下有3个结点； 4.依此类推，即每层结点的子节点数目为连续的质数。 hash树特点 **注：**关系型数据库中，索引大多采用B/B+树来作为存储结构，而全文搜索引擎的索引则主要采用hash的存储结构，这两种数据结构有什么区别？ 1.如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值； 2.当然了，这个前提是，键值都是唯一的，如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据； 3.如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后， 　　　　　　有可能变成不连续的了，就没办法再利用索引完成范围查询检索； 4.同理，哈希索引也没办法利用索引完成排序，以及like‘xxx%’这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）； 建立hash树 1.选择从2开始的连续质数来建立一个十层的哈希树。 2.第一层结点为根结点，根结点下有2个结点；第二层的每个结点下有3个结点； 3.依此类推，即每层结点的子节点数目为连续的质数。到第十层，每个结点下有29个结点。 4.同一结点中的子结点，从左到右代表不同的余数结果。 例如：第二层结点下有三个子节点。那么从左到右分别代表：除3余0，除3余1，除3余2.对质数进行取余操作得到的余数决定了处理的路径。 5.以随机的10个数的插入为例，来图解HashTree的插入过程。 6.其实也可以把所有的键-值节点放在哈希树的第10层叶节点处，这第10层的满节点数就包含了所有的整数个数， 　　　　　但是如果这样处理的话，所有的非叶子节点作为键-值节点的索引，这样使树结构庞大，浪费空间。 hash树操作 查找编辑 1.哈希树的节点查找过程和节点插入过程类似，就是对关键字用质数序列取余，根据余数确定下一节点的分叉路径，直到找到目标节点。 2.如上图，最小”哈希树(HashTree)在从4G个对象中找出所匹配的对象，比较次数不超过10次，也就是说：最多属于O(10)。 3.在实际应用中，调整了质数的范围，使得比较次数一般不超过5次。 4.也就是说：最多属于O(5)，因此可以根据自身需要在时间和空间上寻求一个平衡点。 删除编辑 1.哈希树的节点删除过程也很简单，哈希树在删除的时候，并不做任何结构调整。 2.只是先查到到要删除的节点，然后把此节点的“占位标记”置为false即可（即表示此节点为空节点，但并不进行物理删除）。 hash树特点 hash树优点 1）结构简单 1.从哈希树的结构来说，非常的简单，每层节点的子节点个数为连续的质数。 2.子节点可以随时创建，因此哈希树的结构是动态的，也不像某些哈希算法那样需要长时间的初始化过程。 3.哈希树也没有必要为不存在的关键字提前分配空间。 2）查找迅速 1.从算法过程我们可以看出，对于整数，哈希树层级最多能增加到10。 2.因此最多只需要十次取余和比较操作，就可以知道这个对象是否存在，这个在算法逻辑上决定了哈希树的优越性。 3）结构不变 1.从删除算法中可以看出，哈希树在删除的时候，并不做任何结构调整。 2.常规树结构在增加元素和删除元素的时候都要做一定的结构调整，否则他们将可能退化为链表结构，而导致查找效率的降低。 3.哈希树采取的是一种“见缝插针”的算法，从来不用担心退化的问题，也不必为优化结构而采取额外的操作，因此大大节约了操作时间。 缺点编辑 1.哈希树不支持排序，没有顺序特性。 2.如果在此基础上不做任何改进的话并试图通过遍历来实现排序，那么操作效率将远远低于其他类型的数据结构。 hash索引使用范围 **总结：**哈希适用在小范围的精确查找，在列数据很大，又不需要排序，不需要模糊查询，范围查询时有用 1、hash索引仅满足“=”、“IN”和“”查询，不能使用范围查询 因为hash索引比较的是经常hash运算之后的hash值，因此只能进行等值的过滤，不能基于范围的查找， 因为经过hash算法处理后的hash值的大小关系，并不能保证与处理前的hash大小关系对应。 2、hash索引无法被用来进行数据的排序操作 由于hash索引中存放的都是经过hash计算之后的值，而hash值的大小关系不一定与hash计算之前的值一样 所以数据库无法利用hash索引中的值进行排序操作。 3、对于组合索引，Hash索引在计算Hash值的时候是组合索引键合并后再一起计算Hash值 而不是单独计算Hash值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash索引也无法被利用。 4、Hash索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。 对于选择性比较低的索引键，如果创建Hash索引，那么将会存在大量记录指针信息存于同一个Hash值相关联。 这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"shu-ju-jie-gou/shu/avl-shu.html":{"url":"shu-ju-jie-gou/shu/avl-shu.html","title":"AVL树","keywords":"","body":"AVL树定义插入AVL树 定义 AVL树是一棵自平衡的二叉搜索树。 AVL树具有以下性质: 根的左右子树的高度之差的绝对值不能超过1 根的左右子树都是平衡二叉树 插入 插入一个节点可能会破坏AVL树的平衡,可以通过旋转操作来进行修正。 插入一个节点后,只有从插入节点到根节点的路径上的节点的平衡可能 被改变。我们需要找出第一个破坏了平衡条件的节点,称之为K。K的两 颗子树的高度差2。 不平衡的出现可能有4种情况 * * * * console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"suan-fa-she-ji/":{"url":"suan-fa-she-ji/","title":"算法设计","keywords":"","body":"算法设计算法设计 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"suan-fa-she-ji/tan-xin-suan-fa/":{"url":"suan-fa-she-ji/tan-xin-suan-fa/","title":"贪心算法","keywords":"","body":"贪心算法贪心算法(又称贪婪算法)1.概念2.贪心算法的基本思路3.该算法存在的问题4.贪心算法适用的问题5.贪心选择性质6.贪心算法的实现框架贪心算法 贪心算法(又称贪婪算法) 在对问题求解时,总是你做出在当前看来是最好的选择。也就是说,不从整体最优上加以考虑,他所做出的是在某种意义上的局部最优解。 贪心算法并不保证会得到最优解,但是在某些问题上贪心算法的解就是最优解。要会判断一个问题能否用贪心算法来计算。 1.概念 所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，它所做出的仅仅是在某种意义上的局部最优解。 贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性（即某个状态以后的过程不会影响以前的状态，只与当前状态有关。） 所以，对所采用的贪心策略一定要仔细分析其是否满足无后效性。 2.贪心算法的基本思路 建立数学模型来描述问题 把求解的问题分成若干个子问题 对每个子问题求解，得到子问题的局部最优解 把子问题的解局部最优解合成原来问题的一个解 3.该算法存在的问题 不能保证求得的最后解是最佳的 不能用来求最大值或最小值的问题 只能求满足某些约束条件的可行解的范围 4.贪心算法适用的问题 贪心策略适用的前提是：局部最优策略能导致产生全局最优解。 实际上，贪心算法适用的情况很少。一般对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可以做出判断。 5.贪心选择性质 所谓贪心选择性质是指所求问题的整体最优解可以通过一系列局部最优的选择，换句话说，当考虑做何种选择的时候，我们只考虑对当前问题最佳的选择而不考虑子问题的结果。这是贪心算法可行的第一个基本要素。贪心算法以迭代的方式作出相继的贪心选择，每作一次贪心选择就将所求问题简化为规模更小的子问题。对于一个具体问题，要确定它是否具有贪心选择性质，必须证明每一步所作的贪心选择最终导致问题的整体最优解。 当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。问题的最优子结构性质是该问题可用贪心算法求解的关键特征。 6.贪心算法的实现框架 从问题的某一初始解出发： while (朝给定目标前进一步) { 利用可行的决策，求出可行解的一个解元素。 } 1 2 3 4 由所有解元素组合成问题的一个可行解； console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"suan-fa-she-ji/tan-xin-suan-fa/zhao-ling-wen-ti.html":{"url":"suan-fa-she-ji/tan-xin-suan-fa/zhao-ling-wen-ti.html","title":"找零问题","keywords":"","body":"找零问题找零问题 假设商店老板需要找零n元钱,钱币的面额有:100元、50元、 20元、5元、1元,如何找零使得所需钱币的数量最少? def change_money(f, n): print(f) m = [0 for _ in range(len(f))] for i, money in enumerate(f): m[i] = n // money n = n % money return m, n if __name__ == '__main__': f = [100, 50, 10, 5, 1] print(change_money(f, 376)) console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"suan-fa-she-ji/tan-xin-suan-fa/bei-bao-wen-ti.html":{"url":"suan-fa-she-ji/tan-xin-suan-fa/bei-bao-wen-ti.html","title":"背包问题","keywords":"","body":"背包问题背包问题 一个小偷在某个商店发现有n个商品,第i个商品价值v元,重w千克。他希望 拿走的价值尽量高,但他的背包最多只能容纳W千克的东西。他应该拿走哪些 商品? 0-1背包:对于一个商品,小偷要么把它完整拿走,要么留下下。不能只拿走 一部分,或把一个商品拿走多次。(商品为金条) 分数背包（贪心算法）:对于一个商品,小偷可以拿走其中任意一部分。 (商品为金砂) goods = [(60, 10), (120, 30), (100, 20)] # 倒序排列 价格由低倒高 goods.sort(key=lambda x: x[0] / x[1], reverse=True) print(goods) def fractional_backpack(goods, w): \"\"\" 时间复杂度：O(n) 空间复杂度：O(n) 解法：分数背包 \"\"\" # 计算可以取的容量 m = [float(\"inf\") for _ in range(len(goods))] # 计算取走总价格 total = 0 for i, (price, weight) in enumerate(goods): # 当前重量小于总重量 if weight console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"suan-fa-she-ji/tan-xin-suan-fa/huo-dong-xuan-ze-wen-ti.html":{"url":"suan-fa-she-ji/tan-xin-suan-fa/huo-dong-xuan-ze-wen-ti.html","title":"活动选择问题","keywords":"","body":"活动选择问题活动选择问题 活动选择问题 假设有n个活动， 这些活动要占用同一片场地，而场地在某时 刻只能供一个活动使用。 每个活动都有一个开始时间s和结束时间f（题目中时间以整数 表示）,表示活动在[s，f)区间占用场地。 问：安排哪些活动能够使该场地举办的活动的个数最多？ 贪心结论：最先结束的活动一定是最优解的一部分。 证明：假设a是所有活动中最先结束的活动，b是最优解中最先结束的活动。 如果a=b，结论成立。 如果a+b，则b的结束时间一定晚于a的结束时间，则此时用a替换掉最优解中 的b，a一定不与最优解中的其他活动时间重叠，因此替换后的解也是最优解。 activities = [(1, 4), (3, 5), (0, 6), (5, 7), (3, 9), (5, 9), (6, 10), (8, 11), (8, 12), (2, 14), (12, 16)] activities.sort(key=lambda x: x[1]) def activate_selection(active): res = [active[0]] for i in range(1, len(active)): if active[i][0] >= res[-1][1]: res.append(active[i]) return res if __name__ == '__main__': print(activate_selection(activities)) console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"suan-fa-she-ji/tan-xin-suan-fa/pin-jie-zui-da-shu-zi-wen-ti.html":{"url":"suan-fa-she-ji/tan-xin-suan-fa/pin-jie-zui-da-shu-zi-wen-ti.html","title":"拼接最大数字问题","keywords":"","body":"拼接最大数字问题拼接最大数字问题 有n个非负整数,将其按照字符串拼接的方式拼接为一个整数收。 如何拼接可以使得得到的整数最大? 例:32,94,128,1286,6,71可以拼接除的最大整数为 94716321286128 from functools import cmp_to_key li = [32, 94, 128, 1286, 6, 71] def cmp(x, y): if x + y y + x: return -1 return 0 def number_join(li): li = list(map(str, li)) li.sort(key=cmp_to_key(cmp)) return \"\".join(li) if __name__ == \"__main__\": print(number_join(li)) console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"suan-fa-she-ji/dong-tai-gui-hua/":{"url":"suan-fa-she-ji/dong-tai-gui-hua/","title":"动态规划","keywords":"","body":"动态规划动态规划 动态规划（Dynamic Programming，简称DP）是一种常用于解决优化问题的算法思想，它通常用于解决具有重叠子问题和最优子结构性质的问题。动态规划通过将问题分解成小的子问题，并在解决这些子问题的基础上构建问题的最优解。以下是动态规划的基本概念和步骤： 确定状态：首先要确定问题的状态，这些状态可以表示问题的各个子情况。状态的选择往往取决于问题的特性，通常用一个或多个变量表示状态。 定义状态转移方程：状态转移方程描述了状态之间的关系，它告诉我们如何从一个状态转移到另一个状态。这个方程通常以递归的方式定义，并用数学形式表示。状态转移方程是动态规划问题的核心。 初始化：确定初始状态的值，即最小子问题的解或者初始条件。 自底向上或自顶向下求解：动态规划可以采用两种方式求解，自底向上和自顶向下。自底向上从最小子问题开始，逐步求解更大规模的问题，直到达到原始问题。自顶向下从原始问题开始，逐步分解成子问题，直到达到最小子问题。通常，自底向上的方法更具效率，因为它避免了重复计算子问题。 记忆化存储（可选）：为了避免重复计算子问题，可以使用一个数据结构来存储已经计算过的结果，以便以后直接获取。这通常称为记忆化存储或缓存。 动态规划通常用于解决一些经典问题，如背包问题、最长公共子序列问题、最短路径问题等。它的核心思想是通过将问题分解成子问题并保存子问题的解来降低问题的复杂度，从而有效地解决复杂的优化问题。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"suan-fa-she-ji/dong-tai-gui-hua/fei-bo-na-qi-shu-lie-yin-ru-dong-tai-gui-hua-si-xiang.html":{"url":"suan-fa-she-ji/dong-tai-gui-hua/fei-bo-na-qi-shu-lie-yin-ru-dong-tai-gui-hua-si-xiang.html","title":"斐波那契数列（引入动态规划思想）","keywords":"","body":"斐波那契数列（引入动态规划思想）斐波那契数列（引入动态规划思想） 定义状态转移方程 m = (n-1) + (n - 2) 子问题重复计算导致递归慢 # 递归形式 def febonaqi_recursion(n): if n == 1 or n == 2: return 1 return febonaqi_recursion(n - 1) + febonaqi_recursion(n - 2) def febnaqi(n): l = [0, 1, 1] if n > 2: for i in range(n): s = l[-1] + l[-2] l.append(s) return l[n - 1] + l[n - 2] print(febonaqi_recursion(33)) print(febnaqi(33)) console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"suan-fa-she-ji/dong-tai-gui-hua/gang-tiao-qie-ge.html":{"url":"suan-fa-she-ji/dong-tai-gui-hua/gang-tiao-qie-ge.html","title":"钢条切割","keywords":"","body":"钢条切割钢条切割 可以将求解规模为n的原问题，划分为规模更小的子问题：完成一次切割 后，可以将产生的两段钢条看成两个独立的钢条切个问题。 组合两个子问题的最优解，并在所有可能的两段切割方案中选取组合收 益最大的，构成原问题的最优解。 钢条切割满足最优子结构：问题的最优解由相关子问题的最优解组合而 成，这些子问题可以独立求解。 钢条切割问题还存在更简单的递归求解方法 从钢条的左边切割下长度为i的一段，只对右边剩下的一段继续进行切割，左边的不再切割 递推式简化为 .png>)不做切割的方案就可以描述为：左边一段长度为n，收益为pn，剩余一段长度 为0，收益为ro=0。 .png>) # p = [0, 1, 5, 8, 9, 10, 17, 17, 20, 21, 23, 24, 26, 27, 27, 28, 30, 33, 36, 39, 40] p = [0, 1, 5, 8, 9, 10, 17, 17, 20, 24, 30] \"\"\" 2n次方 \"\"\" def f1_recursion(p, n): if n == 0: return 0 res = p[n] for i in range(1, n): res = max(res, f1_recursion(p, i) + f1_recursion(p, n - i)) return res def f2_recursion(p, n): if n == 0: return 0 res = 0 for i in range(1, n + 1): res = max(res, p[i] + f2_recursion(p, n - i)) return res \"\"\" n² 重构解 \"\"\" def cut_rod_dp(p, n): r = [0] for i in range(1, n + 1): res = 0 for j in range(1, i + 1): res = max(res, p[j] + r[i - j]) r.append(res) return r[n] def cut_rod_extend(p, n): r = [0] s = [0] for i in range(1, n + 1): res_r = 0 res_s = 0 for j in range(1, i + 1): if p[j] + r[i - j] > res_r: res_r = p[j] + r[i - j] res_s = j r.append(res_r) s.append(res_s) return r[n], s def cut_rod_solution(p, n): r, s = cut_rod_extend(p, n) ans = [] while n > 0: ans.append(s[n]) n -= s[n] return ans print(cut_rod_solution(p, 7)) python print(cut_rod_dp(p, 10)) # print(f1_recursion(p, 20)) print(f2_recursion(p, 10)) console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"suan-fa-she-ji/dong-tai-gui-hua/zui-chang-gong-gong-zi-xu-lie.html":{"url":"suan-fa-she-ji/dong-tai-gui-hua/zui-chang-gong-gong-zi-xu-lie.html","title":"最长公共子序列","keywords":"","body":"最长公共子序列最长公共子序列 \"\"\" —个序列的子序列是在该序列中删去若干元素后得 到的序列。 例：“ABCD”和“BDF”都是“ABCDEFG”的子序列 最长公共子序列（LCS）问题：给定两个序列X和Y，求X和Y长度最大的公共子 序列。 例：X=\"ABCBDAB\" Y=\"BDCABA\" LCS(X,Y)=\"BCBA\" 应用场景：字符串相似度比对 \"\"\" def lcs_length(x, y): m = len(x) n = len(y) c = [[0 for _ in range(n + 1)] for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if x[i - 1] == y[j - 1]: c[i][j] = c[i - 1][j - 1] + 1 else: c[i][j] = max(c[i - 1][j], c[i][j - 1]) return c[m][n] import copy def lcs(x, y): m = len(x) n = len(y) c = [[0 for _ in range(n + 1)] for _ in range(m + 1)] b = copy.deepcopy(c) for i in range(1, m + 1): for j in range(1, n + 1): if x[i - 1] == y[j - 1]: c[i][j] = c[i - 1][j - 1] + 1 b[i][j] = 1 elif c[i - 1][j] > c[i][j - 1]: c[i][j] = c[i - 1][j] b[i][j] = 2 else: c[i][j] = c[i][j - 1] b[i][j] = 3 return c[m][n], b def lsc_print(x, y): c, b = lcs(x, y) i = len(x) j = len(y) res = [] while i > 0 and j > 0: if b[i][j] == 1: res.append(x[i - 1]) i -= 1 j -= 1 elif b[i][j] == 2: i -= 1 else: j -= 1 return \"\".join(reversed(res)) print(lsc_print(\"ABCBDAB\", \"BDCABA\")) console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"suan-fa-she-ji/ou-ji-li-de/":{"url":"suan-fa-she-ji/ou-ji-li-de/","title":"欧几里得","keywords":"","body":"欧几里得欧几里得 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"suan-fa-she-ji/ou-ji-li-de/zui-da-gong-yue-shu.html":{"url":"suan-fa-she-ji/ou-ji-li-de/zui-da-gong-yue-shu.html","title":"最大公约数","keywords":"","body":"最大公约数最大公约数 计算两个整数的最大公约数可以使用欧几里得算法（Euclidean algorithm），也称为辗转相除法。 欧几里得算法的基本原理是，两个整数a和b（假设a >= b）的最大公约数等于b和a mod b的最大公约数，其中mod是取余运算符。 def gcd(a, b): \"\"\" 时间复杂度：O(n) 空间复杂度：O(1) :param a: :param b: :return: \"\"\" if b == 0: return a return gcd(b, a % b) def gcd2(a, b): \"\"\" 时间复杂度：O(n) 空间复杂度：O(1) :param a: :param b: :return: \"\"\" while b > 0: r = a % b a = b b = r return a print(gcd(12, 16)) print(gcd2(12, 16)) console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"jia-mi-suan-fa/":{"url":"jia-mi-suan-fa/","title":"加密算法","keywords":"","body":"加密算法加密算法 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"jia-mi-suan-fa/se.html":{"url":"jia-mi-suan-fa/se.html","title":"SE","keywords":"","body":"SESE 对称加密是一种加密方法，使用相同的密钥进行加密和解密。在对称加密中，发送方使用密钥将明文转换为密文，接收方使用相同的密钥将密文转换回明文。 对称加密的基本原理是通过对数据进行替换、置换、混淆或其他变换来隐藏数据的真实含义。这种加密方法需要确保密钥的安全性，只有掌握正确的密钥才能成功解密密文。 对称加密相对于非对称加密而言具有以下特点： 效率高：对称加密算法的加密和解密速度通常比非对称加密算法快，适用于处理大量数据的加密和解密操作。 密钥管理相对简单：由于加密和解密使用相同的密钥，密钥管理相对较为简单。 密钥分发挑战：对称加密算法需要确保密钥的安全性，发送方和接收方需要事先共享密钥以确保加密和解密的安全性。 常见的对称加密算法包括AES（Advanced Encryption Standard）、DES（Data Encryption Standard）、3DES（Triple Data Encryption Standard）和Blowfish等。 尽管对称加密在加密和解密速度上具有优势，但当需要安全地进行密钥交换或实现数字签名等功能时，通常会结合使用非对称加密算法。 from cryptography.fernet import Fernet # 生成随机密钥 key = Fernet.generate_key() # 创建Fernet对象 cipher_suite = Fernet(key) # 要加密的明文 message = b\"Hello, World!\" # 加密明文 ciphertext = cipher_suite.encrypt(message) print(\"密文:\", ciphertext) # 解密密文 decrypted_message = cipher_suite.decrypt(ciphertext) print(\"解密后的明文:\", decrypted_message) console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"jia-mi-suan-fa/rsa.html":{"url":"jia-mi-suan-fa/rsa.html","title":"RSA","summary":"RSA","keywords":"","body":"RSARSA RSA（Rivest-Shamir-Adleman）是一种非对称加密算法，常用于数据加密和数字签名。它基于两个大素数的乘积因子分解的难题，其中一个素数用于加密，另一个素数用于解密。 下面是RSA加密的基本步骤： 选择两个不同的大素数p和q。 计算n = p * q，其中n是RSA加密的模数。 计算欧拉函数φ(n) = (p-1) * (q-1)，表示小于n且与n互质的正整数的个数。 选择一个整数e，满足1 计算e的模反元素d，满足e * d ≡ 1 (mod φ(n))。d称为私钥指数。 公钥为(n, e)，私钥为(n, d)。 要加密明文m，计算密文c = m^e (mod n)。 要解密密文c，计算明文m = c^d (mod n)。 在实际使用中，RSA加密通常用于加密对称加密算法的密钥，以提供更高的安全性和密钥交换的便利性。 需要注意的是，RSA加密的安全性依赖于大素数的选择和密钥长度的适当设置。通常要选择足够大的素数和密钥长度以保护加密数据免受攻击。此外，RSA加密的性能较慢，因此通常与对称加密算法结合使用，以实现更高效的加密和解密过程。 import random def generate_keys(p, q): # 计算 n = p * q 和 φ(n) = (p-1) * (q-1) n = p * q phi = (p - 1) * (q - 1) # 选择公钥指数 e，满足 1 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"she-ji-mo-shi/":{"url":"she-ji-mo-shi/","title":"设计模式","keywords":"","body":"设计模式设计模式 设计模式是在软件设计中经过反复验证并被广泛应用的解决问题的方案。它们是在软件开发过程中针对常见问题的可重用设计思想和实践经验的总结。 设计模式提供了一种被广泛接受的共享词汇和思维模式，使开发人员能够更加清晰地沟通和交流设计思想。通过使用设计模式，开发人员可以遵循一套被认为是最佳实践的规则和原则，从而设计出更加灵活、可维护和可扩展的软件系统。 设计模式通常包括以下几个要素： 模式名称：每个设计模式都有一个独特的名称，用于标识和描述该模式。 问题描述：设计模式解决的具体问题或情景。 解决方案描述：设计模式的实现解决方案，包括所涉及的类、对象、关系和交互方式。 优点：设计模式的优势和潜在好处。 使用情景：适用于该设计模式的具体使用场景和条件。 常见的设计模式包括单例模式、工厂模式、观察者模式、装饰器模式、策略模式等。每种设计模式都有其特定的目的和适用范围，开发人员可以根据实际需要选择合适的设计模式来解决问题。 创建型模式（5种）：抽象工厂模式和建造者模式相比于简单工厂模式和工厂方法 模式而言更灵活也更复杂。 通常情况下、设计以简单工厂模式或工厂方法模式开始，当你发现设计需要更大的灵活性时，则像更复杂的设计模式演化。 工厂方法模式 抽象工厂模式 创建者模式 原型模式 单例模式 结构型模式（7种） 适配器模式 桥模式 组合模式 装饰模式 外观模式 享元模式 代理模式 行为型模式（11种）： 解释器模式 责任链模式 命令模式 迭代器模式 中介者模式 备忘录模式 观察者模式 状态模式 策略模式 访问者模式 模板方法模式 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"she-ji-mo-shi/gong-chang-mo-shi/":{"url":"she-ji-mo-shi/gong-chang-mo-shi/","title":"工厂模式","keywords":"","body":"工厂模式工厂模式 工厂方法模式（Factory Method Pattern）是一种创建型设计模式，它允许客户端代码通过一个抽象工厂接口来创建对象，而具体的工厂子类负责实际创建具体的对象。这个模式使得客户端代码与具体对象的创建解耦，使系统更加灵活和可扩展。 优点： 每个具体产品都对应一个具体工厂类，不需要修改工厂类代码 隐藏了对象创建的实现细节 缺点： 每增加一个具体产品类，就必须增加一个相应的具体工厂类 from abc import ABC, abstractmethod # 定义支付方式的抽象基类 class PaymentMethod(ABC): @abstractmethod def pay(self, amount): pass # 实现信用卡支付类 class CreditCardPayment(PaymentMethod): def pay(self, amount): print(f\"使用信用卡支付 ${amount}\") # 实现支付宝支付类 class AlipayPayment(PaymentMethod): def pay(self, amount): print(f\"使用支付宝支付 ${amount}\") # 定义支付方式工厂的抽象基类 class PaymentFactory(ABC): @abstractmethod def create_payment_method(self): pass # 实现信用卡支付工厂 class CreditCardPaymentFactory(PaymentFactory): def create_payment_method(self): return CreditCardPayment() # 实现支付宝支付工厂 class AlipayPaymentFactory(PaymentFactory): def create_payment_method(self): return AlipayPayment() # 客户端代码 if __name__ == \"__main__\": credit_card_factory = CreditCardPaymentFactory() credit_card_payment = credit_card_factory.create_payment_method() credit_card_payment.pay(100.0) alipay_factory = AlipayPaymentFactory() alipay_payment = alipay_factory.create_payment_method() alipay_payment.pay(50.0) console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"she-ji-mo-shi/gong-chang-mo-shi/chou-xiang-gong-chang-mo-shi.html":{"url":"she-ji-mo-shi/gong-chang-mo-shi/chou-xiang-gong-chang-mo-shi.html","title":"抽象工厂模式","keywords":"","body":"抽象工厂模式抽象工厂模式 抽象工厂模式（Abstract Factory Pattern）是一种创建型设计模式，它提供了一个接口，用于创建一系列相关或相互依赖的对象，而不需要指定其具体的类。在这个模式中，有一个抽象工厂接口，每个具体工厂子类都实现了这个接口，用于创建一组相关的对象。 内容：定义一个工厂类接口，让工厂子类来创建一系列相关或相互依赖 的对象。 相比工厂方法模式，抽象工厂模式中的每个具体工厂都生产一套产品。 from abc import ABC, abstractmethod # 定义支付方式的抽象基类 class PaymentMethod(ABC): @abstractmethod def pay(self, amount): pass # 实现信用卡支付类 class CreditCardPayment(PaymentMethod): def pay(self, amount): print(f\"使用信用卡支付 ${amount}\") # 实现支付宝支付类 class AlipayPayment(PaymentMethod): def pay(self, amount): print(f\"使用支付宝支付 ${amount}\") # 定义支付方式工厂的抽象基类 class PaymentFactory(ABC): @abstractmethod def create_payment_method(self): pass # 实现信用卡支付工厂 class CreditCardPaymentFactory(PaymentFactory): def create_payment_method(self): return CreditCardPayment() # 实现支付宝支付工厂 class AlipayPaymentFactory(PaymentFactory): def create_payment_method(self): return AlipayPayment() # 客户端代码 if __name__ == \"__main__\": # 创建信用卡支付工厂 credit_card_factory = CreditCardPaymentFactory() # 使用信用卡支付 credit_card_payment = credit_card_factory.create_payment_method() credit_card_payment.pay(100.0) # 创建支付宝支付工厂 alipay_factory = AlipayPaymentFactory() # 使用支付宝支付 alipay_payment = alipay_factory.create_payment_method() alipay_payment.pay(50.0) console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"she-ji-mo-shi/gong-chang-mo-shi/jian-dan-gong-chang-mo-shi.html":{"url":"she-ji-mo-shi/gong-chang-mo-shi/jian-dan-gong-chang-mo-shi.html","title":"简单工厂模式","keywords":"","body":"简单工厂模式简单工厂模式 内容：不直接向客户端暴露对象创建的实现细节，而是通过一个工厂类来负责创建产品 类的实例。 优点： 隐藏了对象创建的实现细节 客户端不需要修改代码 缺点： 违反了单一职责原则，将创建逻辑几种到一个工厂类里，当添加新产品时，需要修改工厂类代码，违反了开闭原则 from abc import ABCMeta, abstractmethod # 定义初始类 class PayCommon(metaclass=ABCMeta): @abstractmethod def draw(self, money): pass # 实现支付宝支付 class AliPay(PayCommon): def draw(self, money): print(\"支付宝支付 % d\" % money) # 实现微信支付 class WeChatPay(PayCommon): def draw(self, money): print(\"微信支付 % d\" % money) # 定义形状工厂类 class ShapeFactory: def pay(self, shape_type): if shape_type == \"ali\": return AliPay() elif shape_type == \"wechat\": return WeChatPay() else: raise ValueError(\"不支持的支付类型\") # 客户端代码 if __name__ == \"__main__\": factory = ShapeFactory() circle = factory.pay(\"ali\") circle.draw(100) rectangle = factory.pay(\"wechat\") rectangle.draw(10) console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"she-ji-mo-shi/jian-zao-zhe-mo-shi.html":{"url":"she-ji-mo-shi/jian-zao-zhe-mo-shi.html","title":"建造者模式","keywords":"","body":"建造者模式建造者模式 建造者模式（Builder Pattern）是一种创建型设计模式，它用于创建复杂对象，将一个对象的构建与其表示分离，以便可以创建不同类型的对象，同时避免构造器参数列表的过长问题。该模式通常包括一个指导者（Director）和一个具体的建造者（Builder），指导者负责指导具体的建造者来构建对象。建造者模式的关键是按照正确的顺序设置属性和调用方法，以确保最终生成所需的复杂对象。这有助于提高代码的可维护性和可扩展性。 在这个示例中，我们将Computer类和ComputerBuilder接口定义为抽象基类，并使用abc模块的abstractmethod装饰器来标记抽象方法。具体的电脑类ConcreteComputer继承自Computer，并实现了抽象方法__str__来定义电脑对象的字符串表示。 具体的建造者类ConcreteComputerBuilder继承自ComputerBuilder，并实现了所有的抽象方法，包括set_meat方法，用于设置电脑的meat属性。 客户端代码与之前类似，使用指导者来构建电脑对象，包括设置了meat属性。这种结合abc的方式确保了电脑和建造者的一致性，同时也提供了更好的代码规范和可维护性。 from abc import ABC, abstractmethod # 定义电脑抽象基类 class Computer(ABC): def __init__(self): self.cpu = None self.memory = None self.hard_drive = None self.graphics_card = None self.meat = None @abstractmethod def __str__(self): pass # 定义电脑建造者接口 class ComputerBuilder(ABC): @abstractmethod def set_cpu(self, cpu): pass @abstractmethod def set_memory(self, memory): pass @abstractmethod def set_hard_drive(self, hard_drive): pass @abstractmethod def set_graphics_card(self, graphics_card): pass @abstractmethod def set_meat(self, meat): pass @abstractmethod def build(self): pass # 具体的电脑类 class ConcreteComputer(Computer): def __str__(self): return f\"CPU: {self.cpu}, Memory: {self.memory}, Hard Drive: {self.hard_drive}, Graphics Card: {self.graphics_card}, Meat: {self.meat}\" # 具体的电脑建造者 class ConcreteComputerBuilder(ComputerBuilder): def __init__(self): self.computer = ConcreteComputer() def set_cpu(self, cpu): self.computer.cpu = cpu def set_memory(self, memory): self.computer.memory = memory def set_hard_drive(self, hard_drive): self.computer.hard_drive = hard_drive def set_graphics_card(self, graphics_card): self.computer.graphics_card = graphics_card def set_meat(self, meat): self.computer.meat = meat def build(self): return self.computer # 定义电脑指导者 class ComputerDirector: def __init__(self, builder): self.builder = builder def construct(self): self.builder.set_cpu(\"Intel Core i7\") self.builder.set_memory(\"16GB\") self.builder.set_hard_drive(\"1TB SSD\") self.builder.set_graphics_card(\"NVIDIA GeForce RTX 3080\") self.builder.set_meat(\"Beef\") return self.builder.build() # 定义高端电脑指导者 class ComputerDirectorHighEnd: def __init__(self, builder): self.builder = builder def construct(self): self.builder.set_cpu(\"Intel Core i9\") self.builder.set_memory(\"64GB\") self.builder.set_hard_drive(\"10TB SSD\") self.builder.set_graphics_card(\"NVIDIA GeForce RTX 4090Ti\") self.builder.set_meat(\"Beef\") return self.builder.build() # 客户端代码 if __name__ == \"__main__\": builder = ConcreteComputerBuilder() director = ComputerDirector(builder) computer = director.construct() print(\"构建的电脑信息:\") print(computer) director = ComputerDirectorHighEnd(builder) computer = director.construct() print(\"构建的电脑信息:\") print(computer) console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"she-ji-mo-shi/dan-li-mo-shi.html":{"url":"she-ji-mo-shi/dan-li-mo-shi.html","title":"单例模式","keywords":"","body":"单例模式单例模式 单例模式（Singleton Pattern）是一种创建型设计模式，它确保一个类只有一个实例，并提供一种全局访问该实例的方式。这种模式通常用于控制资源，例如数据库连接、线程池、缓存对象等，以确保系统中只存在一个共享的实例，从而节省资源和确保一致性。 from functools import wraps def test_func(func): _instance = {} @wraps(func) def inner(*args, **kwargs): if func not in _instance: _instance[func] = func() return _instance[func] return inner class TestClass: _instance = None def __new__(cls, *args, **kwargs): if TestClass._instance: return TestClass._instance else: TestClass._instance = object.__new__(cls, *args, **kwargs) return TestClass._instance class Singleton: def __new__(cls, *args, **kwargs): if not hasattr(cls, \"_instance\"): cls._instance = super(Singleton, cls).__new__(cls) class MyClass(Singleton): def __init__(self): pass @test_func class MyClass2: def __init__(self): pass if __name__ == '__main__': t1 = TestClass() t2 = TestClass() print(t1 is t2) t3 = MyClass() t4 = MyClass() print(t3 is t4) t5 = MyClass2() t6 = MyClass2() print(t5 is t6) console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"she-ji-mo-shi/shi-pei-qi-mo-shi.html":{"url":"she-ji-mo-shi/shi-pei-qi-mo-shi.html","title":"适配器模式","keywords":"","body":"适配器模式适配器模式 适配器模式（Adapter Pattern）是一种结构型设计模式，用于将一个类的接口转换为另一个类所期望的接口，以便两个类能够协同工作而无需修改其原有的接口。 适配器模式通常用于以下情况： 转换接口：当现有的类或组件提供的接口与客户端要求的接口不兼容时，可以使用适配器模式进行转换。适配器作为中间层，通过实现客户端期望的接口，并持有现有类的实例，在两者之间进行接口的转换和适配。 重用现有功能：当需要重用一个已有类，但其接口与当前系统要求不符时，可以使用适配器模式。适配器通过实现目标接口并将调用委托给现有类来重用现有类的功能。 适配器模式的优点： 重用现有功能，无需修改原有接口。 解耦客户端和现有类，提高代码的可维护性和可复用性。 提供接口转换和适配，使不兼容的接口能够协同工作。 增加系统的灵活性和扩展性。 适配器模式的缺点： 增加复杂性，引入额外的类和对象。 可能引入性能损失。 限制对现有类的修改。 # 目标接口 class Target: def request(self): raise NotImplementedError # 对象适配器 class Adapter(Target): def __init__(self, adaptee): self.adaptee = adaptee def request(self): # 调用现有类的方法进行适配 self.adaptee.specific_request() class Adaptee: def specific_request(self): print(\"Adaptee's specific request\") # 类适配器 class NewAdaptee(Target, Adaptee): def request(self): self.specific_request() # 使用适配器 adapter = Adapter(Adaptee()) adapter.request() # 使用适配器 adapter2 = NewAdaptee() adapter2.request() console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"she-ji-mo-shi/qiao-mo-shi.html":{"url":"she-ji-mo-shi/qiao-mo-shi.html","title":"桥模式","keywords":"","body":"桥模式桥模式 桥模式是一种设计模式，用于将抽象部分与其具体实现部分解耦，使它们可以独立地变化。桥模式的核心思想是通过将抽象和实现分离，让它们可以独立地进行变化和扩展。 在桥模式中，存在两个独立变化的维度：抽象部分和实现部分。抽象部分定义了高层接口，而实现部分则提供了具体的实现。通过桥接（Bridge）将抽象部分和实现部分连接起来，使它们可以独立进行修改和扩展。 桥模式的关键角色包括：抽象和实现相分离 抽象（Abstraction）：定义了高层接口，维护一个对实现的引用，并将客户端的请求委派给实现对象。 具体抽象（Concrete Abstraction）：扩展了抽象部分，实现了高层接口，通常包含一些额外的业务逻辑。 实现（Implementation）：定义了实现部分的接口，提供基本操作的定义。 具体实现（Concrete Implementation）：具体的实现部分，实现了实现部分的接口。 通过桥模式，可以在不修改现有代码的情况下，新增抽象和实现的组合。这种解耦的设计使得系统更加灵活，能够应对变化，并支持扩展和演化。 总结来说，桥模式通过将抽象部分和实现部分分离，提供了一种灵活的设计方式，使得它们可以独立地变化和扩展。这种模式可以提高系统的可维护性、可扩展性和可复用性。 from abc import ABC, abstractmethod # 实现部分的接口 class Shape(ABC): def __init__(self, color): self.color = color @abstractmethod def draw(self): pass # 实现部分的接口 class Color(ABC): @abstractmethod def paint(self, shape): pass # 长方形 class Rectangle(Shape): name = \"长方形\" def draw(self): self.color.paint(self) # 圆形 class Round(Shape): name = \"圆形\" def draw(self): self.color.paint(self) class Red(Color): def paint(self, shape): print(\"红色的 %s\" % shape.name) class Green(Color): def paint(self, shape): print(\"绿色的 %s\" % shape.name) r = Rectangle(Red()) g = Round(Green()) r.draw() g.draw() from abc import ABC, abstractmethod # 实现部分的接口 class Implementor(ABC): @abstractmethod def operation_implementation(self): pass # 具体实现部分A class ConcreteImplementorA(Implementor): def operation_implementation(self): print(\"Concrete Implementor A operation\") # 具体实现部分B class ConcreteImplementorB(Implementor): def operation_implementation(self): print(\"Concrete Implementor B operation\") # 抽象部分的接口 class Abstraction(ABC): def __init__(self, implementor): self.implementor = implementor @abstractmethod def operation(self): pass # 具体抽象部分A class ConcreteAbstractionA(Abstraction): def operation(self): print(\"Concrete Abstraction A operation\") self.implementor.operation_implementation() # 具体抽象部分B class ConcreteAbstractionB(Abstraction): def operation(self): print(\"Concrete Abstraction B operation\") self.implementor.operation_implementation() # 使用桥模式 implementor_a = ConcreteImplementorA() abstraction_a = ConcreteAbstractionA(implementor_a) abstraction_a.operation() implementor_b = ConcreteImplementorB() abstraction_b = ConcreteAbstractionB(implementor_b) abstraction_b.operation() console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"she-ji-mo-shi/zu-he-mo-shi.html":{"url":"she-ji-mo-shi/zu-he-mo-shi.html","title":"组合模式","keywords":"","body":"组合模式组合模式 将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象 的使用具有一致性。 角色： 抽象组件 (Component) 叶子组件 (Leaf) 复合组件 (Composite) 客户端 (Client) 适用场景： 表示对象的“部分-整体”层次结构（特别是结构是递归的） 希望用户忽略组合对象与单个对象的不同，用户统一地使用组合结构中的所有对象 优点： 定义了包含基本对象和组合对象的类层次结构 简化客户端代码，即客户端可以一致地使用组合对象和单个对象 更容易增加新类型的组件 组合模式（Composite Pattern）是一种结构型设计模式，它允许将对象组合成树状结构以表示“部分-整体”的层次结构。组合模式使得用户可以统一对待单个对象和组合对象，从而简化了客户端的代码。 在组合模式中，有以下几个关键角色： 组件（Component）：定义了组合对象和叶子对象的共同接口，可以是抽象类或接口。它声明了一些操作方法，如添加子节点、删除子节点、获取子节点等。 叶子（Leaf）：表示组合中的叶子对象，它没有子节点。它实现了组件的接口，但在具体的操作方法中可能会抛出异常或不做任何处理。 容器（Composite）：表示组合中的容器对象，它可以包含子节点。容器对象实现了组件的接口，并提供了具体的操作方法，如添加子节点、删除子节点、获取子节点等。 使用组合模式可以将对象组织成树状结构，其中容器对象可以包含叶子对象和其他容器对象。客户端可以递归地遍历整个树状结构，对每个节点进行操作，而无需关心是叶子对象还是容器对象。 from abc import ABC, abstractmethod # 组件接口 class Component(ABC): @abstractmethod def operation(self): pass # 叶子类 class Leaf(Component): def operation(self): print(\"执行叶子操作\") # 容器类 class Composite(Component): def __init__(self): self.children = [] def add(self, component): self.children.append(component) def remove(self, component): self.children.remove(component) def operation(self): print(\"执行容器操作\") for child in self.children: child.operation() # 使用组合模式 leaf1 = Leaf() leaf2 = Leaf() composite1 = Composite() composite1.add(leaf1) composite1.add(leaf2) leaf3 = Leaf() composite2 = Composite() composite2.add(leaf3) composite2.add(composite1) composite2.operation() console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"she-ji-mo-shi/wai-guan-mo-shi.html":{"url":"she-ji-mo-shi/wai-guan-mo-shi.html","title":"外观模式","keywords":"","body":"外观模式外观模式 内容：为子系统中的一组接口提供一个一致的界面，外观模式定义了 一个高层接口，这个接口使得这一子系统更加容易使用。 角色： 外观 (facade) 子系统类 (subsystem classes) 优点： 减少系统相互依赖 提高了灵活性 提高了安全性 外观模式（Facade Pattern）是一种结构型设计模式，它提供了一个统一的接口，用于访问一组子系统的功能。外观模式通过创建一个高层接口，简化了客户端与复杂子系统之间的交互，并隐藏了子系统的复杂性。 外观模式包含以下几个关键角色： 外观（Facade）：提供了一个简化的接口，用于访问子系统的功能。外观模式通常只有一个外观类，它知道如何调用子系统的方法，并将客户端的请求委派给适当的子系统进行处理。 子系统（Subsystem）：包含了一组相关的类或模块，实现了子系统的功能。子系统可以包含多个类，每个类负责处理特定的子系统功能。 客户端（Client）：通过外观类来访问子系统的功能。客户端不直接与子系统进行交互，而是通过外观类来简化访问过程。 使用外观模式可以将复杂的子系统封装起来，提供一个简单的接口给客户端使用。客户端只需要与外观类进行交互，而无需了解子系统的复杂性和内部实现细节。这样可以降低客户端的复杂性，提高代码的可维护性和可扩展性。 # 子系统A class SubsystemA: def operationA(self): print(\"Subsystem A operation\") # 子系统B class SubsystemB: def operationB(self): print(\"Subsystem B operation\") # 外观类 class Facade: def __init__(self): self.subsystemA = SubsystemA() self.subsystemB = SubsystemB() def operation(self): self.subsystemA.operationA() self.subsystemB.operationB() # 客户端代码 facade = Facade() facade.operation() console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"she-ji-mo-shi/dai-li-mo-shi.html":{"url":"she-ji-mo-shi/dai-li-mo-shi.html","title":"代理模式","keywords":"","body":"代理模式代理模式 内容：为其他对象提供一种代理以控制对这个对象的访问。 应用场景： 远程代理：为远程的对象提供代理 虚代理：根据需要创建很大的对象 保护代理：控制对原始对象的访问，用于对象有不同访问权限时 代理模式（Proxy Pattern）是一种结构型设计模式，它允许通过代理对象控制对另一个对象的访问。 代理模式涉及以下几个角色： 抽象主题（Subject）：定义了真实主题和代理主题的共同接口，这样在使用代理的地方就可以使用真实主题或代理主题，实现了客户端与真实主题之间的松耦合。 真实主题（Real Subject）：定义了代理所代表的真实对象，是实际执行业务逻辑的对象。 代理（Proxy）：保存一个引用，使得代理可以访问真实主题，并提供一个与真实主题接口相同的接口，以便可以使用代理替代真实主题。 客户端通过代理对象间接地访问真实主题，可以在代理中添加额外的逻辑，例如访问控制、缓存、延迟加载等，而无需修改真实主题。代理模式可以提供更高层次的控制和保护，同时隐藏了真实主题的复杂性。 from abc import ABCMeta, abstractmethod class Subject: @abstractmethod def get_content(self): pass @abstractmethod def set_content(self, content): pass class RealSubject(Subject): def __init__(self, file_name): self.file_name = file_name print(\"读取文件内容\") with open(file_name, \"r\", encoding=\"utf-8\") as f: self.content = f.read() def get_content(self): print(self.content) return self.content def set_content(self, content): with open(self.file_name, \"rw\", encoding=\"utf-8\") as f: f.write(content) class VirtualSubject(Subject): def __init__(self, file_name): self.file_name = file_name self.subject = None def get_content(self): if not self.subject: self.subject = RealSubject(self.file_name) return self.subject.get_content() # def set_content(self, content): # if not self.subject: # self.subject = RealSubject(self.file_name) # return self.subject.set_content(content) # 可以进行加密 def set_content(self, content): raise PermissionError(\"no permission\") r = RealSubject(\"test.txt\") v = VirtualSubject(\"test.txt\") v.get_content() # 抽象主题 class Subject: def request(self): pass # 真实主题 class RealSubject(Subject): def request(self): print(\"执行真实主题的请求\") # 代理 class Proxy(Subject): def __init__(self): self.real_subject = RealSubject() def request(self): # 在访问真实主题前可以添加额外的逻辑 print(\"执行代理的请求\") self.real_subject.request() # 在访问真实主题后可以添加额外的逻辑 # 客户端代码 subject = Proxy() subject.request() console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"she-ji-mo-shi/ze-ren-lian-mo-shi.html":{"url":"she-ji-mo-shi/ze-ren-lian-mo-shi.html","title":"责任链模式","keywords":"","body":"责任链模式责任链模式 内容：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。 将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。 角色： 抽象处理者 (Handler) 具体处理者 (ConcreteHandler) 客户端 (Client) 责任链模式（Chain of Responsibility Pattern）是一种行为型设计模式，它允许多个对象按照顺序依次处理请求，直到其中一个对象能够处理为止。 责任链模式涉及以下几个角色： 处理者（Handler）：定义了一个处理请求的接口，并持有下一个处理者的引用。处理者可以自行决定是否处理请求，如果能够处理，则进行处理；如果无法处理，则将请求传递给下一个处理者。 具体处理者（Concrete Handler）：实现了处理请求的具体逻辑。如果能够处理请求，则进行处理；如果无法处理，则将请求传递给下一个处理者。 客户端将请求发送给第一个处理者，然后责任链中的每个处理者按照顺序尝试处理请求。如果某个处理者能够处理请求，则停止传递请求；如果所有处理者都无法处理请求，则请求未被处理。 责任链模式可以灵活地添加、移除或重新排序处理者，而无需修改客户端代码。它将请求的发送者和接收者解耦，提高了代码的可扩展性和可维护性。 from abc import ABCMeta, abstractmethod class Handler(metaclass=ABCMeta): @abstractmethod def handle_leave(self, day): pass class GeneralManager(Handler): def handle_leave(self, day): if day >= 10: print(\"总经理准假 %d\" % day) else: print(\"你还是离职吧\") class DepartmentManager(Handler): def __init__(self): self.next = GeneralManager() def handle_leave(self, day): if day >= 5: print(\"部门经理准假 %d\" % day) else: print(\"部门经理无权限\") self.next.handle_leave(day) class ProjectManager(Handler): def __init__(self): self.next = DepartmentManager() def handle_leave(self, day): if day >= 3: print(\"项目经理准假 %d\" % day) else: print(\"项目经理无权限\") self.next.handle_leave(day) day = 4 p = ProjectManager() p.handle_leave(day) # 处理者抽象类 class Handler: def __init__(self): self.successor = None def set_successor(self, successor): self.successor = successor def handle_request(self, request): pass # 具体处理者A class ConcreteHandlerA(Handler): def handle_request(self, request): if request == 'A': print(\"ConcreteHandlerA 处理请求\") elif self.successor is not None: self.successor.handle_request(request) # 具体处理者B class ConcreteHandlerB(Handler): def handle_request(self, request): if request == 'B': print(\"ConcreteHandlerB 处理请求\") elif self.successor is not None: self.successor.handle_request(request) # 具体处理者C class ConcreteHandlerC(Handler): def handle_request(self, request): if request == 'C': print(\"ConcreteHandlerC 处理请求\") elif self.successor is not None: self.successor.handle_request(request) # 客户端代码 handlerA = ConcreteHandlerA() handlerB = ConcreteHandlerB() handlerC = ConcreteHandlerC() handlerA.set_successor(handlerB) handlerB.set_successor(handlerC) handlerA.handle_request('B') console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"she-ji-mo-shi/guan-cha-zhe-mo-shi.html":{"url":"she-ji-mo-shi/guan-cha-zhe-mo-shi.html","title":"观察者模式","keywords":"","body":"观察者模式观察者模式 内容：定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时，所有依赖于它的对象都得到 通知并被自动更新。观察者模式又称“发布-订阅”模式 角色： 抽象主题 (Subject) 上具体主题(ConcreteSubject)——发布者 抽象观察者 (Observer) 具体观察者(ConcreteObserver）—订阅者 适用场景： 当一个抽象模型有两方面，其中一个方面依赖于另一个方面。将这两者封装在独立对象中以使它们可以各自独立地改变 和复用。 当对一个对象的改变需要同时改变其它对象，而不知道具体有多少对象有待改变。 当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之，你不希望这些对象是紧密耦合的。 优点： 目标和观察者之间的抽象耦合最小 支持广播通信 观察者模式（Observer Pattern）是一种行为型设计模式，它定义了对象之间的一对多依赖关系，使得当一个对象改变状态时，它的所有依赖对象都会收到通知并自动更新。 观察者模式涉及以下几个角色： 主题（Subject）：也称为被观察者或可观察对象，它维护一组观察者对象，并提供方法用于添加、删除和通知观察者。 观察者（Observer）：定义了接收主题通知并进行相应更新的方法。 具体主题（Concrete Subject）：实现了主题接口，维护了一组观察者对象，并在状态变化时发送通知给观察者。 具体观察者（Concrete Observer）：实现了观察者接口，定义了接收通知并进行相应更新的具体行为。 当主题的状态发生变化时，它会通知所有注册的观察者，观察者接收到通知后进行相应的更新操作。 from abc import abstractmethod, ABCMeta class Observer(metaclass=ABCMeta): def update(self, notices): pass # 具体主题 class Notices: def __init__(self): self.observers = [] def attach(self, observer): self.observers.append(observer) def detach(self, observer): self.observers.remove(observer) def notify(self): for observer in self.observers: observer.update(self) # 观察者接口 class StaffNotice(Notices): def __init__(self, company_info=None): super().__init__() self.__company_info = company_info @property def company_info(self): return self.__company_info @company_info.setter def company_info(self, info): self.__company_info = info self.notify() class Staff(Observer): def __init__(self): self.company_info = None def update(self, notices): self.company_info = notices.company_info notice = StaffNotice(\"初始化公司信息\") s1 = Staff() s2 = Staff() notice.attach(s1) notice.attach(s2) notice.company_info = \"公司今年业绩很好\" print(s1.company_info) print(s2.company_info) notice.detach(s2) notice.company_info = \"公司明年业绩也很好\" print(s1.company_info) print(s2.company_info) # 主题接口 class Subject: def attach(self, observer): pass def detach(self, observer): pass def notify(self): pass # 具体主题 class ConcreteSubject(Subject): def __init__(self): self.observers = [] def attach(self, observer): self.observers.append(observer) def detach(self, observer): self.observers.remove(observer) def notify(self): for observer in self.observers: observer.update() # 观察者接口 class Observer: def update(self): pass # 具体观察者A class ConcreteObserverA(Observer): def update(self): print(\"ConcreteObserverA 收到通知并进行更新\") # 具体观察者B class ConcreteObserverB(Observer): def update(self): print(\"ConcreteObserverB 收到通知并进行更新\") # 客户端代码 subject = ConcreteSubject() observerA = ConcreteObserverA() observerB = ConcreteObserverB() subject.attach(observerA) subject.attach(observerB) subject.notify() console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"she-ji-mo-shi/ce-lve-mo-shi.html":{"url":"she-ji-mo-shi/ce-lve-mo-shi.html","title":"策略模式","keywords":"","body":"策略模式策略模式 内容：定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使 得算法可独立于使用它的客户而变化。 角色： 抽象策略 (Strategy) 具体策略 (ConcreteStrategy) 上下文(Context) 优点： 定义了一系列可重用的算法和行大 消除了一些条件语句 可以提供相同行为的不同实现 缺点： 客户必须了解不同的策略 策略模式（Strategy Pattern）是一种行为型设计模式，它允许在运行时选择算法的行为，使得可以根据需求动态地切换不同的算法或策略，而不必修改使用算法的代码。策略模式提供了一种将算法独立于客户端代码的方式，使得客户端代码更加灵活和可维护。 策略模式通常包括以下角色： 上下文（Context）：上下文类包含一个成员变量，用于保存当前所选的策略对象。上下文类还提供了一个方法，用于设置和切换策略，以及执行策略算法。 策略接口（Strategy Interface）：策略接口定义了一个或多个算法的方法，具体的策略类必须实现这个接口。 具体策略（Concrete Strategy）：具体策略类实现了策略接口，提供了具体的算法实现。不同的具体策略类可以有不同的算法实现。 from abc import ABCMeta, abstractmethod class Strategy(metaclass=ABCMeta): @abstractmethod def execute(self, data): pass class FastStrategy(Strategy): def execute(self, data): print(\"较快的策略%s\", data) class SlowStrategy(Strategy): def execute(self, data): print(\"较慢的策略%s\", data) class Context: def __init__(self, data, strategy): self.data = data self.strategy = strategy def set_strategy(self, strategy): self.strategy = strategy def do_strategy(self): self.strategy.execute(self.data) data = \"[....]\" s1 = FastStrategy() s2 = SlowStrategy() context = Context(data, s1) context.do_strategy() context.set_strategy(s2) context.do_strategy() # --------------------------------------------------------------- # 定义策略接口 class PaymentStrategy: def pay(self, amount): pass # 具体策略类1：信用卡支付 class CreditCardPayment(PaymentStrategy): def pay(self, amount): print(f\"Paid ${amount} with Credit Card\") # 具体策略类2：支付宝支付 class AlipayPayment(PaymentStrategy): def pay(self, amount): print(f\"Paid ${amount} with Alipay\") # 上下文类 class ShoppingCart: def __init__(self, payment_strategy): self.payment_strategy = payment_strategy def checkout(self, amount): self.payment_strategy.pay(amount) # 客户端代码 if __name__ == \"__main__\": credit_card_payment = CreditCardPayment() alipay_payment = AlipayPayment() cart1 = ShoppingCart(credit_card_payment) cart1.checkout(100.0) # 输出 \"Paid $100.0 with Credit Card\" cart2 = ShoppingCart(alipay_payment) cart2.checkout(50.0) # 输出 \"Paid $50.0 with Alipay\" console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"she-ji-mo-shi/mo-ban-fang-fa-mo-shi.html":{"url":"she-ji-mo-shi/mo-ban-fang-fa-mo-shi.html","title":"模版方法模式","keywords":"","body":"模版方法模式模版方法模式 内容：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 角色： 抽象类(AbstractClass)：定义抽象的原子操作（钩子操作）；实现一个模 板方法作为算法的骨架。 具体类 (ConcreteClass 实现原子操作 模板方法模式（Template Method Pattern）是一种行为型设计模式，它定义了一个算法的骨架，将一些步骤的具体实现延迟到子类。这意味着模板方法模式允许在父类中定义算法的结构，同时允许子类提供算法的具体实现。 模板方法模式通常包括以下角色： 抽象类（Abstract Class）：抽象类定义了算法的骨架，包括算法的结构和一些抽象方法，这些方法由子类实现。 具体类（Concrete Class）：具体类继承自抽象类，并实现了抽象方法，提供了算法的具体实现。 from time import sleep from abc import ABCMeta, abstractmethod class Window(metaclass=ABCMeta): def start(self): pass def repaint(self): pass def stop(self): pass def run(self): self.start() while True: try: self.repaint() sleep(1) except KeyboardInterrupt: break self.stop() class MyWindows(Window): def __init__(self, msg): self.msg = msg def start(self): print(\"窗口开始运行\") def stop(self): print(\"窗口结束运行\") def repaint(self): print(self.msg) MyWindows(\"hello -----\").run() # 抽象类 class AbstractClass: def template_method(self): self.step1() self.step2() def step1(self): pass def step2(self): pass # 具体类1 class ConcreteClass1(AbstractClass): def step1(self): print(\"ConcreteClass1 - Step 1\") def step2(self): print(\"ConcreteClass1 - Step 2\") # 具体类2 class ConcreteClass2(AbstractClass): def step1(self): print(\"ConcreteClass2 - Step 1\") def step2(self): print(\"ConcreteClass2 - Step 2\") concrete1 = ConcreteClass1() concrete1.template_method() \"\"\" 输出: ConcreteClass1 - Step 1 ConcreteClass1 - Step 2 \"\"\" concrete2 = ConcreteClass2() concrete2.template_method() \"\"\" 输出: ConcreteClass2 - Step 1 ConcreteClass2 - Step 2 \"\"\" console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"mian-xiang-dui-xiang.html":{"url":"mian-xiang-dui-xiang.html","title":"面相对象","keywords":"","body":"面相对象面相对象 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"}}